#pragma once
#include <cstdint>
#include "!GlobalTypes.hpp"

// /////////////////////////////////////////////////////////////
// Binary: server.dll
// Classes count: 803
// Enums count: 162
// Created using source2gen - github.com/neverlosecc/source2gen
// /////////////////////////////////////////////////////////////

// Alignment: 4
// Size: 0x3
enum class PointTemplateOwnerSpawnGroupType_t : uint32_t
{
	INSERT_INTO_POINT_TEMPLATE_SPAWN_GROUP = 0x0,
	INSERT_INTO_CURRENTLY_ACTIVE_SPAWN_GROUP = 0x1,
	INSERT_INTO_NEWLY_CREATED_SPAWN_GROUP = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class PointTemplateClientOnlyEntityBehavior_t : uint32_t
{
	CREATE_FOR_CURRENTLY_CONNECTED_CLIENTS_ONLY = 0x0,
	CREATE_FOR_CLIENTS_WHO_CONNECT_LATER = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class PerformanceMode_t : uint32_t
{
	PM_NORMAL = 0x0,
	PM_NO_GIBS = 0x1,
	PM_FULL_GIBS = 0x2,
	PM_REDUCED_GIBS = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class ChatIgnoreType_t : uint32_t
{
	CHAT_IGNORE_NONE = 0x0,
	CHAT_IGNORE_ALL = 0x1,
	CHAT_IGNORE_TEAM = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class CommandExecMode_t : uint32_t
{
	EXEC_MANUAL = 0x0,
	EXEC_LEVELSTART = 0x1,
	EXEC_PERIODIC = 0x2,
	EXEC_MODES_COUNT = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class CommandEntitySpecType_t : uint32_t
{
	SPEC_SEARCH = 0x0,
	SPEC_TYPES_COUNT = 0x1,
};

// Alignment: 4
// Size: 0x54
enum class GameAnimEventIndex_t : uint32_t
{
	AE_EMPTY = 0x0,
	AE_CL_PLAYSOUND = 0x1,
	AE_CL_PLAYSOUND_ATTACHMENT = 0x2,
	AE_CL_PLAYSOUND_POSITION = 0x3,
	AE_SV_PLAYSOUND = 0x4,
	AE_CL_STOPSOUND = 0x5,
	AE_CL_PLAYSOUND_LOOPING = 0x6,
	AE_CLIENT_EFFECT_ATTACH = 0x7,
	AE_CL_CREATE_PARTICLE_EFFECT = 0x8,
	AE_CL_STOP_PARTICLE_EFFECT = 0x9,
	AE_CL_ADD_PARTICLE_EFFECT_CP = 0xa,
	AE_CL_CREATE_PARTICLE_EFFECT_CFG = 0xb,
	AE_CL_SUPPRESS_EVENTS_WITH_TAG = 0xc,
	AE_START_SCRIPTED_EFFECT = 0xd,
	AE_STOP_SCRIPTED_EFFECT = 0xe,
	AE_MUZZLEFLASH = 0xf,
	AE_SV_CREATE_PARTICLE_EFFECT_CFG = 0x10,
	AE_SV_STOP_PARTICLE_EFFECT = 0x11,
	AE_CL_HIDE_PARTICLE_EFFECT = 0x12,
	AE_CL_SHOW_PARTICLE_EFFECT = 0x13,
	AE_FOOTSTEP = 0x14,
	AE_CL_FOOTSTEP_LEFT = 0x15,
	AE_CL_FOOTSTEP_RIGHT = 0x16,
	AE_CL_MFOOTSTEP_LEFT = 0x17,
	AE_CL_MFOOTSTEP_RIGHT = 0x18,
	AE_CL_MFOOTSTEP_LEFT_LOUD = 0x19,
	AE_CL_MFOOTSTEP_RIGHT_LOUD = 0x1a,
	AE_RAGDOLL = 0x1b,
	AE_CL_ENABLE_BODYGROUP = 0x1c,
	AE_CL_DISABLE_BODYGROUP = 0x1d,
	AE_CL_BODYGROUP_SET_VALUE = 0x1e,
	AE_SV_BODYGROUP_SET_VALUE = 0x1f,
	AE_CL_BODYGROUP_SET_VALUE_CMODEL_WPN = 0x20,
	AE_WPN_PRIMARYATTACK = 0x21,
	AE_WPN_PLAYWPNSOUND = 0x22,
	AE_WPN_SECONDARYATTACK = 0x23,
	AE_CL_SPEECH = 0x24,
	AE_FIRE_INPUT = 0x25,
	AE_IK_SET_LOCK_ROTATION_ALPHA = 0x26,
	AE_IK_ALLOW_PLANE_TILT_NORMAL_UPDATES = 0x27,
	AE_IK_SET_MASTER_BLEND_AMOUNT = 0x28,
	AE_IK_SET_CHAIN_BLEND_AMOUNT = 0x29,
	AE_CL_CLOTH_ATTR = 0x2a,
	AE_CL_CLOTH_GROUND_OFFSET = 0x2b,
	AE_CL_CLOTH_STIFFEN = 0x2c,
	AE_CL_CLOTH_EFFECT = 0x2d,
	AE_CL_CREATE_ANIM_SCOPE_PROP = 0x2e,
	AE_HAPTIC_PULSE = 0x2f,
	AE_NPC_LEFTFOOT = 0x30,
	AE_NPC_RIGHTFOOT = 0x31,
	AE_NPC_BODYDROP_LIGHT = 0x32,
	AE_NPC_BODYDROP_HEAVY = 0x33,
	AE_NPC_SWISHSOUND = 0x34,
	AE_NPC_WEAPON_DROP = 0x35,
	AE_NPC_RAGDOLL = 0x36,
	AE_NPC_ATTACK_BROADCAST = 0x37,
	AE_NPC_GIB = 0x38,
	AE_NPC_BECOME_TEMPORARY_RAGDOLL = 0x39,
	AE_NPC_START_POWERED_RAGDOLL = 0x3a,
	AE_NPC_END_POWERED_RAGDOLL = 0x3b,
	AE_NPC_HURT_INTERACTION_PARTNER = 0x3c,
	AE_NPC_SET_INTERACTION_CANTDIE = 0x3d,
	AE_SOUND_EMITTED = 0x3e,
	AE_NPC_ITEM_PICKUP = 0x3f,
	AE_TOSS_ITEM = 0x40,
	AE_NPC_HOLSTER = 0x41,
	AE_NPC_DRAW = 0x42,
	AE_NPC_WEAPON_FIRE = 0x43,
	AE_NPC_WEAPON_FIRE_SHARED = 0x44,
	AE_WEAPON_MELEE_HIT = 0x45,
	AE_WEAPON_RELOAD = 0x46,
	AE_ABILITY_PERFORM_ABILITY = 0x47,
	AE_ABILITY_PERFORM_ABILITY2 = 0x48,
	AE_ABILITY_PERFORM_ABILITY3 = 0x49,
	AE_ABILITY_WEAPON_ACTIVATE = 0x4a,
	AE_ABILITY_WEAPON_DEACTIVATE = 0x4b,
	AE_SCRIPT_EVENT_NOINTERRUPT = 0x4c,
	AE_SCRIPT_EVENT_CANINTERRUPT = 0x4d,
	AE_SCRIPT_EVENT_FIREEVENT = 0x4e,
	AE_SCRIPT_EVENT_DEAD = 0x4f,
	AE_SCRIPT_EVENT_NOT_DEAD = 0x50,
	AE_SCRIPT_EVENT_FIRE_INPUT = 0x51,
	AE_SCRIPT_EVENT_CUSTOMINTERRUPT_START = 0x52,
	AE_SCRIPT_EVENT_CUSTOMINTERRUPT_END = 0x53,
};

// Alignment: 4
// Size: 0x9
enum class ObserverMode_t : uint32_t
{
	OBS_MODE_NONE = 0x0,
	OBS_MODE_DEATHCAM = 0x1,
	OBS_MODE_FREEZECAM = 0x2,
	OBS_MODE_FIXED = 0x3,
	OBS_MODE_IN_EYE = 0x4,
	OBS_MODE_CHASE = 0x5,
	OBS_MODE_ROAMING = 0x6,
	OBS_MODE_DIRECTED = 0x7,
	NUM_OBSERVER_MODES = 0x8,
};

// Alignment: 4
// Size: 0x1b
enum class RumbleEffect_t : uint32_t
{
	RUMBLE_INVALID = 0xffffffffffffffff,
	RUMBLE_STOP_ALL = 0x0,
	RUMBLE_PISTOL = 0x1,
	RUMBLE_357 = 0x2,
	RUMBLE_SMG1 = 0x3,
	RUMBLE_AR2 = 0x4,
	RUMBLE_SHOTGUN_SINGLE = 0x5,
	RUMBLE_SHOTGUN_DOUBLE = 0x6,
	RUMBLE_AR2_ALT_FIRE = 0x7,
	RUMBLE_RPG_MISSILE = 0x8,
	RUMBLE_CROWBAR_SWING = 0x9,
	RUMBLE_AIRBOAT_GUN = 0xa,
	RUMBLE_JEEP_ENGINE_LOOP = 0xb,
	RUMBLE_FLAT_LEFT = 0xc,
	RUMBLE_FLAT_RIGHT = 0xd,
	RUMBLE_FLAT_BOTH = 0xe,
	RUMBLE_DMG_LOW = 0xf,
	RUMBLE_DMG_MED = 0x10,
	RUMBLE_DMG_HIGH = 0x11,
	RUMBLE_FALL_LONG = 0x12,
	RUMBLE_FALL_SHORT = 0x13,
	RUMBLE_PHYSCANNON_OPEN = 0x14,
	RUMBLE_PHYSCANNON_PUNT = 0x15,
	RUMBLE_PHYSCANNON_LOW = 0x16,
	RUMBLE_PHYSCANNON_MEDIUM = 0x17,
	RUMBLE_PHYSCANNON_HIGH = 0x18,
	NUM_RUMBLE_EFFECTS = 0x19,
};

// Alignment: 4
// Size: 0xe
enum class WeaponSound_t : uint32_t
{
	WEAPON_SOUND_EMPTY = 0x0,
	WEAPON_SOUND_SINGLE = 0x1,
	WEAPON_SOUND_DOUBLE = 0x2,
	WEAPON_SOUND_RELOAD = 0x3,
	WEAPON_SOUND_MELEE_MISS = 0x4,
	WEAPON_SOUND_MELEE_HIT = 0x5,
	WEAPON_SOUND_MELEE_HIT_WORLD = 0x6,
	WEAPON_SOUND_MELEE_HIT_PLAYER = 0x7,
	WEAPON_SOUND_SPECIAL1 = 0x8,
	WEAPON_SOUND_SPECIAL2 = 0x9,
	WEAPON_SOUND_SPECIAL3 = 0xa,
	WEAPON_SOUND_NEARLYEMPTY = 0xb,
	WEAPON_SOUND_IMPACT1 = 0xc,
	WEAPON_SOUND_NUM_TYPES = 0xd,
};

// Alignment: 4
// Size: 0x404
enum class BaseActivity_t : uint32_t
{
	ACT_RESET = 0x0,
	ACT_IDLE = 0x1,
	ACT_TRANSITION = 0x2,
	ACT_COVER = 0x3,
	ACT_COVER_MED = 0x4,
	ACT_COVER_LOW = 0x5,
	ACT_WALK = 0x6,
	ACT_WALK_AIM = 0x7,
	ACT_WALK_CROUCH = 0x8,
	ACT_WALK_CROUCH_AIM = 0x9,
	ACT_RUN = 0xa,
	ACT_RUN_AIM = 0xb,
	ACT_RUN_CROUCH = 0xc,
	ACT_RUN_CROUCH_AIM = 0xd,
	ACT_RUN_PROTECTED = 0xe,
	ACT_SCRIPT_CUSTOM_MOVE = 0xf,
	ACT_RANGE_ATTACK1 = 0x10,
	ACT_RANGE_ATTACK2 = 0x11,
	ACT_RANGE_ATTACK1_LOW = 0x12,
	ACT_RANGE_ATTACK2_LOW = 0x13,
	ACT_DIESIMPLE = 0x14,
	ACT_DIEBACKWARD = 0x15,
	ACT_DIEFORWARD = 0x16,
	ACT_DIEVIOLENT = 0x17,
	ACT_DIERAGDOLL = 0x18,
	ACT_FLY = 0x19,
	ACT_HOVER = 0x1a,
	ACT_GLIDE = 0x1b,
	ACT_SWIM = 0x1c,
	ACT_JUMP = 0x1d,
	ACT_HOP = 0x1e,
	ACT_LEAP = 0x1f,
	ACT_LAND = 0x20,
	ACT_CLIMB_UP = 0x21,
	ACT_CLIMB_DOWN = 0x22,
	ACT_CLIMB_DISMOUNT = 0x23,
	ACT_SHIPLADDER_UP = 0x24,
	ACT_SHIPLADDER_DOWN = 0x25,
	ACT_STRAFE_LEFT = 0x26,
	ACT_STRAFE_RIGHT = 0x27,
	ACT_ROLL_LEFT = 0x28,
	ACT_ROLL_RIGHT = 0x29,
	ACT_TURN_LEFT = 0x2a,
	ACT_TURN_RIGHT = 0x2b,
	ACT_CROUCH = 0x2c,
	ACT_CROUCHIDLE = 0x2d,
	ACT_STAND = 0x2e,
	ACT_USE = 0x2f,
	ACT_ALIEN_BURROW_IDLE = 0x30,
	ACT_ALIEN_BURROW_OUT = 0x31,
	ACT_SIGNAL1 = 0x32,
	ACT_SIGNAL2 = 0x33,
	ACT_SIGNAL3 = 0x34,
	ACT_SIGNAL_ADVANCE = 0x35,
	ACT_SIGNAL_FORWARD = 0x36,
	ACT_SIGNAL_GROUP = 0x37,
	ACT_SIGNAL_HALT = 0x38,
	ACT_SIGNAL_LEFT = 0x39,
	ACT_SIGNAL_RIGHT = 0x3a,
	ACT_SIGNAL_TAKECOVER = 0x3b,
	ACT_LOOKBACK_RIGHT = 0x3c,
	ACT_LOOKBACK_LEFT = 0x3d,
	ACT_COWER = 0x3e,
	ACT_SMALL_FLINCH = 0x3f,
	ACT_BIG_FLINCH = 0x40,
	ACT_MELEE_ATTACK1 = 0x41,
	ACT_MELEE_ATTACK2 = 0x42,
	ACT_RELOAD = 0x43,
	ACT_RELOAD_START = 0x44,
	ACT_RELOAD_FINISH = 0x45,
	ACT_RELOAD_LOW = 0x46,
	ACT_ARM = 0x47,
	ACT_DISARM = 0x48,
	ACT_DROP_WEAPON = 0x49,
	ACT_DROP_WEAPON_SHOTGUN = 0x4a,
	ACT_PICKUP_GROUND = 0x4b,
	ACT_PICKUP_RACK = 0x4c,
	ACT_IDLE_ANGRY = 0x4d,
	ACT_IDLE_RELAXED = 0x4e,
	ACT_IDLE_STIMULATED = 0x4f,
	ACT_IDLE_AGITATED = 0x50,
	ACT_IDLE_STEALTH = 0x51,
	ACT_IDLE_HURT = 0x52,
	ACT_WALK_RELAXED = 0x53,
	ACT_WALK_STIMULATED = 0x54,
	ACT_WALK_AGITATED = 0x55,
	ACT_WALK_STEALTH = 0x56,
	ACT_RUN_RELAXED = 0x57,
	ACT_RUN_STIMULATED = 0x58,
	ACT_RUN_AGITATED = 0x59,
	ACT_RUN_STEALTH = 0x5a,
	ACT_IDLE_AIM_RELAXED = 0x5b,
	ACT_IDLE_AIM_STIMULATED = 0x5c,
	ACT_IDLE_AIM_AGITATED = 0x5d,
	ACT_IDLE_AIM_STEALTH = 0x5e,
	ACT_WALK_AIM_RELAXED = 0x5f,
	ACT_WALK_AIM_STIMULATED = 0x60,
	ACT_WALK_AIM_AGITATED = 0x61,
	ACT_WALK_AIM_STEALTH = 0x62,
	ACT_RUN_AIM_RELAXED = 0x63,
	ACT_RUN_AIM_STIMULATED = 0x64,
	ACT_RUN_AIM_AGITATED = 0x65,
	ACT_RUN_AIM_STEALTH = 0x66,
	ACT_CROUCHIDLE_STIMULATED = 0x67,
	ACT_CROUCHIDLE_AIM_STIMULATED = 0x68,
	ACT_CROUCHIDLE_AGITATED = 0x69,
	ACT_WALK_HURT = 0x6a,
	ACT_RUN_HURT = 0x6b,
	ACT_SPECIAL_ATTACK1 = 0x6c,
	ACT_SPECIAL_ATTACK2 = 0x6d,
	ACT_COMBAT_IDLE = 0x6e,
	ACT_WALK_SCARED = 0x6f,
	ACT_RUN_SCARED = 0x70,
	ACT_VICTORY_DANCE = 0x71,
	ACT_DIE_HEADSHOT = 0x72,
	ACT_DIE_CHESTSHOT = 0x73,
	ACT_DIE_GUTSHOT = 0x74,
	ACT_DIE_BACKSHOT = 0x75,
	ACT_FLINCH_HEAD = 0x76,
	ACT_FLINCH_CHEST = 0x77,
	ACT_FLINCH_STOMACH = 0x78,
	ACT_FLINCH_LEFTARM = 0x79,
	ACT_FLINCH_RIGHTARM = 0x7a,
	ACT_FLINCH_LEFTLEG = 0x7b,
	ACT_FLINCH_RIGHTLEG = 0x7c,
	ACT_FLINCH_PHYSICS = 0x7d,
	ACT_FLINCH_HEAD_BACK = 0x7e,
	ACT_FLINCH_CHEST_BACK = 0x7f,
	ACT_FLINCH_STOMACH_BACK = 0x80,
	ACT_FLINCH_CROUCH_FRONT = 0x81,
	ACT_FLINCH_CROUCH_BACK = 0x82,
	ACT_FLINCH_CROUCH_LEFT = 0x83,
	ACT_FLINCH_CROUCH_RIGHT = 0x84,
	ACT_IDLE_ON_FIRE = 0x85,
	ACT_WALK_ON_FIRE = 0x86,
	ACT_RUN_ON_FIRE = 0x87,
	ACT_180_LEFT = 0x89,
	ACT_180_RIGHT = 0x8a,
	ACT_90_LEFT = 0x8b,
	ACT_90_RIGHT = 0x8c,
	ACT_STEP_LEFT = 0x8d,
	ACT_STEP_RIGHT = 0x8e,
	ACT_STEP_BACK = 0x8f,
	ACT_STEP_FORE = 0x90,
	ACT_GESTURE_RANGE_ATTACK1 = 0x91,
	ACT_GESTURE_RANGE_ATTACK2 = 0x92,
	ACT_GESTURE_MELEE_ATTACK1 = 0x93,
	ACT_GESTURE_MELEE_ATTACK2 = 0x94,
	ACT_GESTURE_RANGE_ATTACK1_LOW = 0x95,
	ACT_GESTURE_RANGE_ATTACK2_LOW = 0x96,
	ACT_MELEE_ATTACK_SWING_GESTURE = 0x97,
	ACT_GESTURE_SMALL_FLINCH = 0x98,
	ACT_GESTURE_BIG_FLINCH = 0x99,
	ACT_GESTURE_FLINCH_BLAST = 0x9a,
	ACT_GESTURE_FLINCH_BLAST_SHOTGUN = 0x9b,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED = 0x9c,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN = 0x9d,
	ACT_GESTURE_FLINCH_HEAD = 0x9e,
	ACT_GESTURE_FLINCH_CHEST = 0x9f,
	ACT_GESTURE_FLINCH_STOMACH = 0xa0,
	ACT_GESTURE_FLINCH_LEFTARM = 0xa1,
	ACT_GESTURE_FLINCH_RIGHTARM = 0xa2,
	ACT_GESTURE_FLINCH_LEFTLEG = 0xa3,
	ACT_GESTURE_FLINCH_RIGHTLEG = 0xa4,
	ACT_GESTURE_TURN_LEFT = 0xa5,
	ACT_GESTURE_TURN_RIGHT = 0xa6,
	ACT_GESTURE_TURN_LEFT45 = 0xa7,
	ACT_GESTURE_TURN_RIGHT45 = 0xa8,
	ACT_GESTURE_TURN_LEFT90 = 0xa9,
	ACT_GESTURE_TURN_RIGHT90 = 0xaa,
	ACT_GESTURE_TURN_LEFT45_FLAT = 0xab,
	ACT_GESTURE_TURN_RIGHT45_FLAT = 0xac,
	ACT_GESTURE_TURN_LEFT90_FLAT = 0xad,
	ACT_GESTURE_TURN_RIGHT90_FLAT = 0xae,
	ACT_BARNACLE_HIT = 0xaf,
	ACT_BARNACLE_PULL = 0xb0,
	ACT_BARNACLE_CHOMP = 0xb1,
	ACT_BARNACLE_CHEW = 0xb2,
	ACT_DO_NOT_DISTURB = 0xb3,
	ACT_SPECIFIC_SEQUENCE = 0xb4,
	ACT_VM_DEPLOY = 0xb5,
	ACT_VM_RELOAD_EMPTY = 0xb6,
	ACT_VM_DRAW = 0xb7,
	ACT_VM_HOLSTER = 0xb8,
	ACT_VM_IDLE = 0xb9,
	ACT_VM_FIDGET = 0xba,
	ACT_VM_PULLBACK = 0xbb,
	ACT_VM_PULLBACK_HIGH = 0xbc,
	ACT_VM_PULLBACK_LOW = 0xbd,
	ACT_VM_THROW = 0xbe,
	ACT_VM_DROP = 0xbf,
	ACT_VM_PULLPIN = 0xc0,
	ACT_VM_PRIMARYATTACK = 0xc1,
	ACT_VM_SECONDARYATTACK = 0xc2,
	ACT_VM_RELOAD = 0xc3,
	ACT_VM_DRYFIRE = 0xc4,
	ACT_VM_HITLEFT = 0xc5,
	ACT_VM_HITLEFT2 = 0xc6,
	ACT_VM_HITRIGHT = 0xc7,
	ACT_VM_HITRIGHT2 = 0xc8,
	ACT_VM_HITCENTER = 0xc9,
	ACT_VM_HITCENTER2 = 0xca,
	ACT_VM_MISSLEFT = 0xcb,
	ACT_VM_MISSLEFT2 = 0xcc,
	ACT_VM_MISSRIGHT = 0xcd,
	ACT_VM_MISSRIGHT2 = 0xce,
	ACT_VM_MISSCENTER = 0xcf,
	ACT_VM_MISSCENTER2 = 0xd0,
	ACT_VM_HAULBACK = 0xd1,
	ACT_VM_SWINGHARD = 0xd2,
	ACT_VM_SWINGMISS = 0xd3,
	ACT_VM_SWINGHIT = 0xd4,
	ACT_VM_IDLE_TO_LOWERED = 0xd5,
	ACT_VM_IDLE_LOWERED = 0xd6,
	ACT_VM_LOWERED_TO_IDLE = 0xd7,
	ACT_VM_RECOIL1 = 0xd8,
	ACT_VM_RECOIL2 = 0xd9,
	ACT_VM_RECOIL3 = 0xda,
	ACT_VM_PICKUP = 0xdb,
	ACT_VM_RELEASE = 0xdc,
	ACT_VM_MAUL_LOOP = 0xdd,
	ACT_VM_ATTACH_SILENCER = 0xde,
	ACT_VM_DETACH_SILENCER = 0xdf,
	ACT_SLAM_STICKWALL_IDLE = 0xe0,
	ACT_SLAM_STICKWALL_ND_IDLE = 0xe1,
	ACT_SLAM_STICKWALL_ATTACH = 0xe2,
	ACT_SLAM_STICKWALL_ATTACH2 = 0xe3,
	ACT_SLAM_STICKWALL_ND_ATTACH = 0xe4,
	ACT_SLAM_STICKWALL_ND_ATTACH2 = 0xe5,
	ACT_SLAM_STICKWALL_DETONATE = 0xe6,
	ACT_SLAM_STICKWALL_DETONATOR_HOLSTER = 0xe7,
	ACT_SLAM_STICKWALL_DRAW = 0xe8,
	ACT_SLAM_STICKWALL_ND_DRAW = 0xe9,
	ACT_SLAM_STICKWALL_TO_THROW = 0xea,
	ACT_SLAM_STICKWALL_TO_THROW_ND = 0xeb,
	ACT_SLAM_STICKWALL_TO_TRIPMINE_ND = 0xec,
	ACT_SLAM_THROW_IDLE = 0xed,
	ACT_SLAM_THROW_ND_IDLE = 0xee,
	ACT_SLAM_THROW_THROW = 0xef,
	ACT_SLAM_THROW_THROW2 = 0xf0,
	ACT_SLAM_THROW_THROW_ND = 0xf1,
	ACT_SLAM_THROW_THROW_ND2 = 0xf2,
	ACT_SLAM_THROW_DRAW = 0xf3,
	ACT_SLAM_THROW_ND_DRAW = 0xf4,
	ACT_SLAM_THROW_TO_STICKWALL = 0xf5,
	ACT_SLAM_THROW_TO_STICKWALL_ND = 0xf6,
	ACT_SLAM_THROW_DETONATE = 0xf7,
	ACT_SLAM_THROW_DETONATOR_HOLSTER = 0xf8,
	ACT_SLAM_THROW_TO_TRIPMINE_ND = 0xf9,
	ACT_SLAM_TRIPMINE_IDLE = 0xfa,
	ACT_SLAM_TRIPMINE_DRAW = 0xfb,
	ACT_SLAM_TRIPMINE_ATTACH = 0xfc,
	ACT_SLAM_TRIPMINE_ATTACH2 = 0xfd,
	ACT_SLAM_TRIPMINE_TO_STICKWALL_ND = 0xfe,
	ACT_SLAM_TRIPMINE_TO_THROW_ND = 0xff,
	ACT_SLAM_DETONATOR_IDLE = 0x100,
	ACT_SLAM_DETONATOR_DRAW = 0x101,
	ACT_SLAM_DETONATOR_DETONATE = 0x102,
	ACT_SLAM_DETONATOR_HOLSTER = 0x103,
	ACT_SLAM_DETONATOR_STICKWALL_DRAW = 0x104,
	ACT_SLAM_DETONATOR_THROW_DRAW = 0x105,
	ACT_SHOTGUN_RELOAD_START = 0x106,
	ACT_SHOTGUN_RELOAD_FINISH = 0x107,
	ACT_SHOTGUN_PUMP = 0x108,
	ACT_SMG2_IDLE2 = 0x109,
	ACT_SMG2_FIRE2 = 0x10a,
	ACT_SMG2_DRAW2 = 0x10b,
	ACT_SMG2_RELOAD2 = 0x10c,
	ACT_SMG2_DRYFIRE2 = 0x10d,
	ACT_SMG2_TOAUTO = 0x10e,
	ACT_SMG2_TOBURST = 0x10f,
	ACT_PHYSCANNON_UPGRADE = 0x110,
	ACT_RANGE_ATTACK_AR1 = 0x111,
	ACT_RANGE_ATTACK_AR2 = 0x112,
	ACT_RANGE_ATTACK_AR2_LOW = 0x113,
	ACT_RANGE_ATTACK_AR2_GRENADE = 0x114,
	ACT_RANGE_ATTACK_HMG1 = 0x115,
	ACT_RANGE_ATTACK_ML = 0x116,
	ACT_RANGE_ATTACK_SMG1 = 0x117,
	ACT_RANGE_ATTACK_SMG1_LOW = 0x118,
	ACT_RANGE_ATTACK_SMG2 = 0x119,
	ACT_RANGE_ATTACK_SHOTGUN = 0x11a,
	ACT_RANGE_ATTACK_SHOTGUN_LOW = 0x11b,
	ACT_RANGE_ATTACK_PISTOL = 0x11c,
	ACT_RANGE_ATTACK_PISTOL_LOW = 0x11d,
	ACT_RANGE_ATTACK_SLAM = 0x11e,
	ACT_RANGE_ATTACK_TRIPWIRE = 0x11f,
	ACT_RANGE_ATTACK_THROW = 0x120,
	ACT_RANGE_ATTACK_SNIPER_RIFLE = 0x121,
	ACT_RANGE_ATTACK_RPG = 0x122,
	ACT_MELEE_ATTACK_SWING = 0x123,
	ACT_RANGE_AIM_LOW = 0x124,
	ACT_RANGE_AIM_SMG1_LOW = 0x125,
	ACT_RANGE_AIM_PISTOL_LOW = 0x126,
	ACT_RANGE_AIM_AR2_LOW = 0x127,
	ACT_COVER_PISTOL_LOW = 0x128,
	ACT_COVER_SMG1_LOW = 0x129,
	ACT_GESTURE_RANGE_ATTACK_AR1 = 0x12a,
	ACT_GESTURE_RANGE_ATTACK_AR2 = 0x12b,
	ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE = 0x12c,
	ACT_GESTURE_RANGE_ATTACK_HMG1 = 0x12d,
	ACT_GESTURE_RANGE_ATTACK_ML = 0x12e,
	ACT_GESTURE_RANGE_ATTACK_SMG1 = 0x12f,
	ACT_GESTURE_RANGE_ATTACK_SMG1_LOW = 0x130,
	ACT_GESTURE_RANGE_ATTACK_SMG2 = 0x131,
	ACT_GESTURE_RANGE_ATTACK_SHOTGUN = 0x132,
	ACT_GESTURE_RANGE_ATTACK_PISTOL = 0x133,
	ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW = 0x134,
	ACT_GESTURE_RANGE_ATTACK_SLAM = 0x135,
	ACT_GESTURE_RANGE_ATTACK_TRIPWIRE = 0x136,
	ACT_GESTURE_RANGE_ATTACK_THROW = 0x137,
	ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE = 0x138,
	ACT_GESTURE_MELEE_ATTACK_SWING = 0x139,
	ACT_IDLE_RIFLE = 0x13a,
	ACT_IDLE_SMG1 = 0x13b,
	ACT_IDLE_ANGRY_SMG1 = 0x13c,
	ACT_IDLE_PISTOL = 0x13d,
	ACT_IDLE_ANGRY_PISTOL = 0x13e,
	ACT_IDLE_ANGRY_SHOTGUN = 0x13f,
	ACT_IDLE_STEALTH_PISTOL = 0x140,
	ACT_IDLE_PACKAGE = 0x141,
	ACT_WALK_PACKAGE = 0x142,
	ACT_IDLE_SUITCASE = 0x143,
	ACT_WALK_SUITCASE = 0x144,
	ACT_IDLE_SMG1_RELAXED = 0x145,
	ACT_IDLE_SMG1_STIMULATED = 0x146,
	ACT_WALK_RIFLE_RELAXED = 0x147,
	ACT_RUN_RIFLE_RELAXED = 0x148,
	ACT_WALK_RIFLE_STIMULATED = 0x149,
	ACT_RUN_RIFLE_STIMULATED = 0x14a,
	ACT_IDLE_AIM_RIFLE_STIMULATED = 0x14b,
	ACT_WALK_AIM_RIFLE_STIMULATED = 0x14c,
	ACT_RUN_AIM_RIFLE_STIMULATED = 0x14d,
	ACT_IDLE_SHOTGUN_RELAXED = 0x14e,
	ACT_IDLE_SHOTGUN_STIMULATED = 0x14f,
	ACT_IDLE_SHOTGUN_AGITATED = 0x150,
	ACT_WALK_ANGRY = 0x151,
	ACT_POLICE_HARASS1 = 0x152,
	ACT_POLICE_HARASS2 = 0x153,
	ACT_IDLE_MANNEDGUN = 0x154,
	ACT_IDLE_MELEE = 0x155,
	ACT_IDLE_ANGRY_MELEE = 0x156,
	ACT_IDLE_RPG_RELAXED = 0x157,
	ACT_IDLE_RPG = 0x158,
	ACT_IDLE_ANGRY_RPG = 0x159,
	ACT_COVER_LOW_RPG = 0x15a,
	ACT_WALK_RPG = 0x15b,
	ACT_RUN_RPG = 0x15c,
	ACT_WALK_CROUCH_RPG = 0x15d,
	ACT_RUN_CROUCH_RPG = 0x15e,
	ACT_WALK_RPG_RELAXED = 0x15f,
	ACT_RUN_RPG_RELAXED = 0x160,
	ACT_WALK_RIFLE = 0x161,
	ACT_WALK_AIM_RIFLE = 0x162,
	ACT_WALK_CROUCH_RIFLE = 0x163,
	ACT_WALK_CROUCH_AIM_RIFLE = 0x164,
	ACT_RUN_RIFLE = 0x165,
	ACT_RUN_AIM_RIFLE = 0x166,
	ACT_RUN_CROUCH_RIFLE = 0x167,
	ACT_RUN_CROUCH_AIM_RIFLE = 0x168,
	ACT_RUN_STEALTH_PISTOL = 0x169,
	ACT_WALK_AIM_SHOTGUN = 0x16a,
	ACT_RUN_AIM_SHOTGUN = 0x16b,
	ACT_WALK_PISTOL = 0x16c,
	ACT_RUN_PISTOL = 0x16d,
	ACT_WALK_AIM_PISTOL = 0x16e,
	ACT_RUN_AIM_PISTOL = 0x16f,
	ACT_WALK_STEALTH_PISTOL = 0x170,
	ACT_WALK_AIM_STEALTH_PISTOL = 0x171,
	ACT_RUN_AIM_STEALTH_PISTOL = 0x172,
	ACT_RELOAD_PISTOL = 0x173,
	ACT_RELOAD_PISTOL_LOW = 0x174,
	ACT_RELOAD_SMG1 = 0x175,
	ACT_RELOAD_SMG1_LOW = 0x176,
	ACT_RELOAD_SHOTGUN = 0x177,
	ACT_RELOAD_SHOTGUN_LOW = 0x178,
	ACT_GESTURE_RELOAD = 0x179,
	ACT_GESTURE_RELOAD_PISTOL = 0x17a,
	ACT_GESTURE_RELOAD_SMG1 = 0x17b,
	ACT_GESTURE_RELOAD_SHOTGUN = 0x17c,
	ACT_BUSY_LEAN_LEFT = 0x17d,
	ACT_BUSY_LEAN_LEFT_ENTRY = 0x17e,
	ACT_BUSY_LEAN_LEFT_EXIT = 0x17f,
	ACT_BUSY_LEAN_BACK = 0x180,
	ACT_BUSY_LEAN_BACK_ENTRY = 0x181,
	ACT_BUSY_LEAN_BACK_EXIT = 0x182,
	ACT_BUSY_SIT_GROUND = 0x183,
	ACT_BUSY_SIT_GROUND_ENTRY = 0x184,
	ACT_BUSY_SIT_GROUND_EXIT = 0x185,
	ACT_BUSY_SIT_CHAIR = 0x186,
	ACT_BUSY_SIT_CHAIR_ENTRY = 0x187,
	ACT_BUSY_SIT_CHAIR_EXIT = 0x188,
	ACT_BUSY_STAND = 0x189,
	ACT_BUSY_QUEUE = 0x18a,
	ACT_DUCK_DODGE = 0x18b,
	ACT_DIE_BARNACLE_SWALLOW = 0x18c,
	ACT_GESTURE_BARNACLE_STRANGLE = 0x18d,
	ACT_PHYSCANNON_DETACH = 0x18e,
	ACT_PHYSCANNON_ANIMATE = 0x18f,
	ACT_PHYSCANNON_ANIMATE_PRE = 0x190,
	ACT_PHYSCANNON_ANIMATE_POST = 0x191,
	ACT_DIE_FRONTSIDE = 0x192,
	ACT_DIE_RIGHTSIDE = 0x193,
	ACT_DIE_BACKSIDE = 0x194,
	ACT_DIE_LEFTSIDE = 0x195,
	ACT_DIE_CROUCH_FRONTSIDE = 0x196,
	ACT_DIE_CROUCH_RIGHTSIDE = 0x197,
	ACT_DIE_CROUCH_BACKSIDE = 0x198,
	ACT_DIE_CROUCH_LEFTSIDE = 0x199,
	ACT_DIE_INCAP = 0x19a,
	ACT_DIE_STANDING = 0x19b,
	ACT_OPEN_DOOR = 0x19c,
	ACT_DI_ALYX_ZOMBIE_MELEE = 0x19d,
	ACT_DI_ALYX_ZOMBIE_TORSO_MELEE = 0x19e,
	ACT_DI_ALYX_HEADCRAB_MELEE = 0x19f,
	ACT_DI_ALYX_ANTLION = 0x1a0,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN64 = 0x1a1,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN26 = 0x1a2,
	ACT_READINESS_RELAXED_TO_STIMULATED = 0x1a3,
	ACT_READINESS_RELAXED_TO_STIMULATED_WALK = 0x1a4,
	ACT_READINESS_AGITATED_TO_STIMULATED = 0x1a5,
	ACT_READINESS_STIMULATED_TO_RELAXED = 0x1a6,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED = 0x1a7,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK = 0x1a8,
	ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED = 0x1a9,
	ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED = 0x1aa,
	ACT_IDLE_CARRY = 0x1ab,
	ACT_WALK_CARRY = 0x1ac,
	ACT_STARTDYING = 0x1ad,
	ACT_DYINGLOOP = 0x1ae,
	ACT_DYINGTODEAD = 0x1af,
	ACT_RIDE_MANNED_GUN = 0x1b0,
	ACT_VM_SPRINT_ENTER = 0x1b1,
	ACT_VM_SPRINT_IDLE = 0x1b2,
	ACT_VM_SPRINT_LEAVE = 0x1b3,
	ACT_FIRE_START = 0x1b4,
	ACT_FIRE_LOOP = 0x1b5,
	ACT_FIRE_END = 0x1b6,
	ACT_CROUCHING_GRENADEIDLE = 0x1b7,
	ACT_CROUCHING_GRENADEREADY = 0x1b8,
	ACT_CROUCHING_PRIMARYATTACK = 0x1b9,
	ACT_OVERLAY_GRENADEIDLE = 0x1ba,
	ACT_OVERLAY_GRENADEREADY = 0x1bb,
	ACT_OVERLAY_PRIMARYATTACK = 0x1bc,
	ACT_OVERLAY_SHIELD_UP = 0x1bd,
	ACT_OVERLAY_SHIELD_DOWN = 0x1be,
	ACT_OVERLAY_SHIELD_UP_IDLE = 0x1bf,
	ACT_OVERLAY_SHIELD_ATTACK = 0x1c0,
	ACT_OVERLAY_SHIELD_KNOCKBACK = 0x1c1,
	ACT_SHIELD_UP = 0x1c2,
	ACT_SHIELD_DOWN = 0x1c3,
	ACT_SHIELD_UP_IDLE = 0x1c4,
	ACT_SHIELD_ATTACK = 0x1c5,
	ACT_SHIELD_KNOCKBACK = 0x1c6,
	ACT_CROUCHING_SHIELD_UP = 0x1c7,
	ACT_CROUCHING_SHIELD_DOWN = 0x1c8,
	ACT_CROUCHING_SHIELD_UP_IDLE = 0x1c9,
	ACT_CROUCHING_SHIELD_ATTACK = 0x1ca,
	ACT_CROUCHING_SHIELD_KNOCKBACK = 0x1cb,
	ACT_TURNRIGHT45 = 0x1cc,
	ACT_TURNLEFT45 = 0x1cd,
	ACT_TURN = 0x1ce,
	ACT_OBJ_ASSEMBLING = 0x1cf,
	ACT_OBJ_DISMANTLING = 0x1d0,
	ACT_OBJ_STARTUP = 0x1d1,
	ACT_OBJ_RUNNING = 0x1d2,
	ACT_OBJ_IDLE = 0x1d3,
	ACT_OBJ_PLACING = 0x1d4,
	ACT_OBJ_DETERIORATING = 0x1d5,
	ACT_OBJ_UPGRADING = 0x1d6,
	ACT_DEPLOY = 0x1d7,
	ACT_DEPLOY_IDLE = 0x1d8,
	ACT_UNDEPLOY = 0x1d9,
	ACT_CROSSBOW_DRAW_UNLOADED = 0x1da,
	ACT_GAUSS_SPINUP = 0x1db,
	ACT_GAUSS_SPINCYCLE = 0x1dc,
	ACT_VM_PRIMARYATTACK_SILENCED = 0x1dd,
	ACT_VM_RELOAD_SILENCED = 0x1de,
	ACT_VM_DRYFIRE_SILENCED = 0x1df,
	ACT_VM_IDLE_SILENCED = 0x1e0,
	ACT_VM_DRAW_SILENCED = 0x1e1,
	ACT_VM_IDLE_EMPTY_LEFT = 0x1e2,
	ACT_VM_DRYFIRE_LEFT = 0x1e3,
	ACT_VM_IS_DRAW = 0x1e4,
	ACT_VM_IS_HOLSTER = 0x1e5,
	ACT_VM_IS_IDLE = 0x1e6,
	ACT_VM_IS_PRIMARYATTACK = 0x1e7,
	ACT_PLAYER_IDLE_FIRE = 0x1e8,
	ACT_PLAYER_CROUCH_FIRE = 0x1e9,
	ACT_PLAYER_CROUCH_WALK_FIRE = 0x1ea,
	ACT_PLAYER_WALK_FIRE = 0x1eb,
	ACT_PLAYER_RUN_FIRE = 0x1ec,
	ACT_IDLETORUN = 0x1ed,
	ACT_RUNTOIDLE = 0x1ee,
	ACT_VM_DRAW_DEPLOYED = 0x1ef,
	ACT_HL2MP_IDLE_MELEE = 0x1f0,
	ACT_HL2MP_RUN_MELEE = 0x1f1,
	ACT_HL2MP_IDLE_CROUCH_MELEE = 0x1f2,
	ACT_HL2MP_WALK_CROUCH_MELEE = 0x1f3,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE = 0x1f4,
	ACT_HL2MP_GESTURE_RELOAD_MELEE = 0x1f5,
	ACT_HL2MP_JUMP_MELEE = 0x1f6,
	ACT_MP_STAND_IDLE = 0x1f7,
	ACT_MP_CROUCH_IDLE = 0x1f8,
	ACT_MP_CROUCH_DEPLOYED_IDLE = 0x1f9,
	ACT_MP_CROUCH_DEPLOYED = 0x1fa,
	ACT_MP_DEPLOYED_IDLE = 0x1fb,
	ACT_MP_RUN = 0x1fc,
	ACT_MP_WALK = 0x1fd,
	ACT_MP_AIRWALK = 0x1fe,
	ACT_MP_CROUCHWALK = 0x1ff,
	ACT_MP_SPRINT = 0x200,
	ACT_MP_JUMP = 0x201,
	ACT_MP_JUMP_START = 0x202,
	ACT_MP_JUMP_FLOAT = 0x203,
	ACT_MP_JUMP_LAND = 0x204,
	ACT_MP_DOUBLEJUMP = 0x205,
	ACT_MP_SWIM = 0x206,
	ACT_MP_DEPLOYED = 0x207,
	ACT_MP_SWIM_DEPLOYED = 0x208,
	ACT_MP_VCD = 0x209,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE = 0x20a,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED = 0x20b,
	ACT_MP_ATTACK_STAND_SECONDARYFIRE = 0x20c,
	ACT_MP_ATTACK_STAND_GRENADE = 0x20d,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE = 0x20e,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED = 0x20f,
	ACT_MP_ATTACK_CROUCH_SECONDARYFIRE = 0x210,
	ACT_MP_ATTACK_CROUCH_GRENADE = 0x211,
	ACT_MP_ATTACK_SWIM_PRIMARYFIRE = 0x212,
	ACT_MP_ATTACK_SWIM_SECONDARYFIRE = 0x213,
	ACT_MP_ATTACK_SWIM_GRENADE = 0x214,
	ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE = 0x215,
	ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE = 0x216,
	ACT_MP_ATTACK_AIRWALK_GRENADE = 0x217,
	ACT_MP_RELOAD_STAND = 0x218,
	ACT_MP_RELOAD_STAND_LOOP = 0x219,
	ACT_MP_RELOAD_STAND_END = 0x21a,
	ACT_MP_RELOAD_CROUCH = 0x21b,
	ACT_MP_RELOAD_CROUCH_LOOP = 0x21c,
	ACT_MP_RELOAD_CROUCH_END = 0x21d,
	ACT_MP_RELOAD_SWIM = 0x21e,
	ACT_MP_RELOAD_SWIM_LOOP = 0x21f,
	ACT_MP_RELOAD_SWIM_END = 0x220,
	ACT_MP_RELOAD_AIRWALK = 0x221,
	ACT_MP_RELOAD_AIRWALK_LOOP = 0x222,
	ACT_MP_RELOAD_AIRWALK_END = 0x223,
	ACT_MP_ATTACK_STAND_PREFIRE = 0x224,
	ACT_MP_ATTACK_STAND_POSTFIRE = 0x225,
	ACT_MP_ATTACK_STAND_STARTFIRE = 0x226,
	ACT_MP_ATTACK_CROUCH_PREFIRE = 0x227,
	ACT_MP_ATTACK_CROUCH_POSTFIRE = 0x228,
	ACT_MP_ATTACK_SWIM_PREFIRE = 0x229,
	ACT_MP_ATTACK_SWIM_POSTFIRE = 0x22a,
	ACT_MP_STAND_PRIMARY = 0x22b,
	ACT_MP_CROUCH_PRIMARY = 0x22c,
	ACT_MP_RUN_PRIMARY = 0x22d,
	ACT_MP_WALK_PRIMARY = 0x22e,
	ACT_MP_AIRWALK_PRIMARY = 0x22f,
	ACT_MP_CROUCHWALK_PRIMARY = 0x230,
	ACT_MP_JUMP_PRIMARY = 0x231,
	ACT_MP_JUMP_START_PRIMARY = 0x232,
	ACT_MP_JUMP_FLOAT_PRIMARY = 0x233,
	ACT_MP_JUMP_LAND_PRIMARY = 0x234,
	ACT_MP_SWIM_PRIMARY = 0x235,
	ACT_MP_DEPLOYED_PRIMARY = 0x236,
	ACT_MP_SWIM_DEPLOYED_PRIMARY = 0x237,
	ACT_MP_ATTACK_STAND_PRIMARY = 0x238,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED = 0x239,
	ACT_MP_ATTACK_CROUCH_PRIMARY = 0x23a,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED = 0x23b,
	ACT_MP_ATTACK_SWIM_PRIMARY = 0x23c,
	ACT_MP_ATTACK_AIRWALK_PRIMARY = 0x23d,
	ACT_MP_RELOAD_STAND_PRIMARY = 0x23e,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP = 0x23f,
	ACT_MP_RELOAD_STAND_PRIMARY_END = 0x240,
	ACT_MP_RELOAD_CROUCH_PRIMARY = 0x241,
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP = 0x242,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END = 0x243,
	ACT_MP_RELOAD_SWIM_PRIMARY = 0x244,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP = 0x245,
	ACT_MP_RELOAD_SWIM_PRIMARY_END = 0x246,
	ACT_MP_RELOAD_AIRWALK_PRIMARY = 0x247,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP = 0x248,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END = 0x249,
	ACT_MP_ATTACK_STAND_GRENADE_PRIMARY = 0x24a,
	ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY = 0x24b,
	ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY = 0x24c,
	ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY = 0x24d,
	ACT_MP_STAND_SECONDARY = 0x24e,
	ACT_MP_CROUCH_SECONDARY = 0x24f,
	ACT_MP_RUN_SECONDARY = 0x250,
	ACT_MP_WALK_SECONDARY = 0x251,
	ACT_MP_AIRWALK_SECONDARY = 0x252,
	ACT_MP_CROUCHWALK_SECONDARY = 0x253,
	ACT_MP_JUMP_SECONDARY = 0x254,
	ACT_MP_JUMP_START_SECONDARY = 0x255,
	ACT_MP_JUMP_FLOAT_SECONDARY = 0x256,
	ACT_MP_JUMP_LAND_SECONDARY = 0x257,
	ACT_MP_SWIM_SECONDARY = 0x258,
	ACT_MP_ATTACK_STAND_SECONDARY = 0x259,
	ACT_MP_ATTACK_CROUCH_SECONDARY = 0x25a,
	ACT_MP_ATTACK_SWIM_SECONDARY = 0x25b,
	ACT_MP_ATTACK_AIRWALK_SECONDARY = 0x25c,
	ACT_MP_RELOAD_STAND_SECONDARY = 0x25d,
	ACT_MP_RELOAD_STAND_SECONDARY_LOOP = 0x25e,
	ACT_MP_RELOAD_STAND_SECONDARY_END = 0x25f,
	ACT_MP_RELOAD_CROUCH_SECONDARY = 0x260,
	ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP = 0x261,
	ACT_MP_RELOAD_CROUCH_SECONDARY_END = 0x262,
	ACT_MP_RELOAD_SWIM_SECONDARY = 0x263,
	ACT_MP_RELOAD_SWIM_SECONDARY_LOOP = 0x264,
	ACT_MP_RELOAD_SWIM_SECONDARY_END = 0x265,
	ACT_MP_RELOAD_AIRWALK_SECONDARY = 0x266,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP = 0x267,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_END = 0x268,
	ACT_MP_ATTACK_STAND_GRENADE_SECONDARY = 0x269,
	ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY = 0x26a,
	ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY = 0x26b,
	ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY = 0x26c,
	ACT_MP_STAND_MELEE = 0x26d,
	ACT_MP_CROUCH_MELEE = 0x26e,
	ACT_MP_RUN_MELEE = 0x26f,
	ACT_MP_WALK_MELEE = 0x270,
	ACT_MP_AIRWALK_MELEE = 0x271,
	ACT_MP_CROUCHWALK_MELEE = 0x272,
	ACT_MP_JUMP_MELEE = 0x273,
	ACT_MP_JUMP_START_MELEE = 0x274,
	ACT_MP_JUMP_FLOAT_MELEE = 0x275,
	ACT_MP_JUMP_LAND_MELEE = 0x276,
	ACT_MP_SWIM_MELEE = 0x277,
	ACT_MP_ATTACK_STAND_MELEE = 0x278,
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY = 0x279,
	ACT_MP_ATTACK_CROUCH_MELEE = 0x27a,
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY = 0x27b,
	ACT_MP_ATTACK_SWIM_MELEE = 0x27c,
	ACT_MP_ATTACK_AIRWALK_MELEE = 0x27d,
	ACT_MP_ATTACK_STAND_GRENADE_MELEE = 0x27e,
	ACT_MP_ATTACK_CROUCH_GRENADE_MELEE = 0x27f,
	ACT_MP_ATTACK_SWIM_GRENADE_MELEE = 0x280,
	ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE = 0x281,
	ACT_MP_STAND_ITEM1 = 0x282,
	ACT_MP_CROUCH_ITEM1 = 0x283,
	ACT_MP_RUN_ITEM1 = 0x284,
	ACT_MP_WALK_ITEM1 = 0x285,
	ACT_MP_AIRWALK_ITEM1 = 0x286,
	ACT_MP_CROUCHWALK_ITEM1 = 0x287,
	ACT_MP_JUMP_ITEM1 = 0x288,
	ACT_MP_JUMP_START_ITEM1 = 0x289,
	ACT_MP_JUMP_FLOAT_ITEM1 = 0x28a,
	ACT_MP_JUMP_LAND_ITEM1 = 0x28b,
	ACT_MP_SWIM_ITEM1 = 0x28c,
	ACT_MP_ATTACK_STAND_ITEM1 = 0x28d,
	ACT_MP_ATTACK_STAND_ITEM1_SECONDARY = 0x28e,
	ACT_MP_ATTACK_CROUCH_ITEM1 = 0x28f,
	ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY = 0x290,
	ACT_MP_ATTACK_SWIM_ITEM1 = 0x291,
	ACT_MP_ATTACK_AIRWALK_ITEM1 = 0x292,
	ACT_MP_STAND_ITEM2 = 0x293,
	ACT_MP_CROUCH_ITEM2 = 0x294,
	ACT_MP_RUN_ITEM2 = 0x295,
	ACT_MP_WALK_ITEM2 = 0x296,
	ACT_MP_AIRWALK_ITEM2 = 0x297,
	ACT_MP_CROUCHWALK_ITEM2 = 0x298,
	ACT_MP_JUMP_ITEM2 = 0x299,
	ACT_MP_JUMP_START_ITEM2 = 0x29a,
	ACT_MP_JUMP_FLOAT_ITEM2 = 0x29b,
	ACT_MP_JUMP_LAND_ITEM2 = 0x29c,
	ACT_MP_SWIM_ITEM2 = 0x29d,
	ACT_MP_ATTACK_STAND_ITEM2 = 0x29e,
	ACT_MP_ATTACK_STAND_ITEM2_SECONDARY = 0x29f,
	ACT_MP_ATTACK_CROUCH_ITEM2 = 0x2a0,
	ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY = 0x2a1,
	ACT_MP_ATTACK_SWIM_ITEM2 = 0x2a2,
	ACT_MP_ATTACK_AIRWALK_ITEM2 = 0x2a3,
	ACT_MP_GESTURE_FLINCH = 0x2a4,
	ACT_MP_GESTURE_FLINCH_PRIMARY = 0x2a5,
	ACT_MP_GESTURE_FLINCH_SECONDARY = 0x2a6,
	ACT_MP_GESTURE_FLINCH_MELEE = 0x2a7,
	ACT_MP_GESTURE_FLINCH_ITEM1 = 0x2a8,
	ACT_MP_GESTURE_FLINCH_ITEM2 = 0x2a9,
	ACT_MP_GESTURE_FLINCH_HEAD = 0x2aa,
	ACT_MP_GESTURE_FLINCH_CHEST = 0x2ab,
	ACT_MP_GESTURE_FLINCH_STOMACH = 0x2ac,
	ACT_MP_GESTURE_FLINCH_LEFTARM = 0x2ad,
	ACT_MP_GESTURE_FLINCH_RIGHTARM = 0x2ae,
	ACT_MP_GESTURE_FLINCH_LEFTLEG = 0x2af,
	ACT_MP_GESTURE_FLINCH_RIGHTLEG = 0x2b0,
	ACT_MP_GRENADE1_DRAW = 0x2b1,
	ACT_MP_GRENADE1_IDLE = 0x2b2,
	ACT_MP_GRENADE1_ATTACK = 0x2b3,
	ACT_MP_GRENADE2_DRAW = 0x2b4,
	ACT_MP_GRENADE2_IDLE = 0x2b5,
	ACT_MP_GRENADE2_ATTACK = 0x2b6,
	ACT_MP_PRIMARY_GRENADE1_DRAW = 0x2b7,
	ACT_MP_PRIMARY_GRENADE1_IDLE = 0x2b8,
	ACT_MP_PRIMARY_GRENADE1_ATTACK = 0x2b9,
	ACT_MP_PRIMARY_GRENADE2_DRAW = 0x2ba,
	ACT_MP_PRIMARY_GRENADE2_IDLE = 0x2bb,
	ACT_MP_PRIMARY_GRENADE2_ATTACK = 0x2bc,
	ACT_MP_SECONDARY_GRENADE1_DRAW = 0x2bd,
	ACT_MP_SECONDARY_GRENADE1_IDLE = 0x2be,
	ACT_MP_SECONDARY_GRENADE1_ATTACK = 0x2bf,
	ACT_MP_SECONDARY_GRENADE2_DRAW = 0x2c0,
	ACT_MP_SECONDARY_GRENADE2_IDLE = 0x2c1,
	ACT_MP_SECONDARY_GRENADE2_ATTACK = 0x2c2,
	ACT_MP_MELEE_GRENADE1_DRAW = 0x2c3,
	ACT_MP_MELEE_GRENADE1_IDLE = 0x2c4,
	ACT_MP_MELEE_GRENADE1_ATTACK = 0x2c5,
	ACT_MP_MELEE_GRENADE2_DRAW = 0x2c6,
	ACT_MP_MELEE_GRENADE2_IDLE = 0x2c7,
	ACT_MP_MELEE_GRENADE2_ATTACK = 0x2c8,
	ACT_MP_ITEM1_GRENADE1_DRAW = 0x2c9,
	ACT_MP_ITEM1_GRENADE1_IDLE = 0x2ca,
	ACT_MP_ITEM1_GRENADE1_ATTACK = 0x2cb,
	ACT_MP_ITEM1_GRENADE2_DRAW = 0x2cc,
	ACT_MP_ITEM1_GRENADE2_IDLE = 0x2cd,
	ACT_MP_ITEM1_GRENADE2_ATTACK = 0x2ce,
	ACT_MP_ITEM2_GRENADE1_DRAW = 0x2cf,
	ACT_MP_ITEM2_GRENADE1_IDLE = 0x2d0,
	ACT_MP_ITEM2_GRENADE1_ATTACK = 0x2d1,
	ACT_MP_ITEM2_GRENADE2_DRAW = 0x2d2,
	ACT_MP_ITEM2_GRENADE2_IDLE = 0x2d3,
	ACT_MP_ITEM2_GRENADE2_ATTACK = 0x2d4,
	ACT_MP_STAND_BUILDING = 0x2d5,
	ACT_MP_CROUCH_BUILDING = 0x2d6,
	ACT_MP_RUN_BUILDING = 0x2d7,
	ACT_MP_WALK_BUILDING = 0x2d8,
	ACT_MP_AIRWALK_BUILDING = 0x2d9,
	ACT_MP_CROUCHWALK_BUILDING = 0x2da,
	ACT_MP_JUMP_BUILDING = 0x2db,
	ACT_MP_JUMP_START_BUILDING = 0x2dc,
	ACT_MP_JUMP_FLOAT_BUILDING = 0x2dd,
	ACT_MP_JUMP_LAND_BUILDING = 0x2de,
	ACT_MP_SWIM_BUILDING = 0x2df,
	ACT_MP_ATTACK_STAND_BUILDING = 0x2e0,
	ACT_MP_ATTACK_CROUCH_BUILDING = 0x2e1,
	ACT_MP_ATTACK_SWIM_BUILDING = 0x2e2,
	ACT_MP_ATTACK_AIRWALK_BUILDING = 0x2e3,
	ACT_MP_ATTACK_STAND_GRENADE_BUILDING = 0x2e4,
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING = 0x2e5,
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING = 0x2e6,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING = 0x2e7,
	ACT_MP_STAND_PDA = 0x2e8,
	ACT_MP_CROUCH_PDA = 0x2e9,
	ACT_MP_RUN_PDA = 0x2ea,
	ACT_MP_WALK_PDA = 0x2eb,
	ACT_MP_AIRWALK_PDA = 0x2ec,
	ACT_MP_CROUCHWALK_PDA = 0x2ed,
	ACT_MP_JUMP_PDA = 0x2ee,
	ACT_MP_JUMP_START_PDA = 0x2ef,
	ACT_MP_JUMP_FLOAT_PDA = 0x2f0,
	ACT_MP_JUMP_LAND_PDA = 0x2f1,
	ACT_MP_SWIM_PDA = 0x2f2,
	ACT_MP_ATTACK_STAND_PDA = 0x2f3,
	ACT_MP_ATTACK_SWIM_PDA = 0x2f4,
	ACT_MP_GESTURE_VC_HANDMOUTH = 0x2f5,
	ACT_MP_GESTURE_VC_FINGERPOINT = 0x2f6,
	ACT_MP_GESTURE_VC_FISTPUMP = 0x2f7,
	ACT_MP_GESTURE_VC_THUMBSUP = 0x2f8,
	ACT_MP_GESTURE_VC_NODYES = 0x2f9,
	ACT_MP_GESTURE_VC_NODNO = 0x2fa,
	ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY = 0x2fb,
	ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY = 0x2fc,
	ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY = 0x2fd,
	ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY = 0x2fe,
	ACT_MP_GESTURE_VC_NODYES_PRIMARY = 0x2ff,
	ACT_MP_GESTURE_VC_NODNO_PRIMARY = 0x300,
	ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY = 0x301,
	ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY = 0x302,
	ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY = 0x303,
	ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY = 0x304,
	ACT_MP_GESTURE_VC_NODYES_SECONDARY = 0x305,
	ACT_MP_GESTURE_VC_NODNO_SECONDARY = 0x306,
	ACT_MP_GESTURE_VC_HANDMOUTH_MELEE = 0x307,
	ACT_MP_GESTURE_VC_FINGERPOINT_MELEE = 0x308,
	ACT_MP_GESTURE_VC_FISTPUMP_MELEE = 0x309,
	ACT_MP_GESTURE_VC_THUMBSUP_MELEE = 0x30a,
	ACT_MP_GESTURE_VC_NODYES_MELEE = 0x30b,
	ACT_MP_GESTURE_VC_NODNO_MELEE = 0x30c,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1 = 0x30d,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1 = 0x30e,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM1 = 0x30f,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM1 = 0x310,
	ACT_MP_GESTURE_VC_NODYES_ITEM1 = 0x311,
	ACT_MP_GESTURE_VC_NODNO_ITEM1 = 0x312,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2 = 0x313,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2 = 0x314,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM2 = 0x315,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM2 = 0x316,
	ACT_MP_GESTURE_VC_NODYES_ITEM2 = 0x317,
	ACT_MP_GESTURE_VC_NODNO_ITEM2 = 0x318,
	ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING = 0x319,
	ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING = 0x31a,
	ACT_MP_GESTURE_VC_FISTPUMP_BUILDING = 0x31b,
	ACT_MP_GESTURE_VC_THUMBSUP_BUILDING = 0x31c,
	ACT_MP_GESTURE_VC_NODYES_BUILDING = 0x31d,
	ACT_MP_GESTURE_VC_NODNO_BUILDING = 0x31e,
	ACT_MP_GESTURE_VC_HANDMOUTH_PDA = 0x31f,
	ACT_MP_GESTURE_VC_FINGERPOINT_PDA = 0x320,
	ACT_MP_GESTURE_VC_FISTPUMP_PDA = 0x321,
	ACT_MP_GESTURE_VC_THUMBSUP_PDA = 0x322,
	ACT_MP_GESTURE_VC_NODYES_PDA = 0x323,
	ACT_MP_GESTURE_VC_NODNO_PDA = 0x324,
	ACT_VM_UNUSABLE = 0x325,
	ACT_VM_UNUSABLE_TO_USABLE = 0x326,
	ACT_VM_USABLE_TO_UNUSABLE = 0x327,
	ACT_PRIMARY_VM_DRAW = 0x328,
	ACT_PRIMARY_VM_HOLSTER = 0x329,
	ACT_PRIMARY_VM_IDLE = 0x32a,
	ACT_PRIMARY_VM_PULLBACK = 0x32b,
	ACT_PRIMARY_VM_PRIMARYATTACK = 0x32c,
	ACT_PRIMARY_VM_SECONDARYATTACK = 0x32d,
	ACT_PRIMARY_VM_RELOAD = 0x32e,
	ACT_PRIMARY_VM_DRYFIRE = 0x32f,
	ACT_PRIMARY_VM_IDLE_TO_LOWERED = 0x330,
	ACT_PRIMARY_VM_IDLE_LOWERED = 0x331,
	ACT_PRIMARY_VM_LOWERED_TO_IDLE = 0x332,
	ACT_SECONDARY_VM_DRAW = 0x333,
	ACT_SECONDARY_VM_HOLSTER = 0x334,
	ACT_SECONDARY_VM_IDLE = 0x335,
	ACT_SECONDARY_VM_PULLBACK = 0x336,
	ACT_SECONDARY_VM_PRIMARYATTACK = 0x337,
	ACT_SECONDARY_VM_SECONDARYATTACK = 0x338,
	ACT_SECONDARY_VM_RELOAD = 0x339,
	ACT_SECONDARY_VM_DRYFIRE = 0x33a,
	ACT_SECONDARY_VM_IDLE_TO_LOWERED = 0x33b,
	ACT_SECONDARY_VM_IDLE_LOWERED = 0x33c,
	ACT_SECONDARY_VM_LOWERED_TO_IDLE = 0x33d,
	ACT_MELEE_VM_DRAW = 0x33e,
	ACT_MELEE_VM_HOLSTER = 0x33f,
	ACT_MELEE_VM_IDLE = 0x340,
	ACT_MELEE_VM_PULLBACK = 0x341,
	ACT_MELEE_VM_PRIMARYATTACK = 0x342,
	ACT_MELEE_VM_SECONDARYATTACK = 0x343,
	ACT_MELEE_VM_RELOAD = 0x344,
	ACT_MELEE_VM_DRYFIRE = 0x345,
	ACT_MELEE_VM_IDLE_TO_LOWERED = 0x346,
	ACT_MELEE_VM_IDLE_LOWERED = 0x347,
	ACT_MELEE_VM_LOWERED_TO_IDLE = 0x348,
	ACT_PDA_VM_DRAW = 0x349,
	ACT_PDA_VM_HOLSTER = 0x34a,
	ACT_PDA_VM_IDLE = 0x34b,
	ACT_PDA_VM_PULLBACK = 0x34c,
	ACT_PDA_VM_PRIMARYATTACK = 0x34d,
	ACT_PDA_VM_SECONDARYATTACK = 0x34e,
	ACT_PDA_VM_RELOAD = 0x34f,
	ACT_PDA_VM_DRYFIRE = 0x350,
	ACT_PDA_VM_IDLE_TO_LOWERED = 0x351,
	ACT_PDA_VM_IDLE_LOWERED = 0x352,
	ACT_PDA_VM_LOWERED_TO_IDLE = 0x353,
	ACT_ITEM1_VM_DRAW = 0x354,
	ACT_ITEM1_VM_HOLSTER = 0x355,
	ACT_ITEM1_VM_IDLE = 0x356,
	ACT_ITEM1_VM_PULLBACK = 0x357,
	ACT_ITEM1_VM_PRIMARYATTACK = 0x358,
	ACT_ITEM1_VM_SECONDARYATTACK = 0x359,
	ACT_ITEM1_VM_RELOAD = 0x35a,
	ACT_ITEM1_VM_DRYFIRE = 0x35b,
	ACT_ITEM1_VM_IDLE_TO_LOWERED = 0x35c,
	ACT_ITEM1_VM_IDLE_LOWERED = 0x35d,
	ACT_ITEM1_VM_LOWERED_TO_IDLE = 0x35e,
	ACT_ITEM2_VM_DRAW = 0x35f,
	ACT_ITEM2_VM_HOLSTER = 0x360,
	ACT_ITEM2_VM_IDLE = 0x361,
	ACT_ITEM2_VM_PULLBACK = 0x362,
	ACT_ITEM2_VM_PRIMARYATTACK = 0x363,
	ACT_ITEM2_VM_SECONDARYATTACK = 0x364,
	ACT_ITEM2_VM_RELOAD = 0x365,
	ACT_ITEM2_VM_DRYFIRE = 0x366,
	ACT_ITEM2_VM_IDLE_TO_LOWERED = 0x367,
	ACT_ITEM2_VM_IDLE_LOWERED = 0x368,
	ACT_ITEM2_VM_LOWERED_TO_IDLE = 0x369,
	ACT_RELOAD_SUCCEED = 0x36a,
	ACT_RELOAD_FAIL = 0x36b,
	ACT_WALK_AIM_AUTOGUN = 0x36c,
	ACT_RUN_AIM_AUTOGUN = 0x36d,
	ACT_IDLE_AUTOGUN = 0x36e,
	ACT_IDLE_AIM_AUTOGUN = 0x36f,
	ACT_RELOAD_AUTOGUN = 0x370,
	ACT_CROUCH_IDLE_AUTOGUN = 0x371,
	ACT_RANGE_ATTACK_AUTOGUN = 0x372,
	ACT_JUMP_AUTOGUN = 0x373,
	ACT_IDLE_AIM_PISTOL = 0x374,
	ACT_WALK_AIM_DUAL = 0x375,
	ACT_RUN_AIM_DUAL = 0x376,
	ACT_IDLE_DUAL = 0x377,
	ACT_IDLE_AIM_DUAL = 0x378,
	ACT_RELOAD_DUAL = 0x379,
	ACT_CROUCH_IDLE_DUAL = 0x37a,
	ACT_RANGE_ATTACK_DUAL = 0x37b,
	ACT_JUMP_DUAL = 0x37c,
	ACT_IDLE_AIM_SHOTGUN = 0x37d,
	ACT_CROUCH_IDLE_SHOTGUN = 0x37e,
	ACT_IDLE_AIM_RIFLE = 0x37f,
	ACT_CROUCH_IDLE_RIFLE = 0x380,
	ACT_RANGE_ATTACK_RIFLE = 0x381,
	ACT_SLEEP = 0x382,
	ACT_WAKE = 0x383,
	ACT_FLICK_LEFT = 0x384,
	ACT_FLICK_LEFT_MIDDLE = 0x385,
	ACT_FLICK_RIGHT_MIDDLE = 0x386,
	ACT_FLICK_RIGHT = 0x387,
	ACT_SPINAROUND = 0x388,
	ACT_PREP_TO_FIRE = 0x389,
	ACT_FIRE = 0x38a,
	ACT_FIRE_RECOVER = 0x38b,
	ACT_SPRAY = 0x38c,
	ACT_PREP_EXPLODE = 0x38d,
	ACT_EXPLODE = 0x38e,
	ACT_SCRIPT_CUSTOM_0 = 0x38f,
	ACT_SCRIPT_CUSTOM_1 = 0x390,
	ACT_SCRIPT_CUSTOM_2 = 0x391,
	ACT_SCRIPT_CUSTOM_3 = 0x392,
	ACT_SCRIPT_CUSTOM_4 = 0x393,
	ACT_SCRIPT_CUSTOM_5 = 0x394,
	ACT_SCRIPT_CUSTOM_6 = 0x395,
	ACT_SCRIPT_CUSTOM_7 = 0x396,
	ACT_SCRIPT_CUSTOM_8 = 0x397,
	ACT_SCRIPT_CUSTOM_9 = 0x398,
	ACT_SCRIPT_CUSTOM_10 = 0x399,
	ACT_SCRIPT_CUSTOM_11 = 0x39a,
	ACT_SCRIPT_CUSTOM_12 = 0x39b,
	ACT_SCRIPT_CUSTOM_13 = 0x39c,
	ACT_SCRIPT_CUSTOM_14 = 0x39d,
	ACT_SCRIPT_CUSTOM_15 = 0x39e,
	ACT_SCRIPT_CUSTOM_16 = 0x39f,
	ACT_SCRIPT_CUSTOM_17 = 0x3a0,
	ACT_SCRIPT_CUSTOM_18 = 0x3a1,
	ACT_SCRIPT_CUSTOM_19 = 0x3a2,
	ACT_SCRIPT_CUSTOM_20 = 0x3a3,
	ACT_SCRIPT_CUSTOM_21 = 0x3a4,
	ACT_SCRIPT_CUSTOM_22 = 0x3a5,
	ACT_SCRIPT_CUSTOM_23 = 0x3a6,
	ACT_SCRIPT_CUSTOM_24 = 0x3a7,
	ACT_SCRIPT_CUSTOM_25 = 0x3a8,
	ACT_SCRIPT_CUSTOM_26 = 0x3a9,
	ACT_SCRIPT_CUSTOM_27 = 0x3aa,
	ACT_SCRIPT_CUSTOM_28 = 0x3ab,
	ACT_SCRIPT_CUSTOM_29 = 0x3ac,
	ACT_SCRIPT_CUSTOM_30 = 0x3ad,
	ACT_SCRIPT_CUSTOM_31 = 0x3ae,
	ACT_VR_PISTOL_LAST_SHOT = 0x3af,
	ACT_VR_PISTOL_SLIDE_RELEASE = 0x3b0,
	ACT_VR_PISTOL_CLIP_OUT_CHAMBERED = 0x3b1,
	ACT_VR_PISTOL_CLIP_OUT_SLIDE_BACK = 0x3b2,
	ACT_VR_PISTOL_CLIP_IN_CHAMBERED = 0x3b3,
	ACT_VR_PISTOL_CLIP_IN_SLIDE_BACK = 0x3b4,
	ACT_VR_PISTOL_IDLE_SLIDE_BACK = 0x3b5,
	ACT_VR_PISTOL_IDLE_SLIDE_BACK_CLIP_READY = 0x3b6,
	ACT_RAGDOLL_RECOVERY_FRONT = 0x3b7,
	ACT_RAGDOLL_RECOVERY_BACK = 0x3b8,
	ACT_RAGDOLL_RECOVERY_LEFT = 0x3b9,
	ACT_RAGDOLL_RECOVERY_RIGHT = 0x3ba,
	ACT_GRABBITYGLOVES_GRAB = 0x3bb,
	ACT_GRABBITYGLOVES_RELEASE = 0x3bc,
	ACT_GRABBITYGLOVES_GRAB_IDLE = 0x3bd,
	ACT_GRABBITYGLOVES_ACTIVE = 0x3be,
	ACT_GRABBITYGLOVES_ACTIVE_IDLE = 0x3bf,
	ACT_GRABBITYGLOVES_DEACTIVATE = 0x3c0,
	ACT_GRABBITYGLOVES_PULL = 0x3c1,
	ACT_HEADCRAB_SMOKE_BOMB = 0x3c2,
	ACT_HEADCRAB_SPIT = 0x3c3,
	ACT_ZOMBIE_TRIP = 0x3c4,
	ACT_ZOMBIE_LUNGE = 0x3c5,
	ACT_NEUTRAL_REF_POSE = 0x3c6,
	ACT_ANTLION_SCUTTLE_FORWARD = 0x3c7,
	ACT_ANTLION_SCUTTLE_BACK = 0x3c8,
	ACT_ANTLION_SCUTTLE_LEFT = 0x3c9,
	ACT_ANTLION_SCUTTLE_RIGHT = 0x3ca,
	ACT_VR_PISTOL_EMPTY_CLIP_IN_SLIDE_BACK = 0x3cb,
	ACT_VR_SHOTGUN_IDLE = 0x3cc,
	ACT_VR_SHOTGUN_OPEN_CHAMBER = 0x3cd,
	ACT_VR_SHOTGUN_RELOAD_1 = 0x3ce,
	ACT_VR_SHOTGUN_RELOAD_2 = 0x3cf,
	ACT_VR_SHOTGUN_RELOAD_3 = 0x3d0,
	ACT_VR_SHOTGUN_CLOSE_CHAMBER = 0x3d1,
	ACT_VR_SHOTGUN_TRIGGER_SQUEEZE = 0x3d2,
	ACT_VR_SHOTGUN_SHOOT = 0x3d3,
	ACT_VR_SHOTGUN_SLIDE_BACK = 0x3d4,
	ACT_VR_SHOTGUN_SLIDE_FORWARD = 0x3d5,
	ACT_VR_PISTOL_LONG_CLIP_IN_CHAMBERED = 0x3d6,
	ACT_VR_PISTOL_LONG_CLIP_IN_SLIDE_BACK = 0x3d7,
	ACT_VR_PISTOL_BURST_TOGGLE = 0x3d8,
	ACT_VR_PISTOL_LOW_KICK = 0x3d9,
	ACT_VR_PISTOL_BURST_ATTACK = 0x3da,
	ACT_VR_SHOTGUN_GRENADE_TWIST = 0x3db,
	ACT_DIE_STAND = 0x3dc,
	ACT_DIE_STAND_HEADSHOT = 0x3dd,
	ACT_DIE_CROUCH = 0x3de,
	ACT_DIE_CROUCH_HEADSHOT = 0x3df,
	ACT_CSGO_NULL = 0x3e0,
	ACT_CSGO_DEFUSE = 0x3e1,
	ACT_CSGO_DEFUSE_WITH_KIT = 0x3e2,
	ACT_CSGO_FLASHBANG_REACTION = 0x3e3,
	ACT_CSGO_FIRE_PRIMARY = 0x3e4,
	ACT_CSGO_FIRE_PRIMARY_OPT_1 = 0x3e5,
	ACT_CSGO_FIRE_PRIMARY_OPT_2 = 0x3e6,
	ACT_CSGO_FIRE_SECONDARY = 0x3e7,
	ACT_CSGO_FIRE_SECONDARY_OPT_1 = 0x3e8,
	ACT_CSGO_FIRE_SECONDARY_OPT_2 = 0x3e9,
	ACT_CSGO_RELOAD = 0x3ea,
	ACT_CSGO_RELOAD_START = 0x3eb,
	ACT_CSGO_RELOAD_LOOP = 0x3ec,
	ACT_CSGO_RELOAD_END = 0x3ed,
	ACT_CSGO_OPERATE = 0x3ee,
	ACT_CSGO_DEPLOY = 0x3ef,
	ACT_CSGO_CATCH = 0x3f0,
	ACT_CSGO_SILENCER_DETACH = 0x3f1,
	ACT_CSGO_SILENCER_ATTACH = 0x3f2,
	ACT_CSGO_TWITCH = 0x3f3,
	ACT_CSGO_TWITCH_BUYZONE = 0x3f4,
	ACT_CSGO_PLANT_BOMB = 0x3f5,
	ACT_CSGO_IDLE_TURN_BALANCEADJUST = 0x3f6,
	ACT_CSGO_IDLE_ADJUST_STOPPEDMOVING = 0x3f7,
	ACT_CSGO_ALIVE_LOOP = 0x3f8,
	ACT_CSGO_FLINCH = 0x3f9,
	ACT_CSGO_FLINCH_HEAD = 0x3fa,
	ACT_CSGO_FLINCH_MOLOTOV = 0x3fb,
	ACT_CSGO_JUMP = 0x3fc,
	ACT_CSGO_FALL = 0x3fd,
	ACT_CSGO_CLIMB_LADDER = 0x3fe,
	ACT_CSGO_LAND_LIGHT = 0x3ff,
	ACT_CSGO_LAND_HEAVY = 0x400,
	ACT_CSGO_EXIT_LADDER_TOP = 0x401,
	ACT_CSGO_EXIT_LADDER_BOTTOM = 0x402,
	ACT_CSGO_PARACHUTE = 0x403,
	ACT_CSGO_TAUNT = 0x404,
};

// Alignment: 4
// Size: 0x3
enum class AmmoFlags_t : uint32_t
{
	AMMO_FORCE_DROP_IF_CARRIED = 0x1,
	AMMO_RESERVE_STAYS_WITH_WEAPON = 0x2,
	AMMO_FLAG_MAX = 0x2,
};

// Alignment: 2
// Size: 0xc
enum class TakeDamageFlags_t : uint16_t
{
	DFLAG_NONE = 0x0,
	DFLAG_SUPPRESS_HEALTH_CHANGES = 0x1,
	DFLAG_SUPPRESS_PHYSICS_FORCE = 0x2,
	DFLAG_SUPPRESS_EFFECTS = 0x4,
	DFLAG_PREVENT_DEATH = 0x8,
	DFLAG_FORCE_DEATH = 0x10,
	DFLAG_ALWAYS_GIB = 0x20,
	DFLAG_NEVER_GIB = 0x40,
	DFLAG_REMOVE_NO_RAGDOLL = 0x80,
	DFLAG_SUPPRESS_DAMAGE_MODIFICATION = 0x100,
	DFLAG_ALWAYS_FIRE_DAMAGE_EVENTS = 0x200,
	DMG_LASTDFLAG = 0x200,
};

// Alignment: 4
// Size: 0x16
enum class DamageTypes_t : uint32_t
{
	DMG_GENERIC = 0x0,
	DMG_CRUSH = 0x1,
	DMG_BULLET = 0x2,
	DMG_SLASH = 0x4,
	DMG_BURN = 0x8,
	DMG_VEHICLE = 0x10,
	DMG_FALL = 0x20,
	DMG_BLAST = 0x40,
	DMG_CLUB = 0x80,
	DMG_SHOCK = 0x100,
	DMG_SONIC = 0x200,
	DMG_ENERGYBEAM = 0x400,
	DMG_DROWN = 0x4000,
	DMG_POISON = 0x8000,
	DMG_RADIATION = 0x10000,
	DMG_DROWNRECOVER = 0x20000,
	DMG_ACID = 0x40000,
	DMG_PHYSGUN = 0x100000,
	DMG_DISSOLVE = 0x200000,
	DMG_BLAST_SURFACE = 0x400000,
	DMG_BUCKSHOT = 0x1000000,
	DMG_LASTGENERICFLAG = 0x1000000,
};

// Alignment: 4
// Size: 0x11
enum class BaseExplosionTypes_t : uint32_t
{
	EXPLOSION_TYPE_DEFAULT = 0x0,
	EXPLOSION_TYPE_GRENADE = 0x1,
	EXPLOSION_TYPE_MOLOTOV = 0x2,
	EXPLOSION_TYPE_FIREWORKS = 0x3,
	EXPLOSION_TYPE_GASCAN = 0x4,
	EXPLOSION_TYPE_GASCYLINDER = 0x5,
	EXPLOSION_TYPE_EXPLOSIVEBARREL = 0x6,
	EXPLOSION_TYPE_ELECTRICAL = 0x7,
	EXPLOSION_TYPE_EMP = 0x8,
	EXPLOSION_TYPE_SHRAPNEL = 0x9,
	EXPLOSION_TYPE_SMOKEGRENADE = 0xa,
	EXPLOSION_TYPE_FLASHBANG = 0xb,
	EXPLOSION_TYPE_TRIPMINE = 0xc,
	EXPLOSION_TYPE_ICE = 0xd,
	EXPLOSION_TYPE_NONE = 0xe,
	EXPLOSION_TYPE_CUSTOM = 0xf,
	EXPLOSION_TYPE_COUNT = 0x10,
};

// Alignment: 4
// Size: 0x6
enum class HierarchyType_t : uint32_t
{
	HIERARCHY_NONE = 0x0,
	HIERARCHY_BONE_MERGE = 0x1,
	HIERARCHY_ATTACHMENT = 0x2,
	HIERARCHY_ABSORIGIN = 0x3,
	HIERARCHY_BONE = 0x4,
	HIERARCHY_TYPE_COUNT = 0x5,
};

// Alignment: 4
// Size: 0x3
enum class CanPlaySequence_t : uint32_t
{
	CANNOT_PLAY = 0x0,
	CAN_PLAY_NOW = 0x1,
	CAN_PLAY_ENQUEUED = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class ScriptedOnDeath_t : uint32_t
{
	SS_ONDEATH_NOT_APPLICABLE = 0xffffffffffffffff,
	SS_ONDEATH_UNDEFINED = 0x0,
	SS_ONDEATH_RAGDOLL = 0x1,
	SS_ONDEATH_ANIMATED_DEATH = 0x2,
};

// Alignment: 4
// Size: 0x7
enum class IChoreoServices__ScriptState_t : uint32_t
{
	SCRIPT_PLAYING = 0x0,
	SCRIPT_WAIT = 0x1,
	SCRIPT_POST_IDLE = 0x2,
	SCRIPT_CLEANUP = 0x3,
	SCRIPT_WALK_TO_MARK = 0x4,
	SCRIPT_RUN_TO_MARK = 0x5,
	SCRIPT_CUSTOM_MOVE_TO_MARK = 0x6,
};

// Alignment: 4
// Size: 0x7
enum class IChoreoServices__ChoreoState_t : uint32_t
{
	STATE_PRE_SCRIPT = 0x0,
	STATE_WAIT_FOR_SCRIPT = 0x1,
	STATE_WALK_TO_MARK = 0x2,
	STATE_SYNCHRONIZE_SCRIPT = 0x3,
	STATE_PLAY_SCRIPT = 0x4,
	STATE_PLAY_SCRIPT_POST_IDLE = 0x5,
	STATE_PLAY_SCRIPT_POST_IDLE_DONE = 0x6,
};

// Alignment: 4
// Size: 0x6
enum class ShakeCommand_t : uint32_t
{
	SHAKE_START = 0x0,
	SHAKE_STOP = 0x1,
	SHAKE_AMPLITUDE = 0x2,
	SHAKE_FREQUENCY = 0x3,
	SHAKE_START_RUMBLEONLY = 0x4,
	SHAKE_START_NORUMBLE = 0x5,
};

// Alignment: 4
// Size: 0x5
enum class TimelineCompression_t : uint32_t
{
	TIMELINE_COMPRESSION_SUM = 0x0,
	TIMELINE_COMPRESSION_COUNT_PER_INTERVAL = 0x1,
	TIMELINE_COMPRESSION_AVERAGE = 0x2,
	TIMELINE_COMPRESSION_AVERAGE_BLEND = 0x3,
	TIMELINE_COMPRESSION_TOTAL = 0x4,
};

// Alignment: 8
// Size: 0x28
enum class DebugOverlayBits_t : uint64_t
{
	OVERLAY_TEXT_BIT = 0x1,
	OVERLAY_NAME_BIT = 0x2,
	OVERLAY_BBOX_BIT = 0x4,
	OVERLAY_PIVOT_BIT = 0x8,
	OVERLAY_MESSAGE_BIT = 0x10,
	OVERLAY_ABSBOX_BIT = 0x20,
	OVERLAY_RBOX_BIT = 0x40,
	OVERLAY_SHOW_BLOCKSLOS = 0x80,
	OVERLAY_ATTACHMENTS_BIT = 0x100,
	OVERLAY_INTERPOLATED_ATTACHMENTS_BIT = 0x200,
	OVERLAY_INTERPOLATED_PIVOT_BIT = 0x400,
	OVERLAY_SKELETON_BIT = 0x800,
	OVERLAY_INTERPOLATED_SKELETON_BIT = 0x1000,
	OVERLAY_TRIGGER_BOUNDS_BIT = 0x2000,
	OVERLAY_HITBOX_BIT = 0x4000,
	OVERLAY_INTERPOLATED_HITBOX_BIT = 0x8000,
	OVERLAY_AUTOAIM_BIT = 0x10000,
	OVERLAY_NPC_SELECTED_BIT = 0x20000,
	OVERLAY_JOINT_INFO_BIT = 0x40000,
	OVERLAY_NPC_ROUTE_BIT = 0x80000,
	OVERLAY_NPC_TRIANGULATE_BIT = 0x100000,
	OVERLAY_NPC_ZAP_BIT = 0x200000,
	OVERLAY_NPC_ENEMIES_BIT = 0x400000,
	OVERLAY_NPC_CONDITIONS_BIT = 0x800000,
	OVERLAY_NPC_COMBAT_BIT = 0x1000000,
	OVERLAY_NPC_TASK_BIT = 0x2000000,
	OVERLAY_NPC_BODYLOCATIONS = 0x4000000,
	OVERLAY_NPC_VIEWCONE_BIT = 0x8000000,
	OVERLAY_NPC_KILL_BIT = 0x10000000,
	OVERLAY_WC_CHANGE_ENTITY = 0x20000000,
	OVERLAY_BUDDHA_MODE = 0x40000000,
	OVERLAY_NPC_STEERING_REGULATIONS = 0x80000000,
	OVERLAY_NPC_TASK_TEXT_BIT = 0x100000000,
	OVERLAY_PROP_DEBUG = 0x200000000,
	OVERLAY_NPC_RELATION_BIT = 0x400000000,
	OVERLAY_VIEWOFFSET = 0x800000000,
	OVERLAY_VCOLLIDE_WIREFRAME_BIT = 0x1000000000,
	OVERLAY_NPC_NEAREST_NODE_BIT = 0x2000000000,
	OVERLAY_ACTORNAME_BIT = 0x4000000000,
	OVERLAY_NPC_CONDITIONS_TEXT_BIT = 0x8000000000,
};

// Alignment: 1
// Size: 0xe
enum class MoveType_t : uint8_t
{
	MOVETYPE_NONE = 0x0,
	MOVETYPE_OBSOLETE = 0x1,
	MOVETYPE_WALK = 0x2,
	MOVETYPE_STEP = 0x3,
	MOVETYPE_FLY = 0x4,
	MOVETYPE_FLYGRAVITY = 0x5,
	MOVETYPE_VPHYSICS = 0x6,
	MOVETYPE_PUSH = 0x7,
	MOVETYPE_NOCLIP = 0x8,
	MOVETYPE_LADDER = 0x9,
	MOVETYPE_OBSERVER = 0xa,
	MOVETYPE_CUSTOM = 0xb,
	MOVETYPE_LAST = 0xb,
	MOVETYPE_MAX_BITS = 0x4,
};

// Alignment: 1
// Size: 0x6
enum class MoveCollide_t : uint8_t
{
	MOVECOLLIDE_DEFAULT = 0x0,
	MOVECOLLIDE_FLY_BOUNCE = 0x1,
	MOVECOLLIDE_FLY_CUSTOM = 0x2,
	MOVECOLLIDE_FLY_SLIDE = 0x3,
	MOVECOLLIDE_COUNT = 0x4,
	MOVECOLLIDE_MAX_BITS = 0x3,
};

// Alignment: 1
// Size: 0x9
enum class SolidType_t : uint8_t
{
	SOLID_NONE = 0x0,
	SOLID_BSP = 0x1,
	SOLID_BBOX = 0x2,
	SOLID_OBB = 0x3,
	SOLID_SPHERE = 0x4,
	SOLID_POINT = 0x5,
	SOLID_VPHYSICS = 0x6,
	SOLID_CAPSULE = 0x7,
	SOLID_LAST = 0x8,
};

// Alignment: 4
// Size: 0x3
enum class BrushSolidities_e : uint32_t
{
	BRUSHSOLID_TOGGLE = 0x0,
	BRUSHSOLID_NEVER = 0x1,
	BRUSHSOLID_ALWAYS = 0x2,
};

// Alignment: 1
// Size: 0xd
enum class RenderMode_t : uint8_t
{
	kRenderNormal = 0x0,
	kRenderTransColor = 0x1,
	kRenderTransTexture = 0x2,
	kRenderGlow = 0x3,
	kRenderTransAlpha = 0x4,
	kRenderTransAdd = 0x5,
	kRenderEnvironmental = 0x6,
	kRenderTransAddFrameBlend = 0x7,
	kRenderTransAlphaAdd = 0x8,
	kRenderWorldGlow = 0x9,
	kRenderNone = 0xa,
	kRenderDevVisualizer = 0xb,
	kRenderModeCount = 0xc,
};

// Alignment: 1
// Size: 0x14
enum class RenderFx_t : uint8_t
{
	kRenderFxNone = 0x0,
	kRenderFxPulseSlow = 0x1,
	kRenderFxPulseFast = 0x2,
	kRenderFxPulseSlowWide = 0x3,
	kRenderFxPulseFastWide = 0x4,
	kRenderFxFadeSlow = 0x5,
	kRenderFxFadeFast = 0x6,
	kRenderFxSolidSlow = 0x7,
	kRenderFxSolidFast = 0x8,
	kRenderFxStrobeSlow = 0x9,
	kRenderFxStrobeFast = 0xa,
	kRenderFxStrobeFaster = 0xb,
	kRenderFxFlickerSlow = 0xc,
	kRenderFxFlickerFast = 0xd,
	kRenderFxNoDissipation = 0xe,
	kRenderFxFadeOut = 0xf,
	kRenderFxFadeIn = 0x10,
	kRenderFxPulseFastWider = 0x11,
	kRenderFxGlowShell = 0x12,
	kRenderFxMax = 0x13,
};

// Alignment: 4
// Size: 0x2
enum class CRR_Response__ResponseEnum_t : uint32_t
{
	MAX_RESPONSE_NAME = 0xc0,
	MAX_RULE_NAME = 0x80,
};

// Alignment: 4
// Size: 0x3
enum class LessonPanelLayoutFileTypes_t : uint32_t
{
	LAYOUT_HAND_DEFAULT = 0x0,
	LAYOUT_WORLD_DEFAULT = 0x1,
	LAYOUT_CUSTOM = 0x2,
};

// Alignment: 4
// Size: 0x5
enum class Touch_t : uint32_t
{
	touch_none = 0x0,
	touch_player_only = 0x1,
	touch_npc_only = 0x2,
	touch_player_or_npc = 0x3,
	touch_player_or_npc_or_physicsprop = 0x4,
};

// Alignment: 4
// Size: 0x7
enum class CGameChoreoServices__ChoreoState_t : uint32_t
{
	STATE_PRE_SCRIPT = 0x0,
	STATE_WAIT_FOR_SCRIPT = 0x1,
	STATE_WALK_TO_MARK = 0x2,
	STATE_SYNCHRONIZE_SCRIPT = 0x3,
	STATE_PLAY_SCRIPT = 0x4,
	STATE_PLAY_SCRIPT_POST_IDLE = 0x5,
	STATE_PLAY_SCRIPT_POST_IDLE_DONE = 0x6,
};

// Alignment: 4
// Size: 0xb
enum class Hull_t : uint32_t
{
	HULL_HUMAN = 0x0,
	HULL_SMALL_CENTERED = 0x1,
	HULL_WIDE_HUMAN = 0x2,
	HULL_TINY = 0x3,
	HULL_MEDIUM = 0x4,
	HULL_TINY_CENTERED = 0x5,
	HULL_LARGE = 0x6,
	HULL_LARGE_CENTERED = 0x7,
	HULL_MEDIUM_TALL = 0x8,
	NUM_HULLS = 0x9,
	HULL_NONE = 0xa,
};

// Alignment: 4
// Size: 0x1
enum class navproperties_t : uint32_t
{
	NAV_IGNORE = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class CLogicBranchList__LogicBranchListenerLastState_t : uint32_t
{
	LOGIC_BRANCH_LISTENER_NOT_INIT = 0x0,
	LOGIC_BRANCH_LISTENER_ALL_TRUE = 0x1,
	LOGIC_BRANCH_LISTENER_ALL_FALSE = 0x2,
	LOGIC_BRANCH_LISTENER_MIXED = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class EntFinderMethod_t : uint32_t
{
	ENT_FIND_METHOD_NEAREST = 0x0,
	ENT_FIND_METHOD_FARTHEST = 0x1,
	ENT_FIND_METHOD_RANDOM = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class ValueRemapperInputType_t : uint32_t
{
	InputType_PlayerShootPosition = 0x0,
	InputType_PlayerShootPositionAroundAxis = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class ValueRemapperOutputType_t : uint32_t
{
	OutputType_AnimationCycle = 0x0,
	OutputType_RotationX = 0x1,
	OutputType_RotationY = 0x2,
	OutputType_RotationZ = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class ValueRemapperHapticsType_t : uint32_t
{
	HaticsType_Default = 0x0,
	HaticsType_None = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class ValueRemapperMomentumType_t : uint32_t
{
	MomentumType_None = 0x0,
	MomentumType_Friction = 0x1,
	MomentumType_SpringTowardSnapValue = 0x2,
	MomentumType_SpringAwayFromSnapValue = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class ValueRemapperRatchetType_t : uint32_t
{
	RatchetType_Absolute = 0x0,
	RatchetType_EachEngage = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class PointWorldTextJustifyHorizontal_t : uint32_t
{
	POINT_WORLD_TEXT_JUSTIFY_HORIZONTAL_LEFT = 0x0,
	POINT_WORLD_TEXT_JUSTIFY_HORIZONTAL_CENTER = 0x1,
	POINT_WORLD_TEXT_JUSTIFY_HORIZONTAL_RIGHT = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class PointWorldTextJustifyVertical_t : uint32_t
{
	POINT_WORLD_TEXT_JUSTIFY_VERTICAL_BOTTOM = 0x0,
	POINT_WORLD_TEXT_JUSTIFY_VERTICAL_CENTER = 0x1,
	POINT_WORLD_TEXT_JUSTIFY_VERTICAL_TOP = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class PointWorldTextReorientMode_t : uint32_t
{
	POINT_WORLD_TEXT_REORIENT_NONE = 0x0,
	POINT_WORLD_TEXT_REORIENT_AROUND_UP = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class doorCheck_e : uint32_t
{
	DOOR_CHECK_FORWARD = 0x0,
	DOOR_CHECK_BACKWARD = 0x1,
	DOOR_CHECK_FULL = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class PropDoorRotatingSpawnPos_t : uint32_t
{
	DOOR_SPAWN_CLOSED = 0x0,
	DOOR_SPAWN_OPEN_FORWARD = 0x1,
	DOOR_SPAWN_OPEN_BACK = 0x2,
	DOOR_SPAWN_AJAR = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class PropDoorRotatingOpenDirection_e : uint32_t
{
	DOOR_ROTATING_OPEN_BOTH_WAYS = 0x0,
	DOOR_ROTATING_OPEN_FORWARD = 0x1,
	DOOR_ROTATING_OPEN_BACKWARD = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class SceneOnPlayerDeath_t : uint32_t
{
	SCENE_ONPLAYERDEATH_DO_NOTHING = 0x0,
	SCENE_ONPLAYERDEATH_CANCEL = 0x1,
};

// Alignment: 4
// Size: 0x2
enum class ScriptedConflictResponse_t : uint32_t
{
	SS_CONFLICT_ENQUEUE = 0x0,
	SS_CONFLICT_INTERRUPT = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class TRAIN_CODE : uint32_t
{
	TRAIN_SAFE = 0x0,
	TRAIN_BLOCKING = 0x1,
	TRAIN_FOLLOWING = 0x2,
};

// Alignment: 4
// Size: 0x8
enum class TOGGLE_STATE : uint32_t
{
	TS_AT_TOP = 0x0,
	TS_AT_BOTTOM = 0x1,
	TS_GOING_UP = 0x2,
	TS_GOING_DOWN = 0x3,
	DOOR_OPEN = 0x0,
	DOOR_CLOSED = 0x1,
	DOOR_OPENING = 0x2,
	DOOR_CLOSING = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class FuncDoorSpawnPos_t : uint32_t
{
	FUNC_DOOR_SPAWN_CLOSED = 0x0,
	FUNC_DOOR_SPAWN_OPEN = 0x1,
};

// Alignment: 4
// Size: 0x2
enum class filter_t : uint32_t
{
	FILTER_AND = 0x0,
	FILTER_OR = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class Explosions : uint32_t
{
	expRandom = 0x0,
	expDirected = 0x1,
	expUsePrecise = 0x2,
};

// Alignment: 4
// Size: 0xc
enum class Materials : uint32_t
{
	matGlass = 0x0,
	matWood = 0x1,
	matMetal = 0x2,
	matFlesh = 0x3,
	matCinderBlock = 0x4,
	matCeilingTile = 0x5,
	matComputer = 0x6,
	matUnbreakableGlass = 0x7,
	matRocks = 0x8,
	matWeb = 0x9,
	matNone = 0xa,
	matLastMaterial = 0xb,
};

// Alignment: 4
// Size: 0x3
enum class TrackOrientationType_t : uint32_t
{
	TrackOrientation_Fixed = 0x0,
	TrackOrientation_FacePath = 0x1,
	TrackOrientation_FacePathAngles = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class SimpleConstraintSoundProfile__SimpleConstraintsSoundProfileKeypoints_t : uint32_t
{
	kMIN_THRESHOLD = 0x0,
	kMIN_FULL = 0x1,
	kHIGHWATER = 0x2,
};

// Alignment: 4
// Size: 0x17
enum class SoundFlags_t : uint32_t
{
	SOUND_NONE = 0x0,
	SOUND_COMBAT = 0x1,
	SOUND_WORLD = 0x2,
	SOUND_PLAYER = 0x4,
	SOUND_DANGER = 0x8,
	SOUND_BULLET_IMPACT = 0x10,
	SOUND_THUMPER = 0x20,
	SOUND_PHYSICS_DANGER = 0x40,
	SOUND_MOVE_AWAY = 0x80,
	SOUND_PLAYER_VEHICLE = 0x100,
	SOUND_GLASS_BREAK = 0x200,
	SOUND_PHYSICS_OBJECT = 0x400,
	SOUND_CONTEXT_GUNFIRE = 0x100000,
	SOUND_CONTEXT_COMBINE_ONLY = 0x200000,
	SOUND_CONTEXT_REACT_TO_SOURCE = 0x400000,
	SOUND_CONTEXT_EXPLOSION = 0x800000,
	SOUND_CONTEXT_EXCLUDE_COMBINE = 0x1000000,
	SOUND_CONTEXT_DANGER_APPROACH = 0x2000000,
	SOUND_CONTEXT_ALLIES_ONLY = 0x4000000,
	SOUND_CONTEXT_PANIC_NPCS = 0x8000000,
	ALL_CONTEXTS = 0xfffffffffff00000,
	ALL_SCENTS = 0x0,
	ALL_SOUNDS = 0xfffff,
};

// Alignment: 4
// Size: 0x3
enum class TrainVelocityType_t : uint32_t
{
	TrainVelocity_Instantaneous = 0x0,
	TrainVelocity_LinearBlend = 0x1,
	TrainVelocity_EaseInEaseOut = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class TrainOrientationType_t : uint32_t
{
	TrainOrientation_Fixed = 0x0,
	TrainOrientation_AtPathTracks = 0x1,
	TrainOrientation_LinearBlend = 0x2,
	TrainOrientation_EaseInEaseOut = 0x3,
};

// Alignment: 4
// Size: 0x15
enum class sound_states : uint32_t
{
	SS_NONE = 0x0,
	SS_SHUTDOWN = 0x1,
	SS_SHUTDOWN_WATER = 0x2,
	SS_START_WATER = 0x3,
	SS_START_IDLE = 0x4,
	SS_IDLE = 0x5,
	SS_GEAR_0 = 0x6,
	SS_GEAR_1 = 0x7,
	SS_GEAR_2 = 0x8,
	SS_GEAR_3 = 0x9,
	SS_GEAR_4 = 0xa,
	SS_SLOWDOWN = 0xb,
	SS_SLOWDOWN_HIGHSPEED = 0xc,
	SS_GEAR_0_RESUME = 0xd,
	SS_GEAR_1_RESUME = 0xe,
	SS_GEAR_2_RESUME = 0xf,
	SS_GEAR_3_RESUME = 0x10,
	SS_GEAR_4_RESUME = 0x11,
	SS_TURBO = 0x12,
	SS_REVERSE = 0x13,
	SS_NUM_STATES = 0x14,
};

// Alignment: 4
// Size: 0x7
enum class BeamType_t : uint32_t
{
	BEAM_INVALID = 0x0,
	BEAM_POINTS = 0x1,
	BEAM_ENTPOINT = 0x2,
	BEAM_ENTS = 0x3,
	BEAM_HOSE = 0x4,
	BEAM_SPLINE = 0x5,
	BEAM_LASER = 0x6,
};

// Alignment: 4
// Size: 0x4
enum class BeamClipStyle_t : uint32_t
{
	kNOCLIP = 0x0,
	kGEOCLIP = 0x1,
	kMODELCLIP = 0x2,
	kBEAMCLIPSTYLE_NUMBITS = 0x2,
};

// Alignment: 1
// Size: 0x9
enum class SurroundingBoundsType_t : uint8_t
{
	USE_OBB_COLLISION_BOUNDS = 0x0,
	USE_BEST_COLLISION_BOUNDS = 0x1,
	USE_HITBOXES = 0x2,
	USE_SPECIFIED_BOUNDS = 0x3,
	USE_GAME_CODE = 0x4,
	USE_ROTATION_EXPANDED_BOUNDS = 0x5,
	USE_COLLISION_BOUNDS_NEVER_VPHYSICS = 0x6,
	USE_ROTATION_EXPANDED_SEQUENCE_BOUNDS = 0x7,
	SURROUNDING_TYPE_BIT_COUNT = 0x3,
};

// Alignment: 1
// Size: 0x2
enum class ShatterPanelMode : uint8_t
{
	SHATTER_GLASS = 0x0,
	SHATTER_DRYWALL = 0x1,
};

// Alignment: 1
// Size: 0x5
enum class ShatterDamageCause : uint8_t
{
	SHATTERDAMAGE_BULLET = 0x0,
	SHATTERDAMAGE_MELEE = 0x1,
	SHATTERDAMAGE_THROWN = 0x2,
	SHATTERDAMAGE_SCRIPT = 0x3,
	SHATTERDAMAGE_EXPLOSIVE = 0x4,
};

// Alignment: 1
// Size: 0x5
enum class ShatterGlassStressType : uint8_t
{
	SHATTERGLASS_BLUNT = 0x0,
	SHATTERGLASS_BALLISTIC = 0x1,
	SHATTERGLASS_PULSE = 0x2,
	SHATTERDRYWALL_CHUNKS = 0x3,
	SHATTERGLASS_EXPLOSIVE = 0x4,
};

// Alignment: 1
// Size: 0x3
enum class OnFrame : uint8_t
{
	ONFRAME_UNKNOWN = 0x0,
	ONFRAME_TRUE = 0x1,
	ONFRAME_FALSE = 0x2,
};

// Alignment: 1
// Size: 0x2
enum class ShardSolid_t : uint8_t
{
	SHARD_SOLID = 0x0,
	SHARD_DEBRIS = 0x1,
};

// Alignment: 4
// Size: 0x7
enum class PoseController_FModType_t : uint32_t
{
	POSECONTROLLER_FMODTYPE_NONE = 0x0,
	POSECONTROLLER_FMODTYPE_SINE = 0x1,
	POSECONTROLLER_FMODTYPE_SQUARE = 0x2,
	POSECONTROLLER_FMODTYPE_TRIANGLE = 0x3,
	POSECONTROLLER_FMODTYPE_SAWTOOTH = 0x4,
	POSECONTROLLER_FMODTYPE_NOISE = 0x5,
	POSECONTROLLER_FMODTYPE_TOTAL = 0x6,
};

// Alignment: 4
// Size: 0x9
enum class EntitySubclassScope_t : uint32_t
{
	SUBCLASS_SCOPE_NONE = 0xffffffffffffffff,
	SUBCLASS_SCOPE_MISC = 0x0,
	SUBCLASS_SCOPE_PRECIPITATION = 0x1,
	SUBCLASS_SCOPE_GRENADES = 0x2,
	SUBCLASS_SCOPE_PLAYER_WEAPONS = 0x3,
	SUBCLASS_SCOPE_MODIFIERS = 0x4,
	SUBCLASS_SCOPE_NPC_UNITS = 0x5,
	SUBCLASS_SCOPE_NPC_ABILITIES = 0x6,
	SUBCLASS_SCOPE_COUNT = 0x7,
};

// Alignment: 4
// Size: 0x3
enum class SubclassVDataChangeType_t : uint32_t
{
	SUBCLASS_VDATA_CREATED = 0x0,
	SUBCLASS_VDATA_SUBCLASS_CHANGED = 0x1,
	SUBCLASS_VDATA_RELOADED = 0x2,
};

// Alignment: 4
// Size: 0x6
enum class PlayerConnectedState : uint32_t
{
	PlayerNeverConnected = 0xffffffffffffffff,
	PlayerConnected = 0x0,
	PlayerConnecting = 0x1,
	PlayerReconnecting = 0x2,
	PlayerDisconnecting = 0x3,
	PlayerDisconnected = 0x4,
};

// Alignment: 4
// Size: 0x10
enum class vote_create_failed_t : uint32_t
{
	VOTE_FAILED_GENERIC = 0x0,
	VOTE_FAILED_TRANSITIONING_PLAYERS = 0x1,
	VOTE_FAILED_RATE_EXCEEDED = 0x2,
	VOTE_FAILED_YES_MUST_EXCEED_NO = 0x3,
	VOTE_FAILED_QUORUM_FAILURE = 0x4,
	VOTE_FAILED_ISSUE_DISABLED = 0x5,
	VOTE_FAILED_MAP_NOT_FOUND = 0x6,
	VOTE_FAILED_MAP_NAME_REQUIRED = 0x7,
	VOTE_FAILED_FAILED_RECENTLY = 0x8,
	VOTE_FAILED_TEAM_CANT_CALL = 0x9,
	VOTE_FAILED_WAITINGFORPLAYERS = 0xa,
	VOTE_FAILED_PLAYERNOTFOUND = 0xb,
	VOTE_FAILED_CANNOT_KICK_ADMIN = 0xc,
	VOTE_FAILED_SCRAMBLE_IN_PROGRESS = 0xd,
	VOTE_FAILED_SPECTATOR = 0xe,
	VOTE_FAILED_MAX = 0xf,
};

// Alignment: 4
// Size: 0x3
enum class WeaponState_t : uint32_t
{
	WEAPON_NOT_CARRIED = 0x0,
	WEAPON_IS_CARRIED_BY_PLAYER = 0x1,
	WEAPON_IS_ACTIVE = 0x2,
};

// Alignment: 1
// Size: 0x9
enum class ItemFlagTypes_t : uint8_t
{
	ITEM_FLAG_NONE = 0x0,
	ITEM_FLAG_CAN_SELECT_WITHOUT_AMMO = 0x1,
	ITEM_FLAG_NOAUTORELOAD = 0x2,
	ITEM_FLAG_NOAUTOSWITCHEMPTY = 0x4,
	ITEM_FLAG_LIMITINWORLD = 0x8,
	ITEM_FLAG_EXHAUSTIBLE = 0x10,
	ITEM_FLAG_DOHITLOCATIONDMG = 0x20,
	ITEM_FLAG_NOAMMOPICKUPS = 0x40,
	ITEM_FLAG_NOITEMPICKUP = 0x80,
};

// Alignment: 4
// Size: 0x5
enum class EntityDisolveType_t : uint32_t
{
	ENTITY_DISSOLVE_INVALID = 0xffffffffffffffff,
	ENTITY_DISSOLVE_NORMAL = 0x0,
	ENTITY_DISSOLVE_ELECTRICAL = 0x1,
	ENTITY_DISSOLVE_ELECTRICAL_LIGHT = 0x2,
	ENTITY_DISSOLVE_CORE = 0x3,
};

// Alignment: 4
// Size: 0xd
enum class HitGroup_t : uint32_t
{
	HITGROUP_INVALID = 0xffffffffffffffff,
	HITGROUP_GENERIC = 0x0,
	HITGROUP_HEAD = 0x1,
	HITGROUP_CHEST = 0x2,
	HITGROUP_STOMACH = 0x3,
	HITGROUP_LEFTARM = 0x4,
	HITGROUP_RIGHTARM = 0x5,
	HITGROUP_LEFTLEG = 0x6,
	HITGROUP_RIGHTLEG = 0x7,
	HITGROUP_NECK = 0x8,
	HITGROUP_UNUSED = 0x9,
	HITGROUP_GEAR = 0xa,
	HITGROUP_SPECIAL = 0xb,
};

// Alignment: 4
// Size: 0x5
enum class DoorState_t : uint32_t
{
	DOOR_STATE_CLOSED = 0x0,
	DOOR_STATE_OPENING = 0x1,
	DOOR_STATE_OPEN = 0x2,
	DOOR_STATE_CLOSING = 0x3,
	DOOR_STATE_AJAR = 0x4,
};

// Alignment: 4
// Size: 0x2
enum class ShadowType_t : uint32_t
{
	SHADOWS_NONE = 0x0,
	SHADOWS_SIMPLE = 0x1,
};

// Alignment: 4
// Size: 0x8
enum class Class_T : uint32_t
{
	CLASS_NONE = 0x0,
	CLASS_PLAYER = 0x1,
	CLASS_PLAYER_ALLY = 0x2,
	CLASS_MODIFIER_THINKER = 0x3,
	CLASS_BULLSEYE = 0x4,
	CLASS_GENERIC_ACTOR = 0x5,
	CLASS_ENEMY_APPLIANCE = 0x6,
	NUM_CLASSIFY_CLASSES = 0x7,
};

// Alignment: 4
// Size: 0xa
enum class Disposition_t : uint32_t
{
	D_ER = 0x0,
	D_HT = 0x1,
	D_FR = 0x2,
	D_LI = 0x3,
	D_NU = 0x4,
	D_ERROR = 0x0,
	D_HATE = 0x1,
	D_FEAR = 0x2,
	D_LIKE = 0x3,
	D_NEUTRAL = 0x4,
};

// Alignment: 4
// Size: 0x6
enum class LatchDirtyPermission_t : uint32_t
{
	LATCH_DIRTY_DISALLOW = 0x0,
	LATCH_DIRTY_SERVER_CONTROLLED = 0x1,
	LATCH_DIRTY_CLIENT_SIMULATED = 0x2,
	LATCH_DIRTY_PREDICTION = 0x3,
	LATCH_DIRTY_FRAMESIMULATE = 0x4,
	LATCH_DIRTY_PARTICLE_SIMULATE = 0x5,
};

// Alignment: 4
// Size: 0x5
enum class LifeState_t : uint32_t
{
	LIFE_ALIVE = 0x0,
	LIFE_DYING = 0x1,
	LIFE_DEAD = 0x2,
	LIFE_RESPAWNABLE = 0x3,
	LIFE_RESPAWNING = 0x4,
};

// Alignment: 4
// Size: 0x4
enum class StanceType_t : uint32_t
{
	STANCE_CURRENT = 0xffffffffffffffff,
	STANCE_DEFAULT = 0x0,
	STANCE_CROUCHING = 0x1,
	NUM_STANCES = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class ModifyDamageReturn_t : uint32_t
{
	CONTINUE_TO_APPLY_DAMAGE = 0x0,
	ABORT_DO_NOT_APPLY_DAMAGE = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class WorldTextPanelHorizontalAlign_t : uint32_t
{
	WORLDTEXT_HORIZONTAL_ALIGN_LEFT = 0x0,
	WORLDTEXT_HORIZONTAL_ALIGN_CENTER = 0x1,
	WORLDTEXT_HORIZONTAL_ALIGN_RIGHT = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class WorldTextPanelVerticalAlign_t : uint32_t
{
	WORLDTEXT_VERTICAL_ALIGN_TOP = 0x0,
	WORLDTEXT_VERTICAL_ALIGN_CENTER = 0x1,
	WORLDTEXT_VERTICAL_ALIGN_BOTTOM = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class WorldTextPanelOrientation_t : uint32_t
{
	WORLDTEXT_ORIENTATION_DEFAULT = 0x0,
	WORLDTEXT_ORIENTATION_FACEUSER = 0x1,
	WORLDTEXT_ORIENTATION_FACEUSER_UPRIGHT = 0x2,
};

// Alignment: 4
// Size: 0x7
enum class WorldTextAttachmentType_t : uint32_t
{
	ATTACHED_NONE = 0x0,
	ATTACHED_PRIMARY_HAND = 0x1,
	ATTACHED_OFF_HAND = 0x2,
	ATTACHED_ENTITY = 0x3,
	ATTACHED_HMD = 0x4,
	ATTACHED_ENTITY_LARGE = 0x5,
	ATTACHED_HAND_SPECIFIED_IN_EVENT = 0x6,
};

// Alignment: 4
// Size: 0x5
enum class AI_Efficiency_t : uint32_t
{
	AIE_NORMAL = 0x0,
	AIE_EFFICIENT = 0x1,
	AIE_VERY_EFFICIENT = 0x2,
	AIE_SUPER_EFFICIENT = 0x3,
	AIE_DORMANT = 0x4,
};

// Alignment: 4
// Size: 0x2
enum class AI_MoveEfficiency_t : uint32_t
{
	AIME_NORMAL = 0x0,
	AIME_EFFICIENT = 0x1,
};

// Alignment: 4
// Size: 0x6
enum class AI_SleepState_t : uint32_t
{
	AISS_AWAKE = 0x0,
	AISS_WAITING_FOR_THREAT = 0x1,
	AISS_WAITING_FOR_PVS = 0x2,
	AISS_WAITING_FOR_INPUT = 0x3,
	AISS_AUTO_PVS = 0x4,
	AISS_AUTO_PVS_AFTER_PVS = 0x5,
};

// Alignment: 4
// Size: 0x8
enum class NPC_STATE : uint32_t
{
	NPC_STATE_INVALID = 0xffffffffffffffff,
	NPC_STATE_NONE = 0x0,
	NPC_STATE_IDLE = 0x1,
	NPC_STATE_ALERT = 0x2,
	NPC_STATE_COMBAT = 0x3,
	NPC_STATE_SCRIPT = 0x4,
	NPC_STATE_DEAD = 0x5,
	NUM_NPC_STATES = 0x6,
};

// Alignment: 4
// Size: 0x7
enum class Flinch_DamageClasses_t : uint32_t
{
	AGE_DMG_INVALID = 0xffffffffffffffff,
	AGE_DMG_LIGHT = 0x0,
	AGE_DMG_HEAVY = 0x1,
	AGE_DMG_BLAST = 0x2,
	AGE_DMG_PHYSICS = 0x3,
	AGE_DMG_MELEE = 0x4,
	AGE_DMG_SHOCK = 0x5,
};

// Alignment: 4
// Size: 0x2
enum class CAI_GoalEntity__SearchType_t : uint32_t
{
	ST_ENTNAME = 0x0,
	ST_CLASSNAME = 0x1,
};

// Alignment: 4
// Size: 0x3f
enum class Hint_e : uint32_t
{
	HINT_ANY = 0xffffffffffffffff,
	HINT_NONE = 0x0,
	HINT_NOT_USED_WORLD_DOOR = 0x1,
	HINT_WORLD_WINDOW = 0x2,
	HINT_NOT_USED_WORLD_BUTTON = 0x3,
	HINT_NOT_USED_WORLD_MACHINERY = 0x4,
	HINT_NOT_USED_WORLD_LEDGE = 0x5,
	HINT_NOT_USED_WORLD_LIGHT_SOURCE = 0x6,
	HINT_NOT_USED_WORLD_HEAT_SOURCE = 0x7,
	HINT_NOT_USED_WORLD_BLINKING_LIGHT = 0x8,
	HINT_NOT_USED_WORLD_BRIGHT_COLORS = 0x9,
	HINT_NOT_USED_WORLD_HUMAN_BLOOD = 0xa,
	HINT_NOT_USED_WORLD_ALIEN_BLOOD = 0xb,
	HINT_WORLD_WORK_POSITION = 0xc,
	HINT_WORLD_VISUALLY_INTERESTING = 0xd,
	HINT_WORLD_VISUALLY_INTERESTING_DONT_AIM = 0xe,
	HINT_WORLD_INHIBIT_COMBINE_MINES = 0xf,
	HINT_WORLD_VISUALLY_INTERESTING_STEALTH = 0x10,
	HINT_GENERIC = 0x11,
	HINT_TACTICAL_COVER_MED = 0x64,
	HINT_TACTICAL_COVER_LOW = 0x65,
	HINT_TACTICAL_HIDE = 0x66,
	HINT_TACTICAL_PINCH = 0x67,
	HINT_TACTICAL_SENTRY = 0x68,
	HINT_TACTICAL_ENEMY_DISADVANTAGED = 0x69,
	HINT_NOT_USED_HEALTH_KIT = 0x6a,
	HINT_TACTICAL_HIGH_GROUND = 0x6b,
	HINT_TACTICAL_WALL_COVER_LEFT = 0x6c,
	HINT_TACTICAL_WALL_COVER_RIGHT = 0x6d,
	HINT_TACTICAL_WALL_COVER_BOTH = 0x6e,
	HINT_NOT_USED_URBAN_STREETCORNER = 0xc8,
	HINT_NOT_USED_URBAN_STREETLAMP = 0xc9,
	HINT_NOT_USED_URBAN_DARK_SPOT = 0xca,
	HINT_NOT_USED_URBAN_POSTER = 0xcb,
	HINT_NOT_USED_URBAN_SHELTER = 0xcc,
	HINT_NOT_USED_ASSASSIN_SECLUDED = 0x12c,
	HINT_NOT_USED_ASSASSIN_RAFTERS = 0x12d,
	HINT_NOT_USED_ASSASSIN_GROUND = 0x12e,
	HINT_NOT_USED_ASSASSIN_MONKEYBARS = 0x12f,
	HINT_ANTLION_BURROW_POINT = 0x190,
	HINT_ANTLION_THUMPER_FLEE_POINT = 0x191,
	HINT_HEADCRAB_BURROW_POINT = 0x1c2,
	HINT_HEADCRAB_EXIT_POD_POINT = 0x1c3,
	HINT_NOT_USED_ROLLER_PATROL_POINT = 0x1f4,
	HINT_NOT_USED_ROLLER_CLEANUP_POINT = 0x1f5,
	HINT_NOT_USED_PSTORM_ROCK_SPAWN = 0x258,
	HINT_CROW_FLYTO_POINT = 0x2bc,
	HINT_BUG_PATROL_POINT = 0x320,
	HINT_FOLLOW_WAIT_POINT = 0x384,
	HINT_JUMP_OVERRIDE = 0x385,
	HINT_PLAYER_SQUAD_TRANSITON_POINT = 0x386,
	HINT_NPC_EXIT_POINT = 0x387,
	HINT_STRIDER_NODE = 0x388,
	HINT_PLAYER_ALLY_MOVE_AWAY_DEST = 0x3b6,
	HINT_PLAYER_ALLY_FEAR_DEST = 0x3b7,
	HINT_CSTRIKE_HOSTAGE_ESCAPE = 0x44c,
	HINT_COMBINE_FALLBACK = 0x578,
	HINT_COMBINE_SIGNAL = 0x579,
	HINT_AGENT_WORK = 0x5dc,
	HINT_INSTIGATOR_LURK = 0x640,
	HINT_FLYGUY_JUMP = 0x6a4,
	HINT_HOLDOUT_DEFENSIVE_POSITION = 0x708,
	HINT_HOLDOUT_AMMO_RESUPPLY = 0x709,
};

// Alignment: 4
// Size: 0x3
enum class HintIgnoreFacing_t : uint32_t
{
	HIF_NO = 0x0,
	HIF_YES = 0x1,
	HIF_DEFAULT = 0x2,
};

// Alignment: 4
// Size: 0x7
enum class GoalType_t : uint32_t
{
	GOALTYPE_NONE = 0x0,
	GOALTYPE_ENTITY = 0x1,
	GOALTYPE_PATHCORNER = 0x2,
	GOALTYPE_LOCATION = 0x3,
	GOALTYPE_COVER = 0x4,
	GOALTYPE_LOS = 0x5,
	GOALTYPE_INVALID = 0x6,
};

// Alignment: 4
// Size: 0x2
enum class EAIScheduleFlags : uint32_t
{
	SCHEDULE_FLAGS_NONE = 0x0,
	SCHEDULE_FLAGS_ABILITY = 0x1,
};

// Alignment: 4
// Size: 0xb
enum class SquadSlotId_t : uint32_t
{
	SQUAD_SLOT_NONE = 0xffffffffffffffff,
	SQUAD_SLOT_ATTACK1 = 0x0,
	SQUAD_SLOT_ATTACK2 = 0x1,
	SQUAD_SLOT_ATTACK3 = 0x2,
	SQUAD_SLOT_INVESTIGATE_SOUND = 0x3,
	SQUAD_SLOT_EXCLUSIVE_HANDSIGN = 0x4,
	SQUAD_SLOT_EXCLUSIVE_RELOAD = 0x5,
	SQUAD_SLOT_PICKUP_WEAPON1 = 0x6,
	SQUAD_SLOT_PICKUP_WEAPON2 = 0x7,
	SQUAD_SLOT_SPECIAL_ATTACK = 0x8,
	SQUAD_SLOT_COUNT = 0x9,
};

// Alignment: 4
// Size: 0x5
enum class TaskStatus_e : uint32_t
{
	TASKSTATUS_NEW = 0x0,
	TASKSTATUS_RUN_MOVE_AND_TASK = 0x1,
	TASKSTATUS_RUN_MOVE = 0x2,
	TASKSTATUS_RUN_TASK = 0x3,
	TASKSTATUS_COMPLETE = 0x4,
};

// Alignment: 4
// Size: 0x3
enum class CBaseNPCMaker__ThreeStateYesNo_t : uint32_t
{
	TS_YN_YES = 0x0,
	TS_YN_NO = 0x1,
	TS_YN_DONT_CARE = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class CBaseNPCMaker__ThreeStateDist_t : uint32_t
{
	TS_DIST_NEAREST = 0x0,
	TS_DIST_FARTHEST = 0x1,
	TS_DIST_DONT_CARE = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class TestHullMode_t : uint32_t
{
	TEST_HULL_EVER_PASSABLE = 0x0,
	TEST_HULL_CURRENTLY_PASSABLE = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class NPCAbilityCategory_t : uint32_t
{
	NPC_ABILITY_CATEGORY_INVALID = 0xffffffffffffffff,
	NPC_ABILITY_CATEGORY_RANGED = 0x0,
	NPC_ABILITY_CATEGORY_MELEE = 0x1,
	NPC_ABILITY_CATEGORY_OTHER = 0x2,
};

// Alignment: 4
// Size: 0x2
enum class NPCAbilityUsageQuery_t : uint32_t
{
	NPC_ABILITY_ONLY_BEING_PERFORMED = 0x0,
	NPC_ABILITY_PERFORMING_OR_RESOLUTION = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class TargetOriginType_t : uint32_t
{
	eTargetOriginType_AbsOrigin = 0x0,
	eTargetOriginType_PredictedAbsOrigin = 0x1,
	eTargetOriginType_LastKnownPosition = 0x2,
	eTargetOriginType_LastSeenPosition = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class AbilityPathType_t : uint32_t
{
	eAbilityPathType_None = 0x0,
	eAbilityPathType_Target = 0x1,
};

// Alignment: 4
// Size: 0x5
enum class AbilityPickupBehaviorType_t : uint32_t
{
	eAbilityPickupBehavior_GrantDroppedAmmo = 0x0,
	eAbilityPickupBehavior_GrantSpecifiedAmmo = 0x1,
	eAbilityPickupBehavior_GrantDroppedNPCAbility = 0x2,
	eAbilityPickupBehavior_GrantSpecifiedNPCAbility = 0x3,
	eAbilityPickupBehavior_GrantPlayerWeapon = 0x4,
};

// Alignment: 4
// Size: 0x3
enum class AbilityDropBehaviorType_t : uint32_t
{
	eAbilityDropBehavior_AddIntAttributeToAbilityModel = 0x0,
	eAbilityDropBehavior_CreateEntityBySubclass = 0x1,
	eAbilityDropBehavior_SetGravityScale = 0x2,
};

// Alignment: 4
// Size: 0x7
enum class BodyLocations_t : uint32_t
{
	BODYLOC_INVALID = 0xffffffffffffffff,
	BODYLOC_EYES = 0x0,
	BODYLOC_MUZZLE = 0x1,
	BODYLOC_ABSORIGIN = 0x2,
	BODYLOC_BODYTARGET = 0x3,
	BODYLOC_HEADTARGET = 0x4,
	NUM_BODYLOCS = 0x5,
};

// Alignment: 4
// Size: 0x4
enum class BodyLocationAnimgraphAttachments_t : uint32_t
{
	BODYLOC_PITCH_MIDDLE = 0x0,
	BODYLOC_PITCH_DOWN = 0x1,
	BODYLOC_PITCH_UP = 0x2,
	NUM_BODYLOC_PITCH = 0x3,
};

// Alignment: 4
// Size: 0x1
enum class PoseParameter_t : uint32_t
{
	POSE_END = 0x7fffffff,
};

// Alignment: 4
// Size: 0x1
enum class FlexWeight_t : uint32_t
{
	FLEX_END = 0x7fffffff,
};

// Alignment: 4
// Size: 0x4
enum class ActorClasses_t : uint32_t
{
	ACTOR_CLASS_DEFAULT = 0x0,
	ACTOR_CLASS_ALYX = 0x0,
	ACTOR_CLASS_CITIZEN = 0x1,
	ACTOR_CLASS_COUNT = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class Interruptability_t : uint32_t
{
	GENERAL_INTERRUPTABILITY = 0x0,
	DAMAGEORDEATH_INTERRUPTABILITY = 0x1,
	DEATH_INTERRUPTABILITY = 0x2,
	COMBAT_INTERRUPTABILITY = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class RagdollBlendDirection : uint32_t
{
	RAGDOLL_BLEND_IN = 0x0,
	RAGDOLL_BLEND_OUT = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class Flinch_Direction_t : uint32_t
{
	FLINCH_DIR_NORTH = 0x0,
	FLINCH_DIR_EAST = 0x1,
	FLINCH_DIR_SOUTH = 0x2,
	FLINCH_DIR_WEST = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class Flinch_Displacement_t : uint32_t
{
	FLINCH_DISP_STATIONARY = 0x0,
	FLINCH_DISP_SMALL = 0x1,
	FLINCH_DISP_LARGE = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class DesiredWeaponState_t : uint32_t
{
	DESIREDWEAPONSTATE_IGNORE = 0x0,
	DESIREDWEAPONSTATE_HOLSTERED = 0x1,
	DESIREDWEAPONSTATE_HOLSTERED_DESTROYED = 0x2,
	DESIREDWEAPONSTATE_UNHOLSTERED = 0x3,
};

// Alignment: 4
// Size: 0x4
enum class InternalWeaponState_t : uint32_t
{
	INTERNALWEAPONSTATE_HOLSTERED = 0x0,
	INTERNALWEAPONSTATE_UNHOLSTERED = 0x1,
	INTERNALWEAPONSTATE_CHANGING = 0x2,
	INTERNALWEAPONSTATE_CHANGING_DESTROY = 0x3,
};

// Alignment: 4
// Size: 0x4
enum class WeaponStateMode_t : uint32_t
{
	WSM_AI = 0x0,
	WSM_FORCED_HOLSTERED = 0x1,
	WSM_FORCED_UNHOLSTERED = 0x2,
	WSM_FORCED_HOLSTERED_DESTROY = 0x3,
};

// Alignment: 4
// Size: 0x4
enum class CAI_TrackPather__PauseState_t : uint32_t
{
	PAUSE_NO_PAUSE = 0x0,
	PAUSED_AT_POSITION = 0x1,
	PAUSE_AT_NEXT_LOS_POSITION = 0x2,
	PAUSE_FORCE_DWORD = 0xffffffffffffffff,
};

// Alignment: 4
// Size: 0x6
enum class CAI_StandoffGoal__Aggressiveness_t : uint32_t
{
	AGGR_VERY_LOW = 0x0,
	AGGR_LOW = 0x1,
	AGGR_MEDIUM = 0x2,
	AGGR_HIGH = 0x3,
	AGGR_VERY_HIGH = 0x4,
	AGGR_CUSTOM = 0x5,
};

// Alignment: 4
// Size: 0x3
enum class AI_HintChangeReaction_t : uint32_t
{
	AIHCR_DEFAULT_AI = 0x0,
	AIHCR_MOVE_ON_COVER = 0x1,
	AIHCR_MOVE_IMMEDIATE = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class AI_Posture_t : uint32_t
{
	AIP_INDIFFERENT = 0x0,
	AIP_STANDING = 0x1,
	AIP_CROUCHING = 0x2,
	AIP_PEEKING = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class ScriptedMovementType_t : uint32_t
{
	SCRIPT_WALK = 0x0,
	SCRIPT_RUN = 0x1,
};

// Alignment: 4
// Size: 0x3
enum class NPCAbilityTaskPhase_t : uint32_t
{
	TASK_PRE_ATTACK = 0x0,
	TASK_ATTACK = 0x1,
	TASK_POST_ATTACK = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class NPCAbilityTaskHandling_t : uint32_t
{
	TASK_START = 0x0,
	TASK_RUN = 0x1,
	TASK_END = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class NPCAbilityLOSMethod_t : uint32_t
{
	NPC_ABILITY_LOS_IGNORE = 0x0,
	NPC_ABILITY_LOS_USE_DEFAULT = 0x1,
	NPC_ABILITY_LOS_CUSTOM = 0x2,
	NPC_ABILITY_LOS_TEST_FRIENDLIES_ONLY = 0x3,
};

// Alignment: 4
// Size: 0x2
enum class GatherConditionsResult_t : uint32_t
{
	GATHER_CONDITIONS_CANNOT_USE_ABILITY = 0x0,
	GATHER_CONDITIONS_CAN_USE_ABILITY = 0x1,
};

// Alignment: 4
// Size: 0xb
enum class NPCAbilitySound_t : uint32_t
{
	NPC_ABILITY_SOUND_EMPTY = 0x0,
	NPC_ABILITY_SOUND_SINGLE = 0x1,
	NPC_ABILITY_SOUND_RELOAD = 0x2,
	NPC_ABILITY_SOUND_MELEE_HIT = 0x3,
	NPC_ABILITY_SOUND_MELEE_HIT_WORLD = 0x4,
	NPC_ABILITY_SOUND_MELEE_HIT_PLAYER = 0x5,
	NPC_ABILITY_SOUND_SPECIAL1 = 0x6,
	NPC_ABILITY_SOUND_ANNOUNCE = 0x7,
	NPC_ABILITY_SOUND_TARGET_REACQUIRE = 0x8,
	NPC_ABILITY_SOUND_INTERRUPT = 0x9,
	NPC_ABILITY_SOUND_NUM_TYPES = 0xa,
};

// Alignment: 4
// Size: 0x2
enum class ENPCAbilityMeleeAttackEvaluationTest : uint32_t
{
	NPC_ABILITY_MELEE_ATTACK_EVAL_TEST_HULL = 0x0,
	NPC_ABILITY_MELEE_ATTACK_EVAL_TEST_LOS = 0x1,
};

// Alignment: 4
// Size: 0x4
enum class ModifierRemoveTargets_t : uint32_t
{
	MODIFIER_REMOVE_ALL = 0x0,
	MODIFIER_REMOVE_ENEMY = 0x1,
	MODIFIER_REMOVE_ALLY = 0x2,
	MODIFIER_REMOVE_INTRINSIC = 0x3,
};

// Alignment: 4
// Size: 0x8
enum class ModifierAttribute_t : uint32_t
{
	MODIFIER_ATTRIBUTE_NONE = 0x0,
	MODIFIER_ATTRIBUTE_PERMANENT = 0x1,
	MODIFIER_ATTRIBUTE_MULTIPLE = 0x2,
	MODIFIER_ATTRIBUTE_IGNORE_INVULNERABLE = 0x4,
	MODIFIER_ATTRIBUTE_AURA_PRIORITY = 0x8,
	MODIFIER_ATTRIBUTE_CANNOT_BE_PURGED = 0x10,
	MODIFIER_ATTRIBUTE_INTRINSIC = 0x20,
	MODIFIER_ATTRIBUTE_TRANSFER_TO_RAGDOLL = 0x40,
};

// Alignment: 4
// Size: 0x5
enum class ModifierDisableGroup_t : uint32_t
{
	MODIFIER_DISABLE_GROUP_MIN = 0x0,
	MODIFIER_DISABLE_GROUP_ACTIVE_WEAPON = 0x1,
	MODIFIER_DISABLE_GROUP_TIME_LOCKED = 0x2,
	MODIFIER_DISABLE_GROUP_MAX_BIT = 0x1,
	MODIFIER_DISABLE_GROUP_MAX = 0x2,
};

// Alignment: 4
// Size: 0x3
enum class EModifierScriptVariantType : uint32_t
{
	MODIFIER_SCRIPT_VARIANT_MODIFIER_FLOAT = 0x0,
	MODIFIER_SCRIPT_VARIANT_MODEL = 0x1,
	MODIFIER_SCRIPT_VARIANT_PARTICLE = 0x2,
};

// Alignment: 4
// Size: 0x4
enum class ModifierSoundRecipients_t : uint32_t
{
	MODIFIER_SOUND_RECIPIENT_ALWAYS = 0x0,
	MODIFIER_SOUND_RECIPIENT_PARENT_IS_LOCAL_PLAYER = 0x1,
	MODIFIER_SOUND_RECIPIENT_PARENT_ON_SAME_TEAM_AS_LOCAL_PLAYER = 0x2,
	MODIFIER_SOUND_RECIPIENT_PARENT_ON_OPPOSITE_TEAM_AS_LOCAL_PLAYER = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class ModifierDebuffType_t : uint32_t
{
	MODIFIER_DEBUFF_ENEMY_TEAM_ONLY = 0x0,
	MODIFIER_DEBUFF_YES = 0x1,
	MODIFIER_DEBUFF_NO = 0x2,
};

// Alignment: 4
// Size: 0x12
enum class EModifierValue : uint32_t
{
	MODIFIER_VALUE_MATERIAL_OVERRIDE = 0x0,
	MODIFIER_VALUE_PROC_BUILDUP_PERCENTAGE = 0x1,
	MODIFIER_VALUE_INCOMING_DAMAGE_PERCENTAGE = 0x2,
	MODIFIER_VALUE_OUTGOING_DAMAGE_PERCENTAGE = 0x3,
	MODIFIER_VALUE_ABILITY_MIN_BURST_SIZE_CONSTANT = 0x4,
	MODIFIER_VALUE_ABILITY_MAX_BURST_SIZE_CONSTANT = 0x5,
	MODIFIER_VALUE_ABILITY_POST_USE_MIN_ATTACK_DELAY_CONSTANT = 0x6,
	MODIFIER_VALUE_ABILITY_POST_USE_MAX_ATTACK_DELAY_CONSTANT = 0x7,
	MODIFIER_VALUE_ABILITY_SPREAD_X_BASE_OVERRIDE = 0x8,
	MODIFIER_VALUE_ABILITY_SPREAD_Y_BASE_OVERRIDE = 0x9,
	MODIFIER_VALUE_ABILITY_SPREAD_Z_BASE_OVERRIDE = 0xa,
	MODIFIER_VALUE_ABILITY_SPREAD_MULTIPLIER = 0xb,
	MODIFIER_VALUE_MOVESPEED_BASE_OVERRIDE = 0xc,
	MODIFIER_VALUE_MOVESPEED_PERCENTAGE = 0xd,
	MODIFIER_VALUE_GRAVITY_SCALE = 0xe,
	MODIFIER_VALUE_MOUSE_SENSITIVITY_PERCENTAGE = 0xf,
	MODIFIER_VALUE_COUNT = 0x10,
	MODIFIER_VALUE_INVALID = 0xff,
};

// Alignment: 4
// Size: 0x11
enum class EModifierEvent : uint32_t
{
	MODIFIER_EVENT_PRE_DAMAGE_TAKEN_BROADCAST = 0x0,
	MODIFIER_EVENT_DAMAGE_TAKEN_BROADCAST = 0x1,
	MODIFIER_EVENT_HEALTH_TAKEN_BROADCAST = 0x2,
	MODIFIER_EVENT_PLAYER_DUMMY_BROADCAST = 0x3,
	MODIFIER_EVENT_BROADCAST_EVENT_COUNT = 0x4,
	MODIFIER_EVENT_MODIFIER_GAINED = 0x4,
	MODIFIER_EVENT_MODIFIER_LOST = 0x5,
	MODIFIER_EVENT_SCRIPTED_EVENT = 0x6,
	MODIFIER_EVENT_PRE_DAMAGE_TAKEN = 0x7,
	MODIFIER_EVENT_DAMAGE_TAKEN = 0x8,
	MODIFIER_EVENT_HEALTH_TAKEN = 0x9,
	MODIFIER_EVENT_PARENT_ACTIVATED = 0xa,
	MODIFIER_EVENT_ON_STUNNED = 0xb,
	MODIFIER_EVENT_ON_PLAYER_ACTIVE_WEAPON_CHANGED = 0xc,
	MODIFIER_EVENT_ON_PLAYER_USE = 0xd,
	MODIFIER_EVENT_COUNT = 0xe,
	MODIFIER_EVENT_INVALID = 0xff,
};

// Alignment: 4
// Size: 0x3
enum class EModifierScriptedEvent : uint32_t
{
	MODIFIER_SCRIPTED_EVENT_INVALID = 0x0,
	MODIFIER_SCRIPTED_EVENT_TEST = 0x1,
	MODIFIER_SCRIPTED_EVENT_COUNT = 0x2,
};

// Alignment: 4
// Size: 0xb
enum class EModifierState : uint32_t
{
	MODIFIER_STATE_MATERIAL_OVERRIDE = 0x0,
	MODIFIER_STATE_INVULNERABLE = 0x1,
	MODIFIER_STATE_BLIND = 0x2,
	MODIFIER_STATE_INVISIBLE = 0x3,
	MODIFIER_STATE_STUNNED = 0x4,
	MODIFIER_STATE_IMMUNE_TO_STUN = 0x5,
	MODIFIER_STATE_ROOTED = 0x6,
	MODIFIER_STATE_DISARMED = 0x7,
	MODIFIER_STATE_RAGDOLL_DAMAGE = 0x8,
	MODIFIER_STATE_COUNT = 0x9,
	MODIFIER_STATE_INVALID = 0xff,
};

// Alignment: 4
// Size: 0x5
enum class ModifierVariantType_t : uint32_t
{
	Variant_Null = 0x0,
	Variant_Float = 0x1,
	Variant_String = 0x2,
	Variant_Entity = 0x3,
	Variant_Vector = 0x4,
};

// Alignment: 4
// Size: 0x5
enum class EModifierPriority : uint32_t
{
	MODIFIER_PRIORITY_LOW = 0x0,
	MODIFIER_PRIORITY_NORMAL = 0x1,
	MODIFIER_PRIORITY_HIGH = 0x2,
	MODIFIER_PRIORITY_ULTRA = 0x3,
	MODIFIER_PRIORITY_SUPER_ULTRA = 0x4,
};

// Alignment: 4
// Size: 0x8
enum class eDryEraseMarkerType : uint32_t
{
	k_DRY_ERASE_MARKER_ROUND_TIP = 0x0,
	k_DRY_ERASE_MARKER_CHISEL_TIP = 0x1,
	k_DRY_ERASE_MARKER_CHALK = 0x2,
	k_DRY_ERASE_MARKER_DIRTY = 0x3,
	k_DRY_ERASE_MARKER_DRIED_OUT = 0x4,
	k_DRY_ERASE_MARKER_ERASER = 0x5,
	k_DRY_ERASE_MARKER_HAND_ERASER = 0x6,
	k_DRY_ERASE_MARKER_COUNT = 0x7,
};

// Alignment: 4
// Size: 0x4
enum class Steampal_TurretType_t : uint32_t
{
	STEAMPAL_TURRETTYPE_BADTURRET = 0x0,
	STEAMPAL_TURRETTYPE_GOODTURRET = 0x1,
	STEAMPAL_TURRETTYPE_ACTUALTURRET = 0x2,
	STEAMPAL_TURRETTYPE_INTROTURRET = 0x3,
};

// Alignment: 4
// Size: 0x3
enum class CSteamPal_Intro_Toilet__TestState_t : uint32_t
{
	TEST_UNTESTED = 0x0,
	TEST_PASS = 0x1,
	TEST_FAIL = 0x2,
};

// Alignment: 4
// Size: 0x8
enum class SteampalUltraToiletGunType_t : uint32_t
{
	ULTRA_GUN_MINIGUN = 0x0,
	ULTRA_GUN_AAGUN_L1 = 0x1,
	ULTRA_GUN_AAGUN_L2 = 0x2,
	ULTRA_GUN_AAGUN_R1 = 0x3,
	ULTRA_GUN_AAGUN_R2 = 0x4,
	ULTRA_GUN_SMG = 0x5,
	ULTRA_GUN_ROCKET = 0x6,
	ULTRA_GUN_TYPE_COUNT = 0x7,
};

// Alignment: 4
// Size: 0x8
enum class SteampalUltraToiletAttachedModel_t : uint32_t
{
	ULTRA_ATTACHMENT_AAGUN_L = 0x0,
	ULTRA_ATTACHMENT_AAGUN_R = 0x1,
	ULTRA_ATTACHMENT_MINIGUN = 0x2,
	ULTRA_ATTACHMENT_SMG = 0x3,
	ULTRA_ATTACHMENT_QUAD_ROCKET_L = 0x4,
	ULTRA_ATTACHMENT_QUAD_ROCKET_R = 0x5,
	ULTRA_ATTACHMENT_RADAR = 0x6,
	ULTRA_ATTACHED_MODEL_COUNT = 0x7,
};

// Alignment: 4
// Size: 0x3
enum class CSteamPalConveyorEntitySpawner__SpawnOrder_t : uint32_t
{
	SPAWN_ORDER_SEQUENTIAL = 0x0,
	SPAWN_ORDER_RANDOM = 0x1,
	SPAWN_ORDER_RANDOM_SHUFFLE = 0x2,
};

// Alignment: 4
// Size: 0xd
enum class DeskButtonGroups_t : uint32_t
{
	DESK_BUTTON_GROUP_BUMPERS = 0x0,
	DESK_BUTTON_GROUP_DPAD = 0x1,
	DESK_BUTTON_GROUP_MICS = 0x2,
	DESK_BUTTON_GROUP_PADDLES = 0x3,
	DESK_BUTTON_GROUP_STICK_L = 0x4,
	DESK_BUTTON_GROUP_STICK_R = 0x5,
	DESK_BUTTON_GROUP_TRACKPADS = 0x6,
	DESK_BUTTON_GROUP_TRACKBALLS = 0x7,
	DESK_BUTTON_GROUP_TRIGGER_L = 0x8,
	DESK_BUTTON_GROUP_TRIGGER_R = 0x9,
	DESK_BUTTON_GROUP_XYAB = 0xa,
	DESK_BUTTON_GROUP_TOUCHSCREEN = 0xb,
	DESK_BUTTON_GROUP_COUNT = 0xc,
};

// Alignment: 4
// Size: 0x3
enum class DeskDeployButtonGroups_t : uint32_t
{
	DESK_DEPLOY_BUTTON_GROUP_MICS = 0x0,
	DESK_DEPLOY_BUTTON_GROUP_STICKS = 0x1,
	DESK_DEPLOY_BUTTON_GROUP_COUNT = 0x2,
};

// Alignment: 4
// Size: 0xb
enum class DeskState_t : uint32_t
{
	DESK_STATE_NONE = 0x0,
	DESK_STATE_ALL_BUTTONS = 0x1,
	DESK_STATE_BUTTONS_EMPTY = 0x2,
	DESK_STATE_BUTTONS_DISCOVERY = 0x3,
	DESK_STATE_BUTTONS_TOILET_CALIBRATION = 0x4,
	DESK_STATE_BUTTONS_TURRET_INTRO = 0x5,
	DESK_STATE_BUTTONS_PRISON = 0x6,
	DESK_STATE_BUTTONS_SHOOTING_GALLERY = 0x7,
	DESK_STATE_BUTTONS_ASCENT = 0x8,
	DESK_STATE_BUTTONS_CAVE_OFFICE = 0x9,
	DESK_STATE_BUTTONS_TOILET_OUTRO = 0xa,
};

// Alignment: 4
// Size: 0x3
enum class SteamPalPaintType : uint32_t
{
	STEAMPAL_PAINT_BOUNCE = 0x0,
	STEAMPAL_PAINT_SPEED = 0x1,
	STEAMPAL_PAINT_POWER_TYPE_COUNT = 0x2,
};

// Alignment: 4
// Size: 0x6
enum class SteamPal_Projectile_Tag_Marker_Type_t : uint32_t
{
	STEAMPAL_PROJECTILE_TAG_MARKER_WORLD = 0x0,
	STEAMPAL_PROJECTILE_TAG_MARKER_NPC = 0x1,
	STEAMPAL_PROJECTILE_TAG_MARKER_PHYSICS_PROP = 0x2,
	STEAMPAL_PROJECTILE_TAG_MARKER_RAGDOLL = 0x3,
	STEAMPAL_PROJECTILE_TAG_MARKER_BASE_ANIMATING = 0x4,
	STEAMPAL_PROJECTILE_TAG_MARKER_TYPE_COUNT = 0x5,
};

// Alignment: 4
// Size: 0x6
enum class ApplianceWeaponState : uint32_t
{
	APPLIANCE_WEAPON_CLOSED = 0x0,
	APPLIANCE_WEAPON_OPENING = 0x1,
	APPLIANCE_WEAPON_READY_TO_ATTACK = 0x2,
	APPLIANCE_WEAPON_ATTACKING = 0x3,
	APPLIANCE_WEAPON_STUNNED = 0x4,
	APPLIANCE_WEAPON_CLOSING = 0x5,
};

// Alignment: 4
// Size: 0x9
enum class AttachType_t : uint32_t
{
	ATTACH_TYPE_NONE = 0xffffffffffffffff,
	ATTACH_TYPE_RIGID = 0x0,
	ATTACH_TYPE_SOFT = 0x1,
	ATTACH_TYPE_LOOSE = 0x2,
	ATTACH_TYPE_HOVER = 0x3,
	ATTACH_TYPE_RAGDOLL = 0x4,
	ATTACH_TYPE_RAGDOLL_LARGE_CREATURE = 0x5,
	ATTACH_TYPE_RAGDOLL_LARGE = 0x6,
	ATTACH_TYPE_LOCKED = 0x7,
};

// Alignment: 4
// Size: 0x13
enum class NavAttributeEnum : uint32_t
{
	NAV_MESH_AVOID = 0x80,
	NAV_MESH_STAIRS = 0x1000,
	NAV_MESH_NON_ZUP = 0x8000,
	NAV_MESH_SHORT_HEIGHT = 0x10000,
	NAV_MESH_CROUCH = 0x10000,
	NAV_MESH_JUMP = 0x2,
	NAV_MESH_PRECISE = 0x4,
	NAV_MESH_NO_JUMP = 0x8,
	NAV_MESH_STOP = 0x10,
	NAV_MESH_RUN = 0x20,
	NAV_MESH_WALK = 0x40,
	NAV_MESH_TRANSIENT = 0x100,
	NAV_MESH_DONT_HIDE = 0x200,
	NAV_MESH_STAND = 0x400,
	NAV_MESH_NO_HOSTAGES = 0x800,
	NAV_MESH_NO_MERGE = 0x2000,
	NAV_MESH_OBSTACLE_TOP = 0x4000,
	NAV_ATTR_FIRST_GAME_INDEX = 0x13,
	NAV_ATTR_LAST_INDEX = 0x1f,
};

// Alignment: 4
// Size: 0x5
enum class NavDirType : uint32_t
{
	NORTH = 0x0,
	EAST = 0x1,
	SOUTH = 0x2,
	WEST = 0x3,
	NUM_DIRECTIONS = 0x4,
};

struct CSkillFloat;
struct CNetworkVarChainer;
struct fogplayerparams_t;
struct audioparams_t;
struct CRangeInt;
struct CRangeFloat;
struct CNetworkedSequenceOperation;
struct CBaseAnimatingEasingFloat_t;
struct ModelConfigHandle_t;
struct CEntityInstance;
struct CGameSceneNode;
struct CGameSceneNodeHandle;
struct CNetworkOriginCellCoordQuantizedVector;
struct CSkeletonInstance;
struct HSequence;
struct CModelState;
struct CNetworkedIKContext;
struct ResponseFollowup;
struct ResponseParams;
struct CRR_Response;
struct CBaseFlex;
struct CResponseCriteriaSet;
struct CSoundEnvelope;
struct CCopyRecipientFilter;
struct CFourWheelServerVehicle;
struct vehicle_controlparams_t;
struct VelocitySampler;
struct SimpleConstraintSoundProfile;
struct ParticleIndex_t;
struct AttachmentHandle_t;
struct VPhysicsCollisionAttribute_t;
struct CEntityIOOutput;
struct fogparams_t;
struct CBaseAnimatingController;
struct AmmoIndex_t;
struct CTakeDamageInfo;
struct CTakeDamageResult;
struct CBaseAnimating;
struct ViewLockData_t;
struct CFootstepTableHandle;
struct CSkillInt;
struct CAI_BehaviorBase;
struct CAI_DefaultNPC;
struct AIScheduleState_t;
struct CSimTimer;
struct CAI_MoveMonitor;
struct AI_FreePassParams_t;
struct ChangeAccessorFieldPathIndex_t;
struct ConditionId_t;
struct AbilityLOSResult_t;
struct CAI_ScheduleBits;
struct AWS_AbilityUsageData_t;
struct NPCAbilityTarget_t;
struct BodyLocationListVData_t;
struct CSimpleSimTimer;
struct CRandStopwatch;
struct CRandSimTimer;
struct AI_StandoffParams_t;
struct CSkillDamage;
struct CModifierLevelFloat;
struct ModifierSerialNumber_t;
struct CModifierHandleBase;
struct ModifierQueuedRefreshHandle_t;
struct ModifierRuntimeHandle_t;
struct ModifierPropRuntimeHandle_t;
struct CSteamPal_Turret_Wing_t;
struct CSteamPal_Ultra_Toilet_Gun_VData_t;
struct CEntityIdentity;
struct CScriptComponent;
struct CAnimGraphNetworkedVariables;
struct CSequenceTransitioner2;
struct CBaseAnimatingOverlayController;
struct CBodyComponent;
struct CNetworkTransmitComponent;
struct CNetworkVelocityVector;
struct CCollisionProperty;
struct CModifierProperty;
struct CountdownTimer;
struct sky3dparams_t;
struct CSkyCamera;
struct CBaseEntity;
struct vehiclesounds_t;
struct ragdoll_t;
struct LastIncomingHit_t;
struct HintNodeData;
struct HullFlags_t;
struct CAI_ProxTester;
struct HitscanGatherData_t;
struct ModifierTrackedParticle_t;
struct ModifierRenderAttribute_t;
struct ModifierTrackedGraphParameter_t;
struct ModifierTrackedSound_t;
struct ModifierTrackedBodyGroup_t;
struct CSteamPalGameRules;
struct CPointCamera;
struct CRenderComponent;
struct CGlowProperty;
struct CNetworkViewOffsetVector;
struct CEnvWindShared;
struct CPhysicsShake;
struct hudtextparms_t;
struct CPathKeyFrame;
struct CConstantForceController;
struct CMotorController;
struct ConstraintSoundInfo;
struct constraint_hingeparams_t;
struct CPhysicsNPCSolver;
struct dynpitchvol_t;
struct locksound_t;
struct CPathTrack;
struct CBuoyancyHelper;
struct ViewSmoothingData_t;
struct CLightComponent;
struct CHitboxComponent;
struct PhysicsRagdollPose_t;
struct IChoreoServices;
struct CBaseAnimatingEasings_t;
struct CFuncTrackTrain;
struct CSprite;
struct CThrustController;
struct CFourWheelVehiclePhysics;
struct shard_model_desc_t;
struct CAI_Expresser;
struct CAI_BehaviorHost;
struct CAI_EnemyServices;
struct CAI_AnimGraphServices;
struct CAI_Scheduler;
struct CAI_DynamicInteractions;
struct CAI_StanceServices;
struct CAI_AbilityServices;
struct CFlightComponent;
struct CAI_FreePass;
struct CPlayer_WeaponServices;
struct CPlayer_ItemServices;
struct CPlayer_VehicleServices;
struct CPlayer_AutoaimServices;
struct CPlayer_ObserverServices;
struct CPlayer_WaterServices;
struct CPlayer_UseServices;
struct CPlayer_FlashlightServices;
struct CPlayer_CameraServices;
struct CPlayer_MovementServices;

// Alignment: 1
// Size: 0x1a0
class CNetworkTransmitComponent
{
public:
	uint8_t m_nTransmitStateOwnedCounter; // 0x16c	
	static int32_t &Get_s_nWatchTransmitEntity(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNetworkTransmitComponent")->m_static_fields[0]->m_instance);};
	static bool &Get_s_bUseNetworkVars(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNetworkTransmitComponent")->m_static_fields[1]->m_instance);};
	static bool &Get_s_bNetworkVarPerFieldTracking(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNetworkTransmitComponent")->m_static_fields[2]->m_instance);};
	static bool &Get_s_bNetworkVarValidate(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNetworkTransmitComponent")->m_static_fields[3]->m_instance);};
	static bool &Get_s_bUsingPVSConvars(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNetworkTransmitComponent")->m_static_fields[4]->m_instance);};
};

// Alignment: 0
// Size: 0x1
class CPhysicsComponent
{
public:
	uint8_t __pad0000[0x1]; 	// @note: autoaligned
};

// Alignment: 1
// Size: 0x20
class CBuoyancyHelper
{
public:
	float m_flFluidDensity; // 0x18	
};

// Alignment: 1
// Size: 0x10
class CSkillFloat
{
public:
	float m_pValue[4]; // 0x0	
};

// Alignment: 1
// Size: 0x10
class CSkillInt
{
public:
	int32_t m_pValue[4]; // 0x0	
};

// Alignment: 1
// Size: 0x10
class CModifierLevelFloat
{
public:
	float m_pValue[4]; // 0x0	
};

// Alignment: 1
// Size: 0x10
class CModifierLevelInt
{
public:
	int32_t m_pValue[4]; // 0x0	
};

// Alignment: 2
// Size: 0x14
class CSkillDamage
{
public:
	// MPropertyDescription "Damage Dealt (in the case of NPC vs NPC damage, medium skill is used)"
	CSkillFloat m_flDamage; // 0x0	
	// MPropertyDescription "If specified, the damage used to compute physics forces. Otherwise normal damage is used."
	float m_flPhysicsForceDamage; // 0x10	
};

// Alignment: 2
// Size: 0xb8
class CScriptUniformRandomStream
{
public:
	HSCRIPT m_hScriptScope; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0010[0xa0]; 	// 0x10
public:
	int32_t m_nInitialSeed; // 0xb0	
	static CUtlVector< CScriptUniformRandomStream* > &Get_sm_UniformStreams(){return *reinterpret_cast<CUtlVector< CScriptUniformRandomStream* >*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CScriptUniformRandomStream")->m_static_fields[0]->m_instance);};
};

// Alignment: 12
// Size: 0x50
struct CommandToolCommand_t
{
public:
	bool m_bEnabled; // 0x0	
	bool m_bOpened; // 0x1	
private:
	[[maybe_unused]] uint8_t __pad0002[0x2]; 	// 0x2
public:
	uint32_t m_InternalId; // 0x4	
	CUtlString m_ShortName; // 0x8	
	CommandExecMode_t m_ExecMode; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0014[0x4]; 	// 0x14
public:
	CUtlString m_SpawnGroup; // 0x18	
	float m_PeriodicExecDelay; // 0x20	
	CommandEntitySpecType_t m_SpecType; // 0x24	
	CUtlString m_EntitySpec; // 0x28	
	CUtlString m_Commands; // 0x30	
	DebugOverlayBits_t m_SetDebugBits; // 0x38	
	DebugOverlayBits_t m_ClearDebugBits; // 0x40	
};

// Alignment: 1
// Size: 0x30
class CPlayerComponent
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x8	
};

// Alignment: 1
// Size: 0x30
class CPlayerControllerComponent
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x8	
};

// Alignment: 9
// Size: 0xc0
struct PlayerResourceData_t
{
public:
	// MNetworkEnable
	// MNetworkEncoder
	uint64_t m_iPlayerSteamID; // 0x20	
	// MNetworkEnable
	// MNetworkChangeCallback "OnPlayerNameChanged"
	char m_iszPlayerName[128]; // 0x28	
	// MNetworkEnable
	CHandle< CBasePlayerController > m_hPlayerController; // 0xa8	
	// MNetworkEnable
	CHandle< CBasePlayer > m_hPawn; // 0xac	
	// MNetworkEnable
	bool m_bIsValid; // 0xb0	
	// MNetworkEnable
	bool m_bFakeClient; // 0xb1	
	// MNetworkEnable
	bool m_bIsBot; // 0xb2	
private:
	[[maybe_unused]] uint8_t __pad00b3[0x1]; 	// 0xb3
public:
	// MNetworkEnable
	int32_t m_nConnectionState; // 0xb4	
	// MNetworkEnable
	int32_t m_iTeam; // 0xb8	
};

// Alignment: 0
// Size: 0x30
class CPlayer_AutoaimServices : public CPlayerComponent
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x78
struct audioparams_t
{
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector localSound[8]; // 0x8	
	// MNetworkEnable
	int32_t soundscapeIndex; // 0x68	
	// MNetworkEnable
	uint8_t localBits; // 0x6c	
private:
	[[maybe_unused]] uint8_t __pad006d[0x3]; 	// 0x6d
public:
	// MNetworkEnable
	int32_t soundscapeEntityListIndex; // 0x70	
};

// Alignment: 14
// Size: 0x40
struct fogplayerparams_t
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "PlayerFogController"
	CHandle< CFogController > m_hCtrl; // 0x8	
	float m_flTransitionTime; // 0xc	
	Color m_OldColor; // 0x10	
	float m_flOldStart; // 0x14	
	float m_flOldEnd; // 0x18	
	float m_flOldMaxDensity; // 0x1c	
	float m_flOldHDRColorScale; // 0x20	
	float m_flOldFarZ; // 0x24	
	Color m_NewColor; // 0x28	
	float m_flNewStart; // 0x2c	
	float m_flNewEnd; // 0x30	
	float m_flNewMaxDensity; // 0x34	
	float m_flNewHDRColorScale; // 0x38	
	float m_flNewFarZ; // 0x3c	
};

// Alignment: 0
// Size: 0x30
class CPlayer_FlashlightServices : public CPlayerComponent
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x30
class CPlayer_ItemServices : public CPlayerComponent
{
public:
	// @note: no members available
};

// Alignment: 16
// Size: 0x90
class CPlayer_MovementServices : public CPlayerComponent
{
public:
	float m_flStepSoundTime; // 0x30	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	// MNetworkBitCount "17"
	// MNetworkMinValue "-4096"
	// MNetworkMaxValue "4096"
	float m_flFallVelocity; // 0x34	
	// MNetworkEnable
	// MNetworkBitCount "12"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "2048"
	// MNetworkEncodeFlags
	float m_flMaxspeed; // 0x38	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	bool m_bDucked; // 0x3c	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	bool m_bDucking; // 0x3d	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	bool m_bInDuckJump; // 0x3e	
private:
	[[maybe_unused]] uint8_t __pad003f[0x1]; 	// 0x3f
public:
	Vector m_groundNormal; // 0x40	
	float m_flSurfaceFriction; // 0x4c	
	CUtlStringToken m_surfaceProps; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0054[0xc]; 	// 0x54
public:
	int32_t m_nStepside; // 0x60	
	Vector m_vecPreviouslyPredictedOrigin; // 0x64	
	float m_flForwardMove; // 0x70	
	float m_flSideMove; // 0x74	
	float m_flUpMove; // 0x78	
	int32_t m_iTargetVolume; // 0x7c	
	Vector m_vecSmoothedVelocity; // 0x80	
};

// Alignment: 4
// Size: 0x40
class CPlayer_ObserverServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnObserverModeChanged"
	uint8_t m_iObserverMode; // 0x30	
private:
	[[maybe_unused]] uint8_t __pad0031[0x3]; 	// 0x31
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnObserverTargetChanged"
	CHandle< CBaseEntity > m_hObserverTarget; // 0x34	
	ObserverMode_t m_iObserverLastMode; // 0x38	
	bool m_bForcedObserverMode; // 0x3c	
};

// Alignment: 1
// Size: 0x38
class CPlayer_UseServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hUseEntity; // 0x30	
};

// Alignment: 6
// Size: 0x58
class CPlayer_VehicleServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hVehicle; // 0x30	
	int32_t m_iVehicleAnalogBias; // 0x34	
	Vector m_vecVehicleViewOrigin; // 0x38	
	QAngle m_vecVehicleViewAngles; // 0x44	
	int32_t m_nVehicleViewSavedFrame; // 0x50	
	float m_flVehicleViewFOV; // 0x54	
};

// Alignment: 8
// Size: 0x70
class CPlayer_WaterServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	float m_AirFinishedTime; // 0x30	
	float m_flWaterJumpTime; // 0x34	
	Vector m_vecWaterJumpVel; // 0x38	
	float m_flSwimSoundTime; // 0x44	
	bool m_bPlayerUnderwater; // 0x48	
private:
	[[maybe_unused]] uint8_t __pad0049[0x7]; 	// 0x49
public:
	CUtlVector< CHandle< CBaseEntity > > m_hWaterVols; // 0x50	
	float m_NextDrownDamageTime; // 0x68	
	int32_t m_nDrownDmgRate; // 0x6c	
};

// Alignment: 5
// Size: 0x98
class CPlayer_WeaponServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBasePlayerWeapon > > m_hMyWeapons; // 0x30	
	// MNetworkEnable
	CHandle< CBasePlayerWeapon > m_hActiveWeapon; // 0x48	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	CHandle< CBasePlayerWeapon > m_hLastWeapon; // 0x4c	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	uint16_t m_iAmmo[32]; // 0x50	
	bool m_bPreventWeaponPickup; // 0x90	
};

// Alignment: 1
// Size: 0x8
class CRangeFloat
{
public:
	float m_pValue[2]; // 0x0	
};

// Alignment: 8
// Size: 0x40
class CNetworkedSequenceOperation
{
public:
	// MNetworkEnable
	// MNetworkSerializer "minusone"
	// MNetworkChangeCallback "sequenceOpSequenceChanged"
	// MNetworkPriority "32"
	HSequence m_hSequence; // 0x8	
	// MNetworkEnable
	// MNetworkBitCount "15"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkEncodeFlags
	// MNetworkPriority "32"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkUserGroup "m_flCycle"
	float m_flPrevCycle; // 0xc	
	// MNetworkEnable
	// MNetworkBitCount "15"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkEncodeFlags
	// MNetworkPriority "32"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkUserGroup "m_flCycle"
	// MNetworkChangeCallback "sequenceOpCycleChanged"
	float m_flCycle; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0014[0x4]; 	// 0x14
public:
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkEncodeFlags
	CNetworkedQuantizedFloat m_flWeight; // 0x18	
	// MNetworkDisable
	bool m_bSequenceChangeNetworked; // 0x30	
	// MNetworkDisable
	bool m_bDiscontinuity; // 0x31	
private:
	[[maybe_unused]] uint8_t __pad0032[0x2]; 	// 0x32
public:
	// MNetworkDisable
	float m_flPrevCycleFromDiscontinuity; // 0x34	
	// MNetworkDisable
	float m_flPrevCycleForAnimEventDetection; // 0x38	
};

// Alignment: 2
// Size: 0x30
struct CBaseAnimatingEasingFloat_t
{
public:
	// MNetworkEnable
	CUtlString m_GraphParameterName; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0010[0x18]; 	// 0x10
public:
	// MNetworkEnable
	float m_flGoal; // 0x28	
};

// Alignment: 1
// Size: 0x38
struct CBaseAnimatingEasings_t
{
public:
	// MNetworkEnable
	CBaseAnimatingEasingFloat_t m_IKMasterBlendAmountEasing; // 0x8	
};

// Alignment: 2
// Size: 0x28
struct PhysicsRagdollPose_t
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnTransformChanged"
	CNetworkUtlVectorBase< CTransform > m_Transforms; // 0x8	
	bool m_bDirty; // 0x20	
};

// Alignment: 1
// Size: 0x4
struct ModelConfigHandle_t
{
public:
	uint32_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 4
// Size: 0x58
struct ActiveModelConfig_t
{
public:
	// MNetworkEnable
	ModelConfigHandle_t m_Handle; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad001c[0x4]; 	// 0x1c
public:
	// MNetworkEnable
	CUtlSymbolLarge m_Name; // 0x20	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseModelEntity > > m_AssociatedEntities; // 0x28	
	// MNetworkEnable
	CNetworkUtlVectorBase< CUtlSymbolLarge > m_AssociatedEntityNames; // 0x40	
};

// Alignment: 7
// Size: 0x68
class CNetworkOriginCellCoordQuantizedVector
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "cellx"
	uint16_t m_cellX; // 0x18	
	// MNetworkEnable
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "celly"
	uint16_t m_cellY; // 0x1a	
	// MNetworkEnable
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "cellz"
	uint16_t m_cellZ; // 0x1c	
	// MNetworkEnable
	uint16_t m_nOutsideWorld; // 0x1e	
	// MNetworkBitCount "15"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1024"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "posx"
	CNetworkedQuantizedFloat m_vecX; // 0x20	
	// MNetworkBitCount "15"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1024"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "posy"
	CNetworkedQuantizedFloat m_vecY; // 0x38	
	// MNetworkBitCount "15"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1024"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "OnCellChanged"
	// MNetworkPriority "31"
	// MNetworkSerializer "posz"
	CNetworkedQuantizedFloat m_vecZ; // 0x50	
};

// Alignment: 3
// Size: 0x60
class CNetworkOriginQuantizedVector
{
public:
	// MNetworkBitCount "19"
	// MNetworkMinValue "-16384"
	// MNetworkMaxValue "16384"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkOriginQuantizedVector"
	CNetworkedQuantizedFloat m_vecX; // 0x18	
	// MNetworkBitCount "19"
	// MNetworkMinValue "-16384"
	// MNetworkMaxValue "16384"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkOriginQuantizedVector"
	CNetworkedQuantizedFloat m_vecY; // 0x30	
	// MNetworkBitCount "19"
	// MNetworkMinValue "-16384"
	// MNetworkMaxValue "16384"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkOriginQuantizedVector"
	CNetworkedQuantizedFloat m_vecZ; // 0x48	
};

// Alignment: 3
// Size: 0x60
class CNetworkVelocityVector
{
public:
	// MNetworkBitCount "18"
	// MNetworkMinValue "-4096"
	// MNetworkMaxValue "4096"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkVelocityVector"
	CNetworkedQuantizedFloat m_vecX; // 0x18	
	// MNetworkBitCount "18"
	// MNetworkMinValue "-4096"
	// MNetworkMaxValue "4096"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkVelocityVector"
	CNetworkedQuantizedFloat m_vecY; // 0x30	
	// MNetworkBitCount "18"
	// MNetworkMinValue "-4096"
	// MNetworkMaxValue "4096"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkVelocityVector"
	CNetworkedQuantizedFloat m_vecZ; // 0x48	
};

// Alignment: 3
// Size: 0x60
class CNetworkViewOffsetVector
{
public:
	// MNetworkBitCount "10"
	// MNetworkMinValue "-64"
	// MNetworkMaxValue "64"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkViewOffsetVector"
	CNetworkedQuantizedFloat m_vecX; // 0x18	
	// MNetworkBitCount "10"
	// MNetworkMinValue "-64"
	// MNetworkMaxValue "64"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkViewOffsetVector"
	CNetworkedQuantizedFloat m_vecY; // 0x30	
	// MNetworkBitCount "20"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "128"
	// MNetworkEncodeFlags
	// MNetworkChangeCallback "CNetworkViewOffsetVector"
	CNetworkedQuantizedFloat m_vecZ; // 0x48	
};

// Alignment: 2
// Size: 0x10
class CGameSceneNodeHandle
{
public:
	// MNetworkEnable
	CEntityHandle m_hOwner; // 0x8	
	// MNetworkEnable
	CUtlStringToken m_name; // 0xc	
};

// Alignment: 33
// Size: 0x160
class CGameSceneNode
{
public:
	// MNetworkDisable
	CTransform m_nodeToWorld; // 0x10	
	// MNetworkDisable
	CEntityInstance* m_pOwner; // 0x30	
	// MNetworkDisable
	CGameSceneNode* m_pParent; // 0x38	
	// MNetworkDisable
	CGameSceneNode* m_pChild; // 0x40	
	// MNetworkDisable
	CGameSceneNode* m_pNextSibling; // 0x48	
private:
	[[maybe_unused]] uint8_t __pad0050[0x20]; 	// 0x50
public:
	// MNetworkEnable
	// MNetworkSerializer "gameSceneNode"
	// MNetworkChangeCallback "gameSceneNodeHierarchyParentChanged"
	// MNetworkPriority "32"
	// MNetworkVarEmbeddedFieldOffsetDelta "8"
	CGameSceneNodeHandle m_hParent; // 0x70	
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkUserGroup "Origin"
	// MNetworkChangeCallback "gameSceneNodeLocalOriginChanged"
	CNetworkOriginCellCoordQuantizedVector m_vecOrigin; // 0x80	
private:
	[[maybe_unused]] uint8_t __pad00e8[0x8]; 	// 0xe8
public:
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkSerializer "gameSceneNodeStepSimulationAnglesSerializer"
	// MNetworkChangeCallback "gameSceneNodeLocalAnglesChanged"
	QAngle m_angRotation; // 0xf0	
	// MNetworkEnable
	// MNetworkChangeCallback "gameSceneNodeLocalScaleChanged"
	// MNetworkPriority "32"
	float m_flScale; // 0xfc	
	// MNetworkDisable
	Vector m_vecAbsOrigin; // 0x100	
	// MNetworkDisable
	QAngle m_angAbsRotation; // 0x10c	
	// MNetworkDisable
	float m_flAbsScale; // 0x118	
	// MNetworkDisable
	int16_t m_nParentAttachmentOrBone; // 0x11c	
	// MNetworkDisable
	bool m_bDebugAbsOriginChanges; // 0x11e	
	// MNetworkDisable
	bool m_bDormant; // 0x11f	
	// MNetworkDisable
	bool m_bForceParentToBeNetworked; // 0x120	
	struct 
	{
		// MNetworkDisable
		uint8_t m_bDirtyHierarchy: 1; 		
		// MNetworkDisable
		uint8_t m_bDirtyBoneMergeInfo: 1; 		
		// MNetworkDisable
		uint8_t m_bNetworkedPositionChanged: 1; 		
		// MNetworkDisable
		uint8_t m_bNetworkedAnglesChanged: 1; 		
		// MNetworkDisable
		uint8_t m_bNetworkedScaleChanged: 1; 		
		// MNetworkDisable
		uint8_t m_bWillBeCallingPostDataUpdate: 1; 		
		// MNetworkDisable
		uint8_t m_bNotifyBoneTransformsChanged: 1; 		
		// MNetworkDisable
		uint8_t m_bBoneMergeFlex: 1; 		
		// MNetworkDisable
		uint8_t m_nLatchAbsOrigin: 2; 		
		// MNetworkDisable
		uint8_t m_bDirtyBoneMergeBoneToRoot: 1; 		
		uint16_t __pad0: 13;
	}; // 24 bits
	// MNetworkDisable
	uint8_t m_nHierarchicalDepth; // 0x123	
	// MNetworkDisable
	uint8_t m_nHierarchyType; // 0x124	
	// MNetworkDisable
	uint8_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount; // 0x125	
private:
	[[maybe_unused]] uint8_t __pad0126[0x2]; 	// 0x126
public:
	// MNetworkEnable
	CUtlStringToken m_name; // 0x128	
private:
	[[maybe_unused]] uint8_t __pad012c[0x14]; 	// 0x12c
public:
	// MNetworkEnable
	// MNetworkChangeCallback "gameSceneNodeHierarchyAttachmentChanged"
	CUtlStringToken m_hierarchyAttachName; // 0x140	
	// MNetworkDisable
	float m_flZOffset; // 0x144	
	// MNetworkDisable
	Vector m_vRenderOrigin; // 0x148	
};

// Alignment: 0
// Size: 0x8
class IChoreoServices
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 10
// Size: 0x60
class JiggleData
{
public:
	int32_t bone; // 0x0	
	int32_t id; // 0x4	
	float lastUpdate; // 0x8	
	Vector basePos; // 0xc	
	Vector baseLastPos; // 0x18	
	Vector baseVel; // 0x24	
	Vector baseAccel; // 0x30	
	Vector tipPos; // 0x3c	
	Vector tipVel; // 0x48	
	Vector tipAccel; // 0x54	
};

// Alignment: 0
// Size: 0x20
class CJiggleBones
{
public:
	uint8_t __pad0000[0x20]; 	// @note: autoaligned
};

// Alignment: 1
// Size: 0x10
class CSkeletonAnimationController
{
public:
	// MNetworkDisable
	CSkeletonInstance* m_pSkeletonInstance; // 0x8	
};

// Alignment: 15
// Size: 0xb8
class CAnimationLayer
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "animationLayerOpChanged"
	CNetworkedSequenceOperation m_op; // 0x20	
	// MNetworkEnable
	// MNetworkChangeCallback "animationLayerOrderChanged"
	int32_t m_nOrder; // 0x60	
private:
	[[maybe_unused]] uint8_t __pad0064[0x4]; 	// 0x64
public:
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "-4"
	// MNetworkMaxValue "12"
	// MNetworkEncodeFlags
	// MNetworkSendProxyRecipientsFilter
	CNetworkedQuantizedFloat m_flPlaybackRate; // 0x68	
	// MNetworkEnable
	// MNetworkSendProxyRecipientsFilter
	bool m_bLooping; // 0x80	
private:
	[[maybe_unused]] uint8_t __pad0081[0x3]; 	// 0x81
public:
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkChangeCallback "animationLayerCycleReset"
	// MNetworkSendProxyRecipientsFilter
	int32_t m_nNewSequenceParity; // 0x84	
	// MNetworkDisable
	int32_t m_nFlags; // 0x88	
	// MNetworkDisable
	bool m_bSequenceFinished; // 0x8c	
private:
	[[maybe_unused]] uint8_t __pad008d[0x3]; 	// 0x8d
public:
	// MNetworkDisable
	float m_flKillRate; // 0x90	
	// MNetworkDisable
	float m_flKillDelay; // 0x94	
	// MNetworkDisable
	float m_flLayerAnimtime; // 0x98	
	// MNetworkDisable
	float m_flLayerFadeOuttime; // 0x9c	
	// MNetworkDisable
	int32_t m_nActivity; // 0xa0	
	// MNetworkDisable
	int32_t m_nPriority; // 0xa4	
	// MNetworkDisable
	float m_flLastEventCycle; // 0xa8	
	// MNetworkDisable
	float m_flLastAccess; // 0xac	
};

// Alignment: 6
// Size: 0x50
class CNetworkedIKProceduralTargetContext
{
public:
	// MNetworkEnable
	int32_t m_nChainIndex; // 0x20	
	// MNetworkEnable
	int32_t m_nRuleIndex; // 0x24	
	// MNetworkEnable
	Vector m_vTargetPosition; // 0x28	
	// MNetworkEnable
	Quaternion m_qTargetOrientation; // 0x34	
	// MNetworkEnable
	// MNetworkPriority "48"
	float m_flWeight; // 0x44	
	// MNetworkEnable
	bool m_bIsValid; // 0x48	
};

// Alignment: 1
// Size: 0x50
class CNetworkedIKContext
{
public:
	// MNetworkEnable
	CUtlVectorEmbeddedNetworkVar< CNetworkedIKProceduralTargetContext > m_ProceduralTargetContexts; // 0x8	
};

// Alignment: 8
// Size: 0x240
class CModelState
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "skeletonModelChanged"
	CStrongHandle< InfoForResourceTypeCModel > m_hModel; // 0xa0	
	// MNetworkDisable
	CUtlSymbolLarge m_ModelName; // 0xa8	
private:
	[[maybe_unused]] uint8_t __pad00b0[0x38]; 	// 0xb0
public:
	// MNetworkEnable
	bool m_bClientClothCreationSuppressed; // 0xe8	
private:
	[[maybe_unused]] uint8_t __pad00e9[0x9f]; 	// 0xe9
public:
	// MNetworkEnable
	// MNetworkChangeCallback "skeletonMeshGroupMaskChanged"
	uint64_t m_MeshGroupMask; // 0x188	
private:
	[[maybe_unused]] uint8_t __pad0190[0x9a]; 	// 0x190
public:
	// MNetworkEnable
	// MNetworkChangeCallback "skeletonMotionTypeChanged"
	int8_t m_nIdealMotionType; // 0x22a	
	// MNetworkDisable
	int8_t m_nForceLOD; // 0x22b	
	// MNetworkDisable
	bool m_bIsJiggleBonesEnabled; // 0x22c	
	// MNetworkDisable
	int8_t m_nClothUpdateFlags; // 0x22d	
};

// Alignment: 12
// Size: 0x4c0
class CSkeletonInstance : public CGameSceneNode
{
public:
	// MNetworkEnable
	CModelState m_modelState; // 0x170	
	// MNetworkEnable
	// MNetworkChangeCallback "skeletonRenderingEnableChanged"
	bool m_bIsRenderingEnabled; // 0x3b0	
	// MNetworkEnable
	bool m_bIsAnimationEnabled; // 0x3b1	
	// MNetworkEnable
	bool m_bUseParentRenderBounds; // 0x3b2	
	// MNetworkDisable
	bool m_bEnableIK; // 0x3b3	
	// MNetworkDisable
	bool m_bDisableSolidCollisionsForHierarchy; // 0x3b4	
	struct 
	{
		// MNetworkDisable
		uint8_t m_bDirtyMotionType: 1; 		
		// MNetworkDisable
		uint8_t m_bIsGeneratingLatchedParentSpaceState: 1; 		
		uint32_t __pad1: 30;
	}; // 32 bits
	// MNetworkEnable
	// MNetworkChangeCallback "skeletonMaterialGroupChanged"
	CUtlStringToken m_materialGroup; // 0x3b8	
	// MNetworkEnable
	uint8_t m_nHitboxSet; // 0x3bc	
private:
	[[maybe_unused]] uint8_t __pad03bd[0x4b]; 	// 0x3bd
public:
	// MNetworkEnable
	float m_flIkMasterBlendValueCache; // 0x408	
private:
	[[maybe_unused]] uint8_t __pad040c[0x4]; 	// 0x40c
public:
	// MNetworkEnable
	CNetworkedIKContext m_NetworkedIKContext; // 0x410	
};

// Alignment: 1
// Size: 0x10
class IntervalTimer
{
public:
	// MNetworkEnable
	float m_timestamp; // 0x8	
};

// Alignment: 2
// Size: 0x10
class CountdownTimer
{
public:
	// MNetworkEnable
	float m_duration; // 0x8	
	// MNetworkEnable
	float m_timestamp; // 0xc	
};

// Alignment: 7
// Size: 0x268
class CTimeline : public IntervalTimer
{
public:
	// MNetworkEnable
	float m_flValues[64]; // 0x10	
	// MNetworkEnable
	int32_t m_nValueCounts[64]; // 0x110	
	// MNetworkEnable
	int32_t m_nBucketCount; // 0x210	
	// MNetworkEnable
	float m_flInterval; // 0x214	
	// MNetworkEnable
	float m_flFinalValue; // 0x218	
	// MNetworkEnable
	TimelineCompression_t m_nCompressionType; // 0x21c	
	// MNetworkEnable
	bool m_bStopped; // 0x220	
};

// Alignment: 25
// Size: 0x260
class CAnimGraphNetworkedVariables
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_BoolVariables"
	CNetworkUtlVectorBase< bool > m_NetBoolVariables; // 0x8	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_ByteVariables"
	CNetworkUtlVectorBase< uint8 > m_NetByteVariables; // 0x20	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_UInt16Variables"
	CNetworkUtlVectorBase< uint16 > m_NetUInt16Variables; // 0x38	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_IntVariables"
	CNetworkUtlVectorBase< int32 > m_NetIntVariables; // 0x50	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_UInt32Variables"
	CNetworkUtlVectorBase< uint32 > m_NetUInt32Variables; // 0x68	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_FloatVariables"
	CNetworkUtlVectorBase< float32 > m_NetFloatVariables; // 0x80	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_VectorVariables"
	CNetworkUtlVectorBase< Vector > m_NetVectorVariables; // 0x98	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_QuaternionVariables"
	CNetworkUtlVectorBase< Quaternion > m_NetQuaternionVariables; // 0xb0	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredBoolVariables"
	CNetworkUtlVectorBase< bool > m_PredNetBoolVariables; // 0xc8	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredByteVariables"
	CNetworkUtlVectorBase< uint8 > m_PredNetByteVariables; // 0xe0	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredUInt16Variables"
	CNetworkUtlVectorBase< uint16 > m_PredNetUInt16Variables; // 0xf8	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredIntVariables"
	CNetworkUtlVectorBase< int32 > m_PredNetIntVariables; // 0x110	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredUInt32Variables"
	CNetworkUtlVectorBase< uint32 > m_PredNetUInt32Variables; // 0x128	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredFloatVariables"
	CNetworkUtlVectorBase< float32 > m_PredNetFloatVariables; // 0x140	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredVectorVariables"
	CNetworkUtlVectorBase< Vector > m_PredNetVectorVariables; // 0x158	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_PredQuaternionVariables"
	CNetworkUtlVectorBase< Quaternion > m_PredNetQuaternionVariables; // 0x170	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetBoolVariables"
	CNetworkUtlVectorBase< bool > m_LocalPredNetBoolVariables; // 0x188	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetByteVariables"
	CNetworkUtlVectorBase< uint8 > m_LocalPredNetByteVariables; // 0x1a0	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetUInt16Variables"
	CNetworkUtlVectorBase< uint16 > m_LocalPredNetUInt16Variables; // 0x1b8	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetIntVariables"
	CNetworkUtlVectorBase< int32 > m_LocalPredNetIntVariables; // 0x1d0	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetUInt32Variables"
	CNetworkUtlVectorBase< uint32 > m_LocalPredNetUInt32Variables; // 0x1e8	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetFloatVariables"
	CNetworkUtlVectorBase< float32 > m_LocalPredNetFloatVariables; // 0x200	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetVectorVariables"
	CNetworkUtlVectorBase< Vector > m_LocalPredNetVectorVariables; // 0x218	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	// MNetworkSendProxyRecipientsFilter
	// MNetworkChangeCallback "OnNetVarChanged"
	// MNetworkAlias "m_LocalPredNetQuaternionVariables"
	CNetworkUtlVectorBase< Quaternion > m_LocalPredNetQuaternionVariables; // 0x230	
	// MNetworkEnable
	// MNetworkUserGroup "animationgraph"
	float m_flLastTeleportTime; // 0x248	
};

// Alignment: 0
// Size: 0x8
class CFootstepTableHandle
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 8
// Size: 0x31
class ResponseFollowup
{
public:
	char* followup_concept; // 0x0	
	char* followup_contexts; // 0x8	
	float followup_delay; // 0x10	
	char* followup_target; // 0x14	
	char* followup_entityiotarget; // 0x1c	
	char* followup_entityioinput; // 0x24	
	float followup_entityiodelay; // 0x2c	
	bool bFired; // 0x30	
};

// Alignment: 4
// Size: 0x20
class ResponseParams
{
public:
	int16_t odds; // 0x10	
	int16_t flags; // 0x12	
	uint8_t soundlevel; // 0x14	
private:
	[[maybe_unused]] uint8_t __pad0015[0x3]; 	// 0x15
public:
	ResponseFollowup* m_pFollowup; // 0x18	
};

// Alignment: 2
// Size: 0x30
class CResponseCriteriaSet
{
public:
	int32_t m_nNumPrefixedContexts; // 0x28	
	bool m_bOverrideOnAppend; // 0x2c	
};

// Alignment: 10
// Size: 0x1f0
class CRR_Response
{
public:
	uint8_t m_Type; // 0x0	
	char m_szResponseName[192]; // 0x1	
	char m_szMatchingRule[128]; // 0xc1	
private:
	[[maybe_unused]] uint8_t __pad0141[0xf]; 	// 0x141
public:
	ResponseParams m_Params; // 0x150	
	float m_fMatchScore; // 0x170	
private:
	[[maybe_unused]] uint8_t __pad0174[0x4]; 	// 0x174
public:
	char* m_szSpeakerContext; // 0x178	
	char* m_szWorldContext; // 0x180	
	ResponseFollowup m_Followup; // 0x188	
private:
	[[maybe_unused]] uint8_t __pad01b9[0x7]; 	// 0x1b9
public:
	CUtlVector< CUtlSymbol > m_pchCriteriaNames; // 0x1c0	
	CUtlVector< char* > m_pchCriteriaValues; // 0x1d8	
};

// Alignment: 2
// Size: 0x1f8
struct ConceptHistory_t
{
public:
	float timeSpoken; // 0x0	
	CRR_Response m_response; // 0x8	
};

// Alignment: 9
// Size: 0x60
class CAI_Expresser
{
public:
	float m_flStopTalkTime; // 0x38	
	float m_flStopTalkTimeWithoutDelay; // 0x3c	
	float m_flBlockedTalkTime; // 0x40	
	int32_t m_voicePitch; // 0x44	
	float m_flLastTimeAcceptedSpeak; // 0x48	
	bool m_bAllowSpeakingInterrupts; // 0x4c	
	bool m_bConsiderSceneInvolvementAsSpeech; // 0x4d	
private:
	[[maybe_unused]] uint8_t __pad004e[0x2]; 	// 0x4e
public:
	int32_t m_nLastSpokenPriority; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0054[0x4]; 	// 0x54
public:
	CBaseFlex* m_pOuter; // 0x58	
};

// Alignment: 1
// Size: 0x68
class CResponseQueue
{
public:
	CUtlVector< CAI_Expresser* > m_ExpresserTargets; // 0x50	
};

// Alignment: 5
// Size: 0x248
class CResponseQueue::CDeferredResponse
{
public:
	CResponseCriteriaSet m_contexts; // 0x10	
	float m_fDispatchTime; // 0x40	
	CHandle< CBaseEntity > m_hIssuer; // 0x44	
private:
	[[maybe_unused]] uint8_t __pad0048[0x8]; 	// 0x48
public:
	CRR_Response m_response; // 0x50	
	bool m_bResponseValid; // 0x240	
};

// Alignment: 1
// Size: 0x70
class CAI_ExpresserWithFollowup : public CAI_Expresser
{
public:
	ResponseFollowup* m_pPostponedFollowup; // 0x60	
};

// Alignment: 1
// Size: 0x78
class CMultiplayer_Expresser : public CAI_ExpresserWithFollowup
{
public:
	bool m_bAllowMultipleScenes; // 0x70	
};

// Alignment: 12
// Size: 0x78
class CCommentarySystem
{
public:
	uint64_t m_afPlayersLastButtons; // 0x18	
	bool m_bCommentaryConvarsChanging; // 0x20	
private:
	[[maybe_unused]] uint8_t __pad0021[0x3]; 	// 0x21
public:
	int32_t m_iClearPressedButtons; // 0x24	
	bool m_bCommentaryEnabledMidGame; // 0x28	
private:
	[[maybe_unused]] uint8_t __pad0029[0x3]; 	// 0x29
public:
	float m_flNextTeleportTime; // 0x2c	
	int32_t m_iTeleportStage; // 0x30	
	bool m_bCheatState; // 0x34	
	bool m_bIsFirstSpawnGroupToLoad; // 0x35	
private:
	[[maybe_unused]] uint8_t __pad0036[0x1a]; 	// 0x36
public:
	CHandle< CPointCommentaryNode > m_hCurrentNode; // 0x50	
	CHandle< CPointCommentaryNode > m_hActiveCommentaryNode; // 0x54	
	CHandle< CPointCommentaryNode > m_hLastCommentaryNode; // 0x58	
private:
	[[maybe_unused]] uint8_t __pad005c[0x4]; 	// 0x5c
public:
	CUtlVector< CHandle< CPointCommentaryNode > > m_vecNodes; // 0x60	
};

// Alignment: 1
// Size: 0x18
class CPhysicsShake
{
public:
	Vector m_force; // 0x8	
};

// Alignment: 10
// Size: 0x3c
class CGameScriptedMoveData
{
public:
	Vector m_vDest; // 0x0	
	Vector m_vSrc; // 0xc	
	QAngle m_angSrc; // 0x18	
	QAngle m_angDst; // 0x24	
	float m_flDuration; // 0x30	
	float m_flStartTime; // 0x34	
	MoveType_t m_nPrevMoveType; // 0x38	
	bool m_bFinished; // 0x39	
	bool m_bTeleportOnEnd; // 0x3a	
	bool m_bIgnoreRotation; // 0x3b	
};

// Alignment: 5
// Size: 0x20
class CGameChoreoServices : public IChoreoServices
{
public:
	CHandle< CBaseAnimating > m_hOwner; // 0x8	
	CHandle< CScriptedSequence > m_hScriptedSequence; // 0xc	
	IChoreoServices::ScriptState_t m_scriptState; // 0x10	
	CGameChoreoServices::ChoreoState_t m_choreoState; // 0x14	
	float m_flTimeStartedState; // 0x18	
};

// Alignment: 9
// Size: 0x9
struct HullFlags_t
{
public:
	bool m_bHull_Human; // 0x0	
	bool m_bHull_SmallCentered; // 0x1	
	bool m_bHull_WideHuman; // 0x2	
	bool m_bHull_Tiny; // 0x3	
	bool m_bHull_Medium; // 0x4	
	bool m_bHull_TinyCentered; // 0x5	
	bool m_bHull_Large; // 0x6	
	bool m_bHull_LargeCentered; // 0x7	
	bool m_bHull_MediumTall; // 0x8	
};

// Alignment: 4
// Size: 0x40
class CConstantForceController
{
public:
	Vector m_linear; // 0xc	
	RotationVector m_angular; // 0x18	
	Vector m_linearSave; // 0x24	
	RotationVector m_angularSave; // 0x30	
};

// Alignment: 4
// Size: 0x20
class CMotorController
{
public:
	float m_speed; // 0x8	
	float m_maxTorque; // 0xc	
	Vector m_axis; // 0x10	
	float m_inertiaFactor; // 0x1c	
};

// Alignment: 4
// Size: 0x10
class CSoundEnvelope
{
public:
	float m_current; // 0x0	
	float m_target; // 0x4	
	float m_rate; // 0x8	
	bool m_forceupdate; // 0xc	
};

// Alignment: 2
// Size: 0x28
class CCopyRecipientFilter
{
public:
	int32_t m_Flags; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000c[0x4]; 	// 0xc
public:
	CUtlVector< CPlayerSlot > m_Recipients; // 0x10	
};

// Alignment: 13
// Size: 0x90
class CSoundPatch
{
public:
	CSoundEnvelope m_pitch; // 0x8	
	CSoundEnvelope m_volume; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0028[0x8]; 	// 0x28
public:
	float m_shutdownTime; // 0x30	
	float m_flLastTime; // 0x34	
	CUtlSymbolLarge m_iszSoundScriptName; // 0x38	
	CHandle< CBaseEntity > m_hEnt; // 0x40	
	CEntityIndex m_soundEntityIndex; // 0x44	
	Vector m_soundOrigin; // 0x48	
	int32_t m_isPlaying; // 0x54	
	CCopyRecipientFilter m_Filter; // 0x58	
	float m_flCloseCaptionDuration; // 0x80	
	bool m_bUpdatedSoundOrigin; // 0x84	
private:
	[[maybe_unused]] uint8_t __pad0085[0x3]; 	// 0x85
public:
	CUtlSymbolLarge m_iszClassName; // 0x88	
	static int32_t &Get_g_SoundPatchCount(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CSoundPatch")->m_static_fields[0]->m_instance);};
};

// Alignment: 25
// Size: 0x64
struct dynpitchvol_base_t
{
public:
	int32_t preset; // 0x0	
	int32_t pitchrun; // 0x4	
	int32_t pitchstart; // 0x8	
	int32_t spinup; // 0xc	
	int32_t spindown; // 0x10	
	int32_t volrun; // 0x14	
	int32_t volstart; // 0x18	
	int32_t fadein; // 0x1c	
	int32_t fadeout; // 0x20	
	int32_t lfotype; // 0x24	
	int32_t lforate; // 0x28	
	int32_t lfomodpitch; // 0x2c	
	int32_t lfomodvol; // 0x30	
	int32_t cspinup; // 0x34	
	int32_t cspincount; // 0x38	
	int32_t pitch; // 0x3c	
	int32_t spinupsav; // 0x40	
	int32_t spindownsav; // 0x44	
	int32_t pitchfrac; // 0x48	
	int32_t vol; // 0x4c	
	int32_t fadeinsav; // 0x50	
	int32_t fadeoutsav; // 0x54	
	int32_t volfrac; // 0x58	
	int32_t lfofrac; // 0x5c	
	int32_t lfomult; // 0x60	
};

// Alignment: 0
// Size: 0x64
struct dynpitchvol_t : public dynpitchvol_base_t
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x18
struct ResponseContext_t
{
public:
	CUtlSymbolLarge m_iszName; // 0x0	
	CUtlSymbolLarge m_iszValue; // 0x8	
	float m_fExpirationTime; // 0x10	
};

// Alignment: 2
// Size: 0x8
struct Relationship_t
{
public:
	Disposition_t disposition; // 0x0	
	int32_t priority; // 0x4	
};

// Alignment: 31
// Size: 0x158
class CFourWheelVehiclePhysics
{
public:
	CHandle< CBaseAnimating > m_pOuter; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000c[0x4]; 	// 0xc
public:
	CFourWheelServerVehicle* m_pOuterServerVehicle; // 0x10	
	vehicle_controlparams_t m_controls; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0030[0x8]; 	// 0x30
public:
	int32_t m_nSpeed; // 0x38	
	int32_t m_nLastSpeed; // 0x3c	
	int32_t m_nRPM; // 0x40	
	float m_fLastBoost; // 0x44	
	int32_t m_nBoostTimeLeft; // 0x48	
	bool m_bHasBoost; // 0x4c	
private:
	[[maybe_unused]] uint8_t __pad004d[0x3]; 	// 0x4d
public:
	float m_maxThrottle; // 0x50	
	float m_flMaxRevThrottle; // 0x54	
	float m_flMaxSpeed; // 0x58	
	float m_actionSpeed; // 0x5c	
private:
	[[maybe_unused]] uint8_t __pad0060[0x20]; 	// 0x60
public:
	int32_t m_wheelCount; // 0x80	
	Vector m_wheelPosition[4]; // 0x84	
	QAngle m_wheelRotation[4]; // 0xb4	
	float m_wheelBaseHeight[4]; // 0xe4	
	float m_wheelTotalHeight[4]; // 0xf4	
	int32_t m_poseParameters[12]; // 0x104	
	float m_actionValue; // 0x134	
	float m_actionScale; // 0x138	
	float m_debugRadius; // 0x13c	
	float m_throttleRate; // 0x140	
	float m_throttleStartTime; // 0x144	
	float m_throttleActiveTime; // 0x148	
	float m_turboTimer; // 0x14c	
	float m_flVehicleVolume; // 0x150	
	bool m_bIsOn; // 0x154	
	bool m_bLastThrottle; // 0x155	
	bool m_bLastBoost; // 0x156	
	bool m_bLastSkid; // 0x157	
};

// Alignment: 3
// Size: 0x20
struct locksound_t
{
public:
	CUtlSymbolLarge sLockedSound; // 0x8	
	CUtlSymbolLarge sUnlockedSound; // 0x10	
	float flwaitSound; // 0x18	
};

// Alignment: 3
// Size: 0x14
class VelocitySampler
{
public:
	Vector m_prevSample; // 0x0	
	float m_fPrevSampleTime; // 0xc	
	float m_fIdealSampleRate; // 0x10	
};

// Alignment: 3
// Size: 0x20
class SimpleConstraintSoundProfile
{
public:
	SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t eKeypoints; // 0x8	
	float m_keyPoints[2]; // 0xc	
	float m_reversalSoundThresholds[3]; // 0x14	
};

// Alignment: 8
// Size: 0x88
class ConstraintSoundInfo
{
public:
	VelocitySampler m_vSampler; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad001c[0x4]; 	// 0x1c
public:
	SimpleConstraintSoundProfile m_soundProfile; // 0x20	
	Vector m_forwardAxis; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad004c[0x4]; 	// 0x4c
public:
	CUtlSymbolLarge m_iszTravelSoundFwd; // 0x50	
	CUtlSymbolLarge m_iszTravelSoundBack; // 0x58	
private:
	[[maybe_unused]] uint8_t __pad0060[0x8]; 	// 0x60
public:
	CUtlSymbolLarge m_iszReversalSounds[3]; // 0x68	
	bool m_bPlayTravelSound; // 0x80	
	bool m_bPlayReversalSound; // 0x81	
};

// Alignment: 3
// Size: 0x28
class CThrustController
{
public:
	Vector m_thrustVector; // 0x8	
	RotationVector m_torqueVector; // 0x14	
	float m_thrust; // 0x20	
};

// Alignment: 5
// Size: 0x20
class CSmoothFunc
{
public:
	float m_flSmoothAmplitude; // 0x8	
	float m_flSmoothBias; // 0xc	
	float m_flSmoothDuration; // 0x10	
	float m_flSmoothRemainingTime; // 0x14	
	int32_t m_nSmoothDir; // 0x18	
};

// Alignment: 1
// Size: 0x10
struct magnetted_objects_t
{
public:
	CHandle< CBaseEntity > hEntity; // 0x8	
};

// Alignment: 12
// Size: 0x34
class CSound
{
public:
	CHandle< CBaseEntity > m_hOwner; // 0x0	
	CHandle< CBaseEntity > m_hTarget; // 0x4	
	int32_t m_iVolume; // 0x8	
	float m_flOcclusionScale; // 0xc	
	int32_t m_iType; // 0x10	
	int32_t m_iNextAudible; // 0x14	
	float m_flExpireTime; // 0x18	
	int16_t m_iNext; // 0x1c	
	bool m_bNoExpirationTime; // 0x1e	
private:
	[[maybe_unused]] uint8_t __pad001f[0x1]; 	// 0x1f
public:
	int32_t m_ownerChannelIndex; // 0x20	
	Vector m_vecOrigin; // 0x24	
	bool m_bHasOwner; // 0x30	
};

// Alignment: 1
// Size: 0x4
struct ParticleIndex_t
{
public:
	int32_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 5
// Size: 0x20
class CPassengerInfo
{
public:
	int32_t m_nRole; // 0x0	
	int32_t m_nSeat; // 0x4	
	CUtlSymbolLarge m_strRoleName; // 0x8	
	CUtlSymbolLarge m_strSeatName; // 0x10	
	CHandle< CBaseCombatCharacter > m_hPassenger; // 0x18	
};

// Alignment: 2
// Size: 0x10
class CPassengerSeatTransition
{
public:
	CUtlSymbolLarge m_strAnimationName; // 0x0	
	int32_t m_nPriority; // 0x8	
};

// Alignment: 4
// Size: 0x40
class CPassengerSeat
{
public:
	CUtlSymbolLarge m_strSeatName; // 0x0	
	AttachmentHandle_t m_nAttachmentID; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0009[0x7]; 	// 0x9
public:
	CUtlVector< CPassengerSeatTransition > m_EntryTransitions; // 0x10	
	CUtlVector< CPassengerSeatTransition > m_ExitTransitions; // 0x28	
};

// Alignment: 2
// Size: 0x20
class CPassengerRole
{
public:
	CUtlSymbolLarge m_strName; // 0x0	
	CUtlVector< CPassengerSeat > m_PassengerSeats; // 0x8	
};

// Alignment: 2
// Size: 0x84
struct CBaseServerVehicle__entryanim_t
{
public:
	int32_t iHitboxGroup; // 0x0	
	char szAnimName[128]; // 0x4	
};

// Alignment: 5
// Size: 0x9c
struct CBaseServerVehicle__exitanim_t
{
public:
	bool bUpright; // 0x0	
	bool bEscapeExit; // 0x1	
	char szAnimName[128]; // 0x2	
private:
	[[maybe_unused]] uint8_t __pad0082[0x2]; 	// 0x82
public:
	Vector vecExitPointLocal; // 0x84	
	QAngle vecExitAnglesLocal; // 0x90	
};

// Alignment: 3
// Size: 0x18
struct vehicle_gear_t
{
public:
	float flMinSpeed; // 0x8	
	float flMaxSpeed; // 0xc	
	float flSpeedApproachFactor; // 0x10	
};

// Alignment: 4
// Size: 0x20
struct vehicle_crashsound_t
{
public:
	float flMinSpeed; // 0x8	
	float flMinDeltaSpeed; // 0xc	
	int32_t gearLimit; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0014[0x4]; 	// 0x14
public:
	CUtlSymbolLarge iszCrashSound; // 0x18	
};

// Alignment: 5
// Size: 0x170
struct vehiclesounds_t
{
public:
	CUtlVector< vehicle_gear_t > pGears; // 0x8	
	CUtlVector< vehicle_crashsound_t > crashSounds; // 0x20	
	CUtlSymbolLarge iszSound[9]; // 0x38	
	CUtlSymbolLarge iszStateSounds[20]; // 0x80	
	float minStateTime[20]; // 0x120	
};

// Alignment: 2
// Size: 0x8
struct ClusteredDistributionParams_t
{
public:
	float m_flClusterCoverageFraction; // 0x0	
	float m_flClusterArea; // 0x4	
};

// Alignment: 8
// Size: 0x30
struct VPhysicsCollisionAttribute_t
{
public:
	// MNetworkEnable
	uint64_t m_nInteractsAs; // 0x8	
	// MNetworkEnable
	uint64_t m_nInteractsWith; // 0x10	
	// MNetworkEnable
	uint64_t m_nInteractsExclude; // 0x18	
	// MNetworkEnable
	uint32_t m_nEntityId; // 0x20	
	// MNetworkEnable
	uint32_t m_nOwnerId; // 0x24	
	// MNetworkEnable
	uint16_t m_nHierarchyId; // 0x28	
	// MNetworkEnable
	uint8_t m_nCollisionGroup; // 0x2a	
	// MNetworkEnable
	uint8_t m_nCollisionFunctionMask; // 0x2b	
};

// Alignment: 17
// Size: 0xb0
class CCollisionProperty
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "CollisionAttributeChanged"
	VPhysicsCollisionAttribute_t m_collisionAttribute; // 0x10	
	// MNetworkEnable
	// MNetworkChangeCallback "OnUpdateOBB"
	Vector m_vecMins; // 0x40	
	// MNetworkEnable
	// MNetworkChangeCallback "OnUpdateOBB"
	Vector m_vecMaxs; // 0x4c	
private:
	[[maybe_unused]] uint8_t __pad0058[0x2]; 	// 0x58
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnUpdateSolidFlags"
	uint8_t m_usSolidFlags; // 0x5a	
	// MNetworkEnable
	// MNetworkChangeCallback "OnUpdateSolidType"
	SolidType_t m_nSolidType; // 0x5b	
	// MNetworkEnable
	// MNetworkChangeCallback "MarkSurroundingBoundsDirty"
	uint8_t m_triggerBloat; // 0x5c	
	// MNetworkEnable
	// MNetworkChangeCallback "MarkSurroundingBoundsDirty"
	SurroundingBoundsType_t m_nSurroundType; // 0x5d	
	// MNetworkEnable
	uint8_t m_CollisionGroup; // 0x5e	
	// MNetworkEnable
	bool m_bHitboxEnabled; // 0x5f	
	float m_flBoundingRadius; // 0x60	
	// MNetworkEnable
	// MNetworkChangeCallback "MarkSurroundingBoundsDirty"
	Vector m_vecSpecifiedSurroundingMins; // 0x64	
	// MNetworkEnable
	// MNetworkChangeCallback "MarkSurroundingBoundsDirty"
	Vector m_vecSpecifiedSurroundingMaxs; // 0x70	
	Vector m_vecSurroundingMaxs; // 0x7c	
	Vector m_vecSurroundingMins; // 0x88	
	// MNetworkEnable
	Vector m_vCapsuleCenter1; // 0x94	
	// MNetworkEnable
	Vector m_vCapsuleCenter2; // 0xa0	
	// MNetworkEnable
	float m_flCapsuleRadius; // 0xac	
};

// Alignment: 21
// Size: 0x70
class CEffectData
{
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vOrigin; // 0x8	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vStart; // 0x14	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vNormal; // 0x20	
	// MNetworkEnable
	// MNetworkEncoder
	QAngle m_vAngles; // 0x2c	
	// MNetworkEnable
	CEntityHandle m_hEntity; // 0x38	
	// MNetworkEnable
	CEntityHandle m_hOtherEntity; // 0x3c	
	// MNetworkEnable
	float m_flScale; // 0x40	
	// MNetworkEnable
	// MNetworkBitCount "12"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1023"
	// MNetworkEncodeFlags
	float m_flMagnitude; // 0x44	
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1023"
	// MNetworkEncodeFlags
	float m_flRadius; // 0x48	
	// MNetworkEnable
	CUtlStringToken m_nSurfaceProp; // 0x4c	
	// MNetworkEnable
	CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > m_nEffectIndex; // 0x50	
	// MNetworkEnable
	uint32_t m_nDamageType; // 0x58	
	// MNetworkEnable
	uint8_t m_nPenetrate; // 0x5c	
private:
	[[maybe_unused]] uint8_t __pad005d[0x1]; 	// 0x5d
public:
	// MNetworkEnable
	uint16_t m_nMaterial; // 0x5e	
	// MNetworkEnable
	uint16_t m_nHitBox; // 0x60	
	// MNetworkEnable
	uint8_t m_nColor; // 0x62	
	// MNetworkEnable
	uint8_t m_fFlags; // 0x63	
	// MNetworkEnable
	AttachmentHandle_t m_nAttachmentIndex; // 0x64	
private:
	[[maybe_unused]] uint8_t __pad0065[0x3]; 	// 0x65
public:
	// MNetworkEnable
	CUtlStringToken m_nAttachmentName; // 0x68	
	// MNetworkEnable
	uint16_t m_iEffectName; // 0x6c	
	// MNetworkEnable
	uint8_t m_nExplosionType; // 0x6e	
};

// Alignment: 31
// Size: 0x280
class CEnvWindShared
{
public:
	// MNetworkEnable
	float m_flStartTime; // 0x8	
	// MNetworkEnable
	uint32_t m_iWindSeed; // 0xc	
	// MNetworkEnable
	uint16_t m_iMinWind; // 0x10	
	// MNetworkEnable
	uint16_t m_iMaxWind; // 0x12	
	// MNetworkEnable
	int32_t m_windRadius; // 0x14	
	// MNetworkEnable
	uint16_t m_iMinGust; // 0x18	
	// MNetworkEnable
	uint16_t m_iMaxGust; // 0x1a	
	// MNetworkEnable
	float m_flMinGustDelay; // 0x1c	
	// MNetworkEnable
	float m_flMaxGustDelay; // 0x20	
	// MNetworkEnable
	float m_flGustDuration; // 0x24	
	// MNetworkEnable
	uint16_t m_iGustDirChange; // 0x28	
private:
	[[maybe_unused]] uint8_t __pad002a[0x2]; 	// 0x2a
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_location; // 0x2c	
	int32_t m_iszGustSound; // 0x38	
	int32_t m_iWindDir; // 0x3c	
	float m_flWindSpeed; // 0x40	
	Vector m_currentWindVector; // 0x44	
	Vector m_CurrentSwayVector; // 0x50	
	Vector m_PrevSwayVector; // 0x5c	
	// MNetworkEnable
	uint16_t m_iInitialWindDir; // 0x68	
private:
	[[maybe_unused]] uint8_t __pad006a[0x2]; 	// 0x6a
public:
	// MNetworkEnable
	float m_flInitialWindSpeed; // 0x6c	
	CEntityIOOutput m_OnGustStart; // 0x70	
	CEntityIOOutput m_OnGustEnd; // 0x98	
	float m_flVariationTime; // 0xc0	
	float m_flSwayTime; // 0xc4	
	float m_flSimTime; // 0xc8	
	float m_flSwitchTime; // 0xcc	
	float m_flAveWindSpeed; // 0xd0	
	bool m_bGusting; // 0xd4	
private:
	[[maybe_unused]] uint8_t __pad00d5[0x3]; 	// 0xd5
public:
	float m_flWindAngleVariation; // 0xd8	
	float m_flWindSpeedVariation; // 0xdc	
	CEntityIndex m_iEntIndex; // 0xe0	
};

// Alignment: 2
// Size: 0x8
struct CEnvWindShared__WindAveEvent_t
{
public:
	float m_flStartWindSpeed; // 0x0	
	float m_flAveWindSpeed; // 0x4	
};

// Alignment: 2
// Size: 0x8
struct CEnvWindShared__WindVariationEvent_t
{
public:
	float m_flWindAngleVariation; // 0x0	
	float m_flWindSpeedVariation; // 0x4	
};

// Alignment: 13
// Size: 0x60
struct shard_model_desc_t
{
public:
	// MNetworkEnable
	int32_t m_nModelID; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000c[0x4]; 	// 0xc
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hMaterial; // 0x10	
	// MNetworkEnable
	ShardSolid_t m_solid; // 0x18	
	// MNetworkEnable
	ShatterPanelMode m_ShatterPanelMode; // 0x19	
private:
	[[maybe_unused]] uint8_t __pad001a[0x2]; 	// 0x1a
public:
	// MNetworkEnable
	Vector2D m_vecPanelSize; // 0x1c	
	// MNetworkEnable
	Vector2D m_vecStressPositionA; // 0x24	
	// MNetworkEnable
	Vector2D m_vecStressPositionB; // 0x2c	
private:
	[[maybe_unused]] uint8_t __pad0034[0x4]; 	// 0x34
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< Vector2D > m_vecPanelVertices; // 0x38	
	// MNetworkEnable
	float m_flGlassHalfThickness; // 0x50	
	// MNetworkEnable
	bool m_bHasParent; // 0x54	
	// MNetworkEnable
	bool m_bParentFrozen; // 0x55	
private:
	[[maybe_unused]] uint8_t __pad0056[0x2]; 	// 0x56
public:
	// MNetworkEnable
	CUtlStringToken m_SurfacePropStringToken; // 0x58	
	// MNetworkEnable
	CUtlStringToken m_LightGroup; // 0x5c	
};

// Alignment: 30
// Size: 0xc0
class CShatterGlassShard
{
public:
	uint32_t m_hShardHandle; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000c[0x4]; 	// 0xc
public:
	CUtlVector< Vector2D > m_vecPanelVertices; // 0x10	
	Vector2D m_vLocalPanelSpaceOrigin; // 0x28	
	CStrongHandle< InfoForResourceTypeCModel > m_hModel; // 0x30	
	CHandle< CShatterGlassShardPhysics > m_hPhysicsEntity; // 0x38	
	CHandle< CFuncShatterglass > m_hParentPanel; // 0x3c	
	uint32_t m_hParentShard; // 0x40	
	ShatterGlassStressType m_ShatterStressType; // 0x44	
private:
	[[maybe_unused]] uint8_t __pad0045[0x3]; 	// 0x45
public:
	Vector m_vecStressVelocity; // 0x48	
	bool m_bCreatedModel; // 0x54	
private:
	[[maybe_unused]] uint8_t __pad0055[0x3]; 	// 0x55
public:
	float m_flLongestEdge; // 0x58	
	float m_flShortestEdge; // 0x5c	
	float m_flLongestAcross; // 0x60	
	float m_flShortestAcross; // 0x64	
	float m_flSumOfAllEdges; // 0x68	
	float m_flArea; // 0x6c	
	OnFrame m_nOnFrameEdge; // 0x70	
private:
	[[maybe_unused]] uint8_t __pad0071[0x3]; 	// 0x71
public:
	int32_t m_nParentPanelsNthShard; // 0x74	
	int32_t m_nSubShardGeneration; // 0x78	
	Vector2D m_vecAverageVertPosition; // 0x7c	
	bool m_bAverageVertPositionIsValid; // 0x84	
private:
	[[maybe_unused]] uint8_t __pad0085[0x3]; 	// 0x85
public:
	Vector2D m_vecPanelSpaceStressPositionA; // 0x88	
	Vector2D m_vecPanelSpaceStressPositionB; // 0x90	
	bool m_bStressPositionAIsValid; // 0x98	
	bool m_bStressPositionBIsValid; // 0x99	
	bool m_bFlaggedForRemoval; // 0x9a	
private:
	[[maybe_unused]] uint8_t __pad009b[0x1]; 	// 0x9b
public:
	float m_flPhysicsEntitySpawnedAtTime; // 0x9c	
	bool m_bShatterRateLimited; // 0xa0	
private:
	[[maybe_unused]] uint8_t __pad00a1[0x3]; 	// 0xa1
public:
	CHandle< CBaseEntity > m_hEntityHittingMe; // 0xa4	
	CUtlVector< uint32 > m_vecNeighbors; // 0xa8	
};

// Alignment: 2
// Size: 0x90
class CGameRules
{
public:
	char m_szQuestName[128]; // 0x8	
	int32_t m_nQuestPhase; // 0x88	
};

// Alignment: 10
// Size: 0x50
class CGlowProperty
{
public:
	Vector m_fGlowColor; // 0x8	
	int32_t m_iGlowTeam; // 0x14	
private:
	[[maybe_unused]] uint8_t __pad0018[0x18]; 	// 0x18
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnGlowTypeChanged"
	int32_t m_iGlowType; // 0x30	
	// MNetworkEnable
	int32_t m_nGlowRange; // 0x34	
	// MNetworkEnable
	int32_t m_nGlowRangeMin; // 0x38	
	// MNetworkEnable
	// MNetworkChangeCallback "OnGlowColorChanged"
	Color m_glowColorOverride; // 0x3c	
	// MNetworkEnable
	bool m_bFlashing; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad0041[0x3]; 	// 0x41
public:
	// MNetworkEnable
	float m_flGlowTime; // 0x44	
	// MNetworkEnable
	float m_flGlowStartTime; // 0x48	
	bool m_bGlowing; // 0x4c	
};

// Alignment: 0
// Size: 0x8
class IVehicle
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 0
// Size: 0x90
class CMultiplayRules : public CGameRules
{
public:
	// @note: no members available
};

// Alignment: 24
// Size: 0x68
struct fogparams_t
{
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector dirPrimary; // 0x8	
	// MNetworkEnable
	Color colorPrimary; // 0x14	
	// MNetworkEnable
	Color colorSecondary; // 0x18	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	Color colorPrimaryLerpTo; // 0x1c	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	Color colorSecondaryLerpTo; // 0x20	
	// MNetworkEnable
	float start; // 0x24	
	// MNetworkEnable
	float end; // 0x28	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float farz; // 0x2c	
	// MNetworkEnable
	float maxdensity; // 0x30	
	// MNetworkEnable
	float exponent; // 0x34	
	// MNetworkEnable
	float HDRColorScale; // 0x38	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float skyboxFogFactor; // 0x3c	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float skyboxFogFactorLerpTo; // 0x40	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float startLerpTo; // 0x44	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float endLerpTo; // 0x48	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float maxdensityLerpTo; // 0x4c	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float lerptime; // 0x50	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float duration; // 0x54	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float blendtobackground; // 0x58	
	// MNetworkEnable
	// MNetworkUserGroup "FogController"
	float scattering; // 0x5c	
	// MNetworkEnable
	bool enable; // 0x60	
	// MNetworkEnable
	bool blend; // 0x61	
	// MNetworkEnable
	bool m_bNoReflectionFog; // 0x62	
	bool m_bPadding; // 0x63	
};

// Alignment: 17
// Size: 0x178
class CPlayer_CameraServices : public CPlayerComponent
{
public:
	// MNetworkEnable
	uint32_t m_iFOV; // 0x30	
	// MNetworkEnable
	uint32_t m_iFOVStart; // 0x34	
	// MNetworkEnable
	float m_flFOVTime; // 0x38	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	float m_flFOVRate; // 0x3c	
	// MNetworkEnable
	uint32_t m_iDefaultFOV; // 0x40	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	// MNetworkPriority "32"
	// MNetworkBitCount "32"
	QAngle m_vecPunchAngle; // 0x44	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	// MNetworkBitCount "32"
	QAngle m_vecPunchAngleVel; // 0x50	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hZoomOwner; // 0x5c	
	// MNetworkEnable
	fogplayerparams_t m_PlayerFog; // 0x60	
	// MNetworkEnable
	CHandle< CColorCorrection > m_hColorCorrectionCtrl; // 0xa0	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hViewEntity; // 0xa4	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	CHandle< CTonemapController2 > m_hTonemapController; // 0xa8	
private:
	[[maybe_unused]] uint8_t __pad00ac[0x4]; 	// 0xac
public:
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	audioparams_t m_audio; // 0xb0	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	CNetworkUtlVectorBase< CHandle< CPostProcessingVolume > > m_PostProcessingVolumes; // 0x128	
	float m_flOldPlayerZ; // 0x140	
	float m_flOldPlayerViewOffsetZ; // 0x144	
private:
	[[maybe_unused]] uint8_t __pad0148[0x18]; 	// 0x148
public:
	CUtlVector< CHandle< CEnvSoundscapeTriggerable > > m_hTriggerSoundscapeList; // 0x160	
};

// Alignment: 6
// Size: 0x90
struct sky3dparams_t
{
public:
	// MNetworkEnable
	int16_t scale; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000a[0x2]; 	// 0xa
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector origin; // 0xc	
	// MNetworkEnable
	bool bClip3DSkyBoxNearToWorldFar; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0019[0x3]; 	// 0x19
public:
	// MNetworkEnable
	float flClip3DSkyBoxNearToWorldFarOffset; // 0x1c	
	// MNetworkEnable
	fogparams_t fog; // 0x20	
	// MNetworkEnable
	CUtlStringToken m_nWorldGroupID; // 0x88	
};

// Alignment: 0
// Size: 0x8
class IRagdoll
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 3
// Size: 0x28
struct ragdollelement_t
{
public:
	Vector originParentSpace; // 0x0	
	int32_t parentIndex; // 0x20	
	float m_flRadius; // 0x24	
};

// Alignment: 4
// Size: 0x38
struct ragdoll_t
{
public:
	CUtlVector< ragdollelement_t > list; // 0x0	
	CUtlVector< int32 > boneIndex; // 0x18	
	bool allowStretch; // 0x30	
	bool unused; // 0x31	
};

// Alignment: 17
// Size: 0x60
class CSceneEventInfo
{
public:
	int32_t m_iLayer; // 0x0	
	int32_t m_iPriority; // 0x4	
	HSequence m_hSequence; // 0x8	
	float m_flWeight; // 0xc	
	bool m_bIsMoving; // 0x10	
	bool m_bHasArrived; // 0x11	
private:
	[[maybe_unused]] uint8_t __pad0012[0x2]; 	// 0x12
public:
	float m_flInitialYaw; // 0x14	
	float m_flTargetYaw; // 0x18	
	float m_flFacingYaw; // 0x1c	
	int32_t m_nType; // 0x20	
	float m_flNext; // 0x24	
	bool m_bIsGesture; // 0x28	
	bool m_bShouldRemove; // 0x29	
private:
	[[maybe_unused]] uint8_t __pad002a[0x2a]; 	// 0x2a
public:
	CHandle< CBaseEntity > m_hTarget; // 0x54	
	uint32_t m_nSceneEventId; // 0x58	
	bool m_bClientSide; // 0x5c	
	bool m_bStarted; // 0x5d	
};

// Alignment: 4
// Size: 0x28
class CSequenceTransitioner
{
public:
	CUtlVector< CAnimationLayer > m_animationQueue; // 0x0	
	bool m_bIsInSimulation; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0019[0x3]; 	// 0x19
public:
	float m_flSimOrRenderTime; // 0x1c	
	float m_flInterpolatedTime; // 0x20	
};

// Alignment: 7
// Size: 0x60
struct TransitioningLayer_t
{
public:
	CNetworkedSequenceOperation m_op; // 0x8	
	float m_flStartAnimTime; // 0x48	
	float m_flStartWeight; // 0x4c	
	float m_flAnimTime; // 0x50	
	int32_t m_nOrder; // 0x54	
	float m_flPlaybackRate; // 0x58	
	float m_flFadeOutDuration; // 0x5c	
};

// Alignment: 5
// Size: 0x1d8
class CSequenceTransitioner2
{
public:
	CNetworkedSequenceOperation m_currentOp; // 0x8	
	float m_flCurrentPlaybackRate; // 0x48	
	float m_flCurrentAnimTime; // 0x4c	
	TransitioningLayer_t m_transitioningLayers[4]; // 0x50	
	CBaseAnimatingController* m_pOwner; // 0x1d0	
};

// Alignment: 6
// Size: 0x34
struct lerpdata_t
{
public:
	CHandle< CBaseEntity > m_hEnt; // 0x0	
	MoveType_t m_MoveType; // 0x4	
private:
	[[maybe_unused]] uint8_t __pad0005[0x3]; 	// 0x5
public:
	float m_flStartTime; // 0x8	
	Vector m_vecStartOrigin; // 0xc	
	Quaternion m_qStartRot; // 0x18	
	ParticleIndex_t m_nFXIndex; // 0x28	
};

// Alignment: 1
// Size: 0x1
struct AmmoIndex_t
{
public:
	int8_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 0
// Size: 0x28
class CEntitySubclassVDataBase
{
public:
	uint8_t __pad0000[0x28]; 	// @note: autoaligned
};

// Alignment: 4
// Size: 0x20
struct thinkfunc_t
{
public:
	HSCRIPT m_hFn; // 0x8	
	CUtlStringToken m_nContext; // 0x10	
	int32_t m_nNextThinkTick; // 0x14	
	int32_t m_nLastThinkTick; // 0x18	
};

// Alignment: 2
// Size: 0x10
struct RagdollCreationParams_t
{
public:
	Vector m_vForce; // 0x0	
	int32_t m_nForceBone; // 0xc	
};

// Alignment: 10
// Size: 0x24
struct hudtextparms_t
{
public:
	Color color1; // 0x0	
	Color color2; // 0x4	
	uint8_t effect; // 0x8	
	uint8_t channel; // 0x9	
private:
	[[maybe_unused]] uint8_t __pad000a[0x2]; 	// 0xa
public:
	float x; // 0xc	
	float y; // 0x10	
	float fadeinTime; // 0x14	
	float fadeoutTime; // 0x18	
	float holdTime; // 0x1c	
	float fxTime; // 0x20	
};

// Alignment: 1
// Size: 0x4
class CSimpleSimTimer
{
public:
	float m_next; // 0x0	
};

// Alignment: 1
// Size: 0x8
class CSimTimer : public CSimpleSimTimer
{
public:
	float m_interval; // 0x4	
};

// Alignment: 2
// Size: 0xc
class CRandSimTimer : public CSimpleSimTimer
{
public:
	float m_minInterval; // 0x4	
	float m_maxInterval; // 0x8	
};

// Alignment: 1
// Size: 0x10
class CStopwatchBase : public CSimpleSimTimer
{
public:
	bool m_fIsRunning; // 0xc	
};

// Alignment: 1
// Size: 0x18
class CStopwatch : public CStopwatchBase
{
public:
	float m_interval; // 0x10	
};

// Alignment: 2
// Size: 0x18
class CRandStopwatch : public CStopwatchBase
{
public:
	float m_minInterval; // 0x10	
	float m_maxInterval; // 0x14	
};

// Alignment: 1
// Size: 0x98
class CSingleplayRules : public CGameRules
{
public:
	bool m_bSinglePlayerGameEnding; // 0x90	
};

// Alignment: 15
// Size: 0xa0
class CTakeDamageInfo
{
public:
	Vector m_vecDamageForce; // 0x8	
	Vector m_vecDamagePosition; // 0x14	
	Vector m_vecReportedPosition; // 0x20	
	Vector m_vecDamageDirection; // 0x2c	
	CHandle< CBaseEntity > m_hInflictor; // 0x38	
	CHandle< CBaseEntity > m_hAttacker; // 0x3c	
	CHandle< CBaseEntity > m_hAbility; // 0x40	
	float m_flDamage; // 0x44	
	int32_t m_bitsDamageType; // 0x48	
	int32_t m_iDamageCustom; // 0x4c	
	AmmoIndex_t m_iAmmoType; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0051[0xf]; 	// 0x51
public:
	float m_flOriginalDamage; // 0x60	
private:
	[[maybe_unused]] uint8_t __pad0064[0xc]; 	// 0x64
public:
	TakeDamageFlags_t m_nDamageFlags; // 0x70	
private:
	[[maybe_unused]] uint8_t __pad0072[0x6]; 	// 0x72
public:
	HSCRIPT m_hScriptInstance; // 0x78	
private:
	[[maybe_unused]] uint8_t __pad0080[0x18]; 	// 0x80
public:
	bool m_bInTakeDamageFlow; // 0x98	
	static CTakeDamageInfo &Get_EmptyInfo(){return *reinterpret_cast<CTakeDamageInfo*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CTakeDamageInfo")->m_static_fields[0]->m_instance);};
};

// Alignment: 2
// Size: 0x8
class CTakeDamageResult
{
public:
	int32_t m_nHealthLost; // 0x0	
	int32_t m_nDamageTaken; // 0x4	
};

// Alignment: 4
// Size: 0xb8
struct SummaryTakeDamageInfo_t
{
public:
	int32_t nSummarisedCount; // 0x0	
	CTakeDamageInfo info; // 0x8	
	CTakeDamageResult result; // 0xa8	
	CHandle< CBaseEntity > hTarget; // 0xb0	
};

// Alignment: 1
// Size: 0x20
class CTakeDamageSummaryScopeGuard
{
public:
	CUtlVector< SummaryTakeDamageInfo_t* > m_vecSummaries; // 0x8	
	static SummaryTakeDamageInfo_t &Get_EmptySummary(){return *reinterpret_cast<SummaryTakeDamageInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CTakeDamageSummaryScopeGuard")->m_static_fields[0]->m_instance);};
};

// Alignment: 0
// Size: 0x90
class CTeamplayRules : public CMultiplayRules
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x10
struct ViewLockData_t
{
public:
	float flLockInterval; // 0x0	
	bool bLocked; // 0x4	
private:
	[[maybe_unused]] uint8_t __pad0005[0x3]; 	// 0x5
public:
	float flUnlockTime; // 0x8	
	float flUnlockBlendInterval; // 0xc	
};

// Alignment: 18
// Size: 0x80
struct ViewSmoothingData_t
{
public:
	CBaseAnimating* pVehicle; // 0x0	
	bool bClampEyeAngles; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0009[0x3]; 	// 0x9
public:
	float flPitchCurveZero; // 0xc	
	float flPitchCurveLinear; // 0x10	
	float flRollCurveZero; // 0x14	
	float flRollCurveLinear; // 0x18	
	float flFOV; // 0x1c	
	ViewLockData_t pitchLockData; // 0x20	
	ViewLockData_t rollLockData; // 0x30	
	bool bDampenEyePosition; // 0x40	
	bool bRunningEnterExit; // 0x41	
	bool bWasRunningAnim; // 0x42	
private:
	[[maybe_unused]] uint8_t __pad0043[0x1]; 	// 0x43
public:
	float flEnterExitStartTime; // 0x44	
	float flEnterExitDuration; // 0x48	
	QAngle vecAnglesSaved; // 0x4c	
	Vector vecOriginSaved; // 0x58	
	QAngle vecAngleDiffSaved; // 0x64	
	QAngle vecAngleDiffMin; // 0x70	
};

// Alignment: 3
// Size: 0x14
struct UnreachableEnt_t
{
public:
	CHandle< CBaseEntity > hUnreachableEnt; // 0x0	
	float fExpireTime; // 0x4	
	Vector vLocationWhenUnreachable; // 0x8	
};

// Alignment: 2
// Size: 0x8
struct AI_SchedLoadStatus_t
{
public:
	bool bValid; // 0x0	
	int32_t nSignature; // 0x4	
};

// Alignment: 2
// Size: 0x10
struct NPCAttachmentSpawnKV_t
{
public:
	CUtlString m_sKey; // 0x0	
	CUtlString m_sValue; // 0x8	
};

// Alignment: 5
// Size: 0x118
struct NPCAttachmentDesc_t
{
public:
	CUtlString m_sAttachmentName; // 0x0	
	CUtlString m_sEntityName; // 0x8	
	Vector m_vOffset; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad001c[0x4]; 	// 0x1c
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x20	
	CUtlVector< NPCAttachmentSpawnKV_t > m_vecSpawnKV; // 0x100	
};

// Alignment: 11
// Size: 0x1a8
class CAI_BaseNPCVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	// MPropertyGroupName "Sounds"
	CFootstepTableHandle m_hFootstepSounds; // 0x108	
	int32_t m_nMaxHealth; // 0x110	
private:
	[[maybe_unused]] uint8_t __pad0114[0x4]; 	// 0x114
public:
	CUtlVector< CEmbeddedSubclass< CSteamPalModifier > > m_vecIntrinsicModifiers; // 0x118	
	CUtlVector< NPCAttachmentDesc_t > m_vecAttachments; // 0x130	
	// MPropertyGroupName "Damage"
	CSkillFloat m_flHeadDamageMultiplier; // 0x148	
	// MPropertyGroupName "Damage"
	CSkillFloat m_flChestDamageMultiplier; // 0x158	
	// MPropertyGroupName "Damage"
	CSkillFloat m_flStomachDamageMultiplier; // 0x168	
	// MPropertyGroupName "Damage"
	CSkillFloat m_flArmDamageMultiplier; // 0x178	
	// MPropertyGroupName "Damage"
	CSkillFloat m_flLegDamageMultiplier; // 0x188	
	// MPropertyGroupName "Damage"
	CSkillInt m_nMaxAdditionalAmmoBalancingShots; // 0x198	
};

// Alignment: 4
// Size: 0x30
class CAI_BehaviorHost
{
public:
	CAI_BehaviorBase* m_pPrimaryBehavior; // 0x0	
	CAI_DefaultNPC* m_pOuter; // 0x8	
	CUtlVector< CAI_BehaviorBase* > m_Behaviors; // 0x10	
	bool m_bCalledBehaviorSelectSchedule; // 0x28	
};

// Alignment: 5
// Size: 0x24
struct LastIncomingHit_t
{
public:
	Vector vecDir; // 0x0	
	Vector vecBoneLocalPos; // 0xc	
	int32_t nHitboxBoneIndex; // 0x18	
	float flHitStrength; // 0x1c	
	int32_t nDamageType; // 0x20	
};

// Alignment: 0
// Size: 0x18
class CAI_Component
{
public:
	uint8_t __pad0000[0x18]; 	// @note: autoaligned
};

// Alignment: 1
// Size: 0x4
struct ConditionId_t
{
public:
	int32_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 0
// Size: 0x20
class CAI_ScheduleBits
{
public:
	uint8_t __pad0000[0x20]; 	// @note: autoaligned
};

// Alignment: 6
// Size: 0x38
class CAI_EnemyServices : public CAI_Component
{
public:
	CHandle< CBaseEntity > m_hEnemy; // 0x18	
	CHandle< CBaseEntity > m_hLastEnemy; // 0x1c	
	float m_flTimeEnemyAcquired; // 0x20	
	float m_flTimeLastHadEnemy; // 0x24	
	int32_t m_nEnemiesSerialNumber; // 0x28	
	CHandle< CBaseEntity > m_hEnemyOccluder; // 0x2c	
};

// Alignment: 11
// Size: 0x40
class HintNodeData
{
public:
	CUtlSymbolLarge strEntityName; // 0x0	
	int16_t nHintType; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000a[0x2]; 	// 0xa
public:
	int32_t nNodeID; // 0xc	
	CUtlSymbolLarge strGroup; // 0x10	
	int32_t iDisabled; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad001c[0x4]; 	// 0x1c
public:
	CUtlSymbolLarge iszGenericType; // 0x20	
	CUtlSymbolLarge iszActivityName; // 0x28	
	HintIgnoreFacing_t fIgnoreFacing; // 0x30	
	NPC_STATE minState; // 0x34	
	NPC_STATE maxState; // 0x38	
	int32_t nRadius; // 0x3c	
};

// Alignment: 2
// Size: 0x10
class CAI_MoveMonitor
{
public:
	Vector m_vMark; // 0x0	
	float m_flMarkTolerance; // 0xc	
};

// Alignment: 8
// Size: 0x20
struct AIScheduleState_t
{
public:
	int32_t iCurTask; // 0x0	
	TaskStatus_e nTaskStatus; // 0x4	
	float timeStarted; // 0x8	
	float timeCurTaskStarted; // 0xc	
	int64_t taskFailureCode; // 0x10	
	int32_t iTaskInterrupt; // 0x18	
	bool bTaskRanAutomovement; // 0x1c	
	bool bScheduleWasInterrupted; // 0x1d	
};

// Alignment: 5
// Size: 0x70
class CAI_Scheduler : public CAI_Component
{
public:
	AIScheduleState_t m_ScheduleState; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0038[0x8]; 	// 0x38
public:
	CUtlSymbolLarge m_failSchedule; // 0x40	
	CUtlSymbolLarge m_untranslatedSchedule; // 0x48	
private:
	[[maybe_unused]] uint8_t __pad0050[0x8]; 	// 0x50
public:
	char* m_szFailText; // 0x58	
private:
	[[maybe_unused]] uint8_t __pad0060[0x8]; 	// 0x60
public:
	char* m_szInterruptText; // 0x68	
	static int32_t &Get_ms_nTasksRun(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_Scheduler")->m_static_fields[0]->m_instance);};
};

// Alignment: 2
// Size: 0x8
class CAI_ProxTester
{
public:
	float m_distSq; // 0x0	
	bool m_fInside; // 0x4	
};

// Alignment: 3
// Size: 0x14
class CAI_ScriptConditionsElement
{
public:
	CHandle< CBaseEntity > m_hActor; // 0x0	
	CSimTimer m_Timer; // 0x4	
	CSimTimer m_Timeout; // 0xc	
};

// Alignment: 1
// Size: 0x28
struct SquadModeInfo_t
{
public:
	CUtlVector< SquadSlotId_t > m_vecSlots; // 0x10	
};

// Alignment: 3
// Size: 0x14
struct AISquadEnemyInfo_t
{
public:
	CHandle< CBaseEntity > hEnemy; // 0x0	
	CBitVec< 48 > slots; // 0x4	
	CBitVec< 48 > inactive_slots_by_mode; // 0xc	
};

// Alignment: 3
// Size: 0xc
struct SquadSlotNPCEntry_t
{
public:
	SquadSlotId_t nId; // 0x0	
	CHandle< CBaseEntity > hEnemy; // 0x4	
	bool bHoldForManualRelease; // 0x8	
};

// Alignment: 9
// Size: 0x30
struct AI_FreePassParams_t
{
public:
	float timeToTrigger; // 0x8	
	float duration; // 0xc	
	float moveTolerance; // 0x10	
	float refillRate; // 0x14	
	float coverDist; // 0x18	
	float peekTime; // 0x1c	
	float peekTimeAfterDamage; // 0x20	
	float peekEyeDist; // 0x24	
	float peekEyeDistZ; // 0x28	
};

// Alignment: 4
// Size: 0x60
class CAI_FreePass : public CAI_Component
{
public:
	CHandle< CBaseEntity > m_hTarget; // 0x18	
	float m_FreePassTimeRemaining; // 0x1c	
	CAI_MoveMonitor m_FreePassMoveMonitor; // 0x20	
	AI_FreePassParams_t m_Params; // 0x30	
};

// Alignment: 6
// Size: 0x38
struct NPCAbilityPickupBehavior_t
{
public:
	AbilityPickupBehaviorType_t m_behaviorType; // 0x0	
	// MPropertyAttributeEditor "VDataChoice( scripts/ammo.vdata )"
	// MPropertySuppressExpr "m_behaviorType != eAbilityPickupBehavior_GrantSpecifiedAmmo"
	// MPropertyDescription "The type of ammo to grant to a player or NPC. Only grants it to players/NPCs who can use that ammo type."
	CUtlString m_sAmmoType; // 0x8	
	// MPropertySuppressExpr "m_behaviorType != eAbilityPickupBehavior_GrantDroppedAmmo"
	bool m_bAllowNPCsToPickUpDroppedAmmo; // 0x10	
	// MPropertySuppressExpr "m_behaviorType != eAbilityPickupBehavior_GrantSpecifiedAmmo"
	bool m_bAllowNPCsToPickUpSpecifiedAmmo; // 0x11	
private:
	[[maybe_unused]] uint8_t __pad0012[0x6]; 	// 0x12
public:
	// MPropertySuppressExpr "m_behaviorType != eAbilityPickupBehavior_GrantSpecifiedNPCAbility"
	// MPropertyDescription "The NPC ability type to grant. Only grants it to NPCs which have been marked as being able to use this ability type."
	CSubclassName< 6 > m_sNPCAbilityName; // 0x18	
	// MPropertySuppressExpr "m_behaviorType != eAbilityPickupBehavior_GrantPlayerWeapon"
	// MPropertyDescription "The player weapon to grant."
	CSubclassName< 3 > m_sPlayerWeaponName; // 0x28	
};

// Alignment: 5
// Size: 0x30
struct NPCAbilityDropBehavior_t
{
public:
	AbilityDropBehaviorType_t m_behaviorType; // 0x0	
	// MPropertySuppressExpr "m_behaviorType != eAbilityDropBehavior_AddIntAttributeToAbilityModel"
	// MPropertyDescription "Name of the Int attribute to add to the ability model being dropped."
	CUtlString m_sIntAttrName; // 0x8	
	// MPropertySuppressExpr "m_behaviorType != eAbilityDropBehavior_AddIntAttributeToAbilityModel"
	// MPropertyDescription "Value of the Int attribute to add to the ability model being dropped."
	int32_t m_nIntAttrValue; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0014[0x4]; 	// 0x14
public:
	// MPropertySuppressExpr "m_behaviorType != eAbilityDropBehavior_CreateEntityBySubclass"
	// MPropertyDescription "Name of the misc subclass to create"
	CSubclassNameGeneric m_sSubclass; // 0x18	
	// MPropertySuppressExpr "m_behaviorType != eAbilityDropBehavior_SetGravityScale"
	// MPropertyDescription "Name of the misc subclass to create"
	float m_flGravityScale; // 0x28	
};

// Alignment: 6
// Size: 0x28
struct NPCAbilityTarget_t
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	ChangeAccessorFieldPathIndex_t m_NetworkVar_PathIndex; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000a[0x2]; 	// 0xa
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hTargetEntity; // 0xc	
	// MNetworkEnable
	BodyLocations_t m_locTargetEntityBodyLocation; // 0x10	
	// MNetworkEnable
	TargetOriginType_t m_locGatherTargetEntityOriginType; // 0x14	
	// MNetworkEnable
	TargetOriginType_t m_locUsageTargetEntityOriginType; // 0x18	
	// MNetworkEnable
	Vector m_vecWorldPosition; // 0x1c	
};

// Alignment: 2
// Size: 0x20
struct NPCAbilityDesc_t
{
public:
	CSubclassName< 6 > m_sAbilityName; // 0x0	
	CSubclassName< 6 > m_sPrimaryLinkedAbilityName; // 0x10	
};

// Alignment: 2
// Size: 0x10
struct AI_TaskVData_t
{
public:
	CUtlString m_sTask; // 0x0	
	CUtlString m_sParam; // 0x8	
};

// Alignment: 4
// Size: 0x40
struct AI_ScheduleVData_t
{
public:
	CUtlString m_sSchedule; // 0x0	
	bool m_bFlag_Ability; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0009[0x7]; 	// 0x9
public:
	CUtlVector< AI_TaskVData_t > m_vecTasks; // 0x10	
	CUtlVector< CUtlString > m_vecInterrupts; // 0x28	
};

// Alignment: 20
// Size: 0x280
class CAI_DefaultNPCVData : public CAI_BaseNPCVData
{
public:
	Class_T m_nClassifyAs; // 0x1a8	
	// MPropertyGroupName "Flinching"
	CRangeFloat m_flInterruptFlinchCooldown; // 0x1ac	
	// MPropertyGroupName "Flinching"
	CRangeFloat m_flNonInterruptFlinchCooldown; // 0x1b4	
	// MPropertyGroupName "Flinching"
	// MPropertyDescription "When checking for flinch movement clearance, this is the minimum distance that must be clear for us to do a large flinch."
	float m_flFlinchClearDistanceForLarge; // 0x1bc	
	// MPropertyGroupName "Flinching"
	// MPropertyDescription "When checking for flinch movement clearance, this is the minimum distance that must be clear for us to do a small flinch. If this distance isn't clear, we'll choose a stationary flinch."
	float m_flFlinchClearDistanceForSmall; // 0x1c0	
	// MPropertyGroupName "Flinching"
	// MPropertyDescription "when hit by DMG_TMPRAGDOLL, this is the minimum amount of time this npc will stay in tmp ragdoll (scaled by damage)"
	CSkillFloat m_flTmpRagdollDamageTimeMin; // 0x1c4	
	// MPropertyGroupName "Flinching"
	// MPropertyDescription "when hit by DMG_TMPRAGDOLL, this is the maximum amount of time this npc will stay in tmp ragdoll (scaled by damage)"
	CSkillFloat m_flTmpRagdollDamageTimeMax; // 0x1d4	
private:
	[[maybe_unused]] uint8_t __pad01e4[0x4]; 	// 0x1e4
public:
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sDeathSound; // 0x1e8	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sPainSound; // 0x1f8	
	// MPropertyDescription "If the distance between the nearest point on a hitscan bullet's trajectory and this NPC's eyes is less than this react amount, this NPC will be notified of the incoming fire via the WarnOfIncomingFire() virtual."
	CRangeFloat m_flIncomingFireDistance; // 0x208	
	// MPropertyDescription "Abilities are things like alt-fire or even weapon upgrades"
	CUtlVector< NPCAbilityDesc_t > m_vecAbilities; // 0x210	
	// MPropertyFriendlyName "Auto Unholster Held Ability"
	// MPropertyDescription "If set, the NPC will automatically unholster the first held ability it's granted."
	bool m_bAutoUnholsterHeldAbility; // 0x228	
	// MPropertyGroupName "Throw & Catch"
	bool m_bCatchThrownProps; // 0x229	
	// MPropertyGroupName "Throw & Catch"
	// MPropertyDescription "If already holding an item, drop it when another item is thrown at us."
	// MPropertySuppressExpr "m_bCatchThrownProps == 0"
	bool m_bDropHeldItemOnThrownCollision; // 0x22a	
private:
	[[maybe_unused]] uint8_t __pad022b[0x5]; 	// 0x22b
public:
	// MPropertyGroupName "Throw & Catch"
	// MPropertyDescription "Graph param that will be set when the entity knows something has been thrown to them (the prop is still in the air)"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	// MPropertySuppressExpr "m_bCatchThrownProps == 0"
	CUtlString m_sReadyCatchAnimgraphParam; // 0x230	
	// MPropertyGroupName "Throw & Catch"
	// MPropertyDescription "Graph param that will be set the moment the thrown prop reaches them."
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	// MPropertySuppressExpr "m_bCatchThrownProps == 0"
	CUtlString m_sCatchAnimgraphParam; // 0x238	
	// MPropertyGroupName "Throw & Catch"
	// MPropertyDescription "Graph param that will be set the moment the thrown prop reaches them."
	// MPropertyAttributeEditor "VDataModelAttachment( m_sModelName )"
	// MPropertySuppressExpr "m_bCatchThrownProps == 0"
	CUtlString m_sCatchAttachmentName; // 0x240	
	// MPropertyGroupName "Throw & Catch"
	// MPropertyDescription "If this NPC supports catching and throwing, show interest in props with any of these string attributes."
	// MPropertySuppressExpr "m_bCatchThrownProps == 0"
	CUtlVector< CUtlString > m_CatchablePropAttriburtes; // 0x248	
	CUtlVector< AI_ScheduleVData_t > m_vecSchedules; // 0x260	
	// MPropertyDescription "If non-empty, this refers to a squad mode entry in npc_squad_modes.txt. The first NPC to be added to a squad will use this mode as the squad mode."
	CUtlString m_sDefaultSquadMode; // 0x278	
};

// Alignment: 3
// Size: 0x28
struct BodyLocationVDataForStance_t
{
public:
	CUtlString m_pSpeculationAttachment[3]; // 0x0	
	bool m_bUsePitch; // 0x18	
private:
	[[maybe_unused]] uint8_t __pad0019[0x3]; 	// 0x19
public:
	Vector m_vecSpeculationPosMiddle; // 0x1c	
};

// Alignment: 3
// Size: 0x60
struct BodyLocationVData_t
{
public:
	CUtlString m_sAttachmentName; // 0x0	
	bool m_bAttachmentIsOnAbilityModel; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0009[0x7]; 	// 0x9
public:
	BodyLocationVDataForStance_t m_pStances[2]; // 0x10	
};

// Alignment: 1
// Size: 0xc0
struct BodyLocationListVData_t
{
public:
	BodyLocationVData_t* m_ppBodyLocationData[5]; // 0x0	
};

// Alignment: 3
// Size: 0xc
struct attached_item_t
{
public:
	CHandle< CBaseEntity > hItem; // 0x0	
	CUtlStringToken sAttachment; // 0x4	
	CUtlStringToken sAttachmentNormal; // 0x8	
};

// Alignment: 3
// Size: 0x370
class CAI_BaseActorVData : public CAI_DefaultNPCVData
{
public:
	// MPropertyFriendlyName "Mood File"
	// MPropertyGroupName "Acting"
	// MPropertyAttributeEditor "AssetBrowse( vdata )"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCVDataResource > > m_hMoodFile; // 0x280	
	// MPropertyFriendlyName "Actor Name"
	// MPropertyGroupName "Acting"
	CUtlString m_sActorName; // 0x360	
	// MPropertyGroupName "Acting"
	ActorClasses_t m_nActorClass; // 0x368	
};

// Alignment: 10
// Size: 0x40
class CTempRagdollData
{
public:
	float flAutoUnragdollDuration; // 0x0	
	float flUnragdollTimeout; // 0x4	
	CTakeDamageInfo* pInfo; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0010[0x8]; 	// 0x10
public:
	CBaseAnimating* pParentEntity; // 0x18	
	char* pBoneTransformsString; // 0x20	
	int32_t boneAttach; // 0x28	
	int32_t parentBoneAttach; // 0x2c	
	Vector boneOrigin; // 0x30	
	bool m_bInvertOrientation; // 0x3c	
	bool m_bCollideWithNPCClip; // 0x3d	
};

// Alignment: 1
// Size: 0x380
class CAI_PlayerAllyVData : public CAI_BaseActorVData
{
public:
	// MPropertyDescription "Time taken for an ally to regenerate a point of health"
	CSkillFloat m_flRegenTime; // 0x370	
};

// Alignment: 3
// Size: 0x30
class CFlightComponent
{
public:
	CHandle< CAI_DefaultNPC > m_pOuter; // 0x8	
	Vector m_vCurrentVelocity; // 0xc	
	Vector m_vNoiseMod; // 0x18	
};

// Alignment: 3
// Size: 0xc
struct AbilityLOSResult_t
{
public:
	ConditionId_t m_nCondition; // 0x0	
	BodyLocations_t m_nTargetBodyLocation; // 0x4	
	CHandle< CBaseEntity > m_hOccluderEntity; // 0x8	
};

// Alignment: 4
// Size: 0x50
struct AWS_NPCAbilityInfo_t
{
public:
	int32_t m_nLastGatheredAtTick; // 0x0	
	AbilityLOSResult_t m_nLastGatherLOSResult; // 0x4	
	CAI_ScheduleBits m_nLastGatherConditions; // 0x10	
	CAI_ScheduleBits m_nNonGatherConditions; // 0x30	
};

// Alignment: 3
// Size: 0x18
struct AWS_AbilityUsageData_t
{
public:
	// MNetworkEnable
	CUtlStringToken m_nAbilityID; // 0x8	
	AbilityPathType_t m_PathTypeToBeUsed; // 0xc	
	bool m_bRestrictToDuringResolution; // 0x10	
};

// Alignment: 23
// Size: 0x110
class CAI_AbilityServices : public CAI_Component
{
public:
	int32_t m_nBatchAbilityScopeCount; // 0x18	
	bool m_bAbilitiesChangedInBatchScope; // 0x1c	
private:
	[[maybe_unused]] uint8_t __pad001d[0x3]; 	// 0x1d
public:
	float m_flNextAbilityUseTime; // 0x20	
	WeaponStateMode_t m_nWeaponStateMode; // 0x24	
	DesiredWeaponState_t m_nDesiredWeaponState; // 0x28	
	InternalWeaponState_t m_nInternalWeaponState; // 0x2c	
	bool m_bLookForBetterAbilities; // 0x30	
private:
	[[maybe_unused]] uint8_t __pad0031[0x3]; 	// 0x31
public:
	float m_flNextHeldAbilitySearchTime; // 0x34	
	CUtlVector< AWS_NPCAbilityInfo_t > m_vecAbilityInfo; // 0x38	
	CHandle< CBaseNPCAbility > m_hUnholsteringWeapon; // 0x50	
	bool m_bDisableAllAbilities; // 0x54	
	bool m_bPerformAimRefinement; // 0x55	
private:
	[[maybe_unused]] uint8_t __pad0056[0x2]; 	// 0x56
public:
	float m_flAimRefinement; // 0x58	
	float m_flAimRefinementDecayTarget; // 0x5c	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseNPCAbility > > m_vecAbilities; // 0x60	
	// MNetworkEnable
	AWS_AbilityUsageData_t m_AbilityToBeUsed; // 0x78	
	uint32_t m_nAbilityCategorySupportedMask; // 0x90	
	uint32_t m_nQueriedAbilityCategorySupportedMask; // 0x94	
	NPCAbilityTarget_t m_TargetToBeUsed; // 0x98	
	CUtlStringToken m_nAbilityIDPreviouslyUsed; // 0xc0	
private:
	[[maybe_unused]] uint8_t __pad00c4[0x4]; 	// 0xc4
public:
	NPCAbilityTarget_t m_TargetPreviouslyUsed; // 0xc8	
	// MNetworkEnable
	AWS_AbilityUsageData_t m_AbilityBeingUsed; // 0xf0	
	// MNetworkEnable
	bool m_bInAbilityUseSchedule; // 0x108	
};

// Alignment: 4
// Size: 0x40
class CAI_BodyLocationCache
{
public:
	CHandle< CAI_DefaultNPC > m_hOwner; // 0x0	
	CHandle< CBaseModelEntity > m_hAssociatedEntity; // 0x4	
	bool m_bOwnsBodyLocationDef; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0009[0x7]; 	// 0x9
public:
	BodyLocationListVData_t* m_pBodyLocationDef; // 0x10	
};

// Alignment: 2
// Size: 0x8
struct ActiveScriptedCommand_t
{
public:
	CHandle< CAI_ScriptedBase > m_hCommand; // 0x0	
	CHandle< CBaseEntity > m_hTarget; // 0x4	
};

// Alignment: 11
// Size: 0x80
class CAI_ChoreoServices : public CAI_Component
{
public:
	CHandle< CScriptedSequence > m_hCine; // 0x20	
	IChoreoServices::ScriptState_t m_scriptState; // 0x24	
	ScriptedOnDeath_t m_scriptedOnDeathBehavior; // 0x28	
private:
	[[maybe_unused]] uint8_t __pad002c[0x4]; 	// 0x2c
public:
	CUtlVector< ActiveScriptedCommand_t > m_vecActiveScriptedCommands; // 0x30	
	bool m_abResumedPriorities[2]; // 0x48	
	bool m_bInAnimGraphChoreo; // 0x4a	
private:
	[[maybe_unused]] uint8_t __pad004b[0x1]; 	// 0x4b
public:
	FacingMode m_nPriorFacingMode; // 0x4c	
	bool m_bInChoreo; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0051[0x3]; 	// 0x51
public:
	float m_flSceneTime; // 0x54	
private:
	[[maybe_unused]] uint8_t __pad0058[0x20]; 	// 0x58
public:
	CHandle< CBaseModelEntity > m_hChoreoPhysProxy; // 0x78	
	float m_flChoreoPhysProxyAttachOffset; // 0x7c	
	static CUtlSymbolLarge &Get_SCHED_SCENE_GENERIC(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_WAIT_FOR_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_SCRIPTED_WALK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_SCRIPTED_RUN(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_SCRIPTED_CUSTOM_MOVE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_SCRIPTED_WAIT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[5]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_SCRIPTED_FACE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[6]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_PLAY_SCENE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[7]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SCRIPT_WALK_TO_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[8]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SCRIPT_RUN_TO_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[9]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SCRIPT_CUSTOM_MOVE_TO_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[10]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_WAIT_FOR_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[11]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_PUSH_SCRIPT_ARRIVAL_ACTIVITY(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[12]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_PLAY_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[13]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_PLAY_SCRIPT_POST_IDLE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[14]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_ENABLE_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[15]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_PLANT_ON_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[16]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FACE_SCRIPT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_ChoreoServices")->m_static_fields[17]->m_instance);};
};

// Alignment: 2
// Size: 0x10
struct ScriptedNPCInteraction_Phases_t
{
public:
	CUtlSymbolLarge iszSequence; // 0x0	
	int32_t iActivity; // 0x8	
};

// Alignment: 15
// Size: 0xc8
struct ScriptedNPCInteraction_t
{
public:
	CUtlSymbolLarge iszInteractionName; // 0x0	
	int32_t iFlags; // 0x8	
	int32_t iTriggerMethod; // 0xc	
	int32_t iLoopBreakTriggerMethod; // 0x10	
	Vector vecRelativeOrigin; // 0x14	
	QAngle angRelativeAngles; // 0x20	
	Vector vecRelativeVelocity; // 0x2c	
	float flDelay; // 0x38	
	float flDistSqr; // 0x3c	
	CUtlSymbolLarge iszMyWeapon; // 0x40	
	CUtlSymbolLarge iszTheirWeapon; // 0x48	
	ScriptedNPCInteraction_Phases_t sPhases[3]; // 0x50	
	VMatrix matDesiredLocalToWorld; // 0x80	
	bool bValidOnCurrentEnemy; // 0xc0	
private:
	[[maybe_unused]] uint8_t __pad00c1[0x3]; 	// 0xc1
public:
	float flNextAttemptTime; // 0xc4	
};

// Alignment: 10
// Size: 0x60
class CAI_DynamicInteractions : public CAI_Component
{
public:
	CHandle< CBaseAnimating > m_hForcedInteractionPartner; // 0x18	
	int32_t m_iInteractionPlaying; // 0x1c	
	Vector m_vecForcedWorldPosition; // 0x20	
	float m_flForcedInteractionTimeout; // 0x2c	
	CHandle< CBaseAnimating > m_hInteractionPartner; // 0x30	
	CHandle< CBaseEntity > m_hLastInteractionTestTarget; // 0x34	
	bool m_bCannotDieDuringInteraction; // 0x38	
private:
	[[maybe_unused]] uint8_t __pad0039[0x3]; 	// 0x39
public:
	int32_t m_iInteractionState; // 0x3c	
	CUtlVector< ScriptedNPCInteraction_t > m_ScriptedInteractions; // 0x40	
	float m_flInteractionYaw; // 0x58	
};

// Alignment: 5
// Size: 0x28
class CAI_StanceServices : public CAI_Component
{
public:
	// MNetworkEnable
	StanceType_t m_nCurrentStance; // 0x18	
	StanceType_t m_nDesiredStance; // 0x1c	
	StanceType_t m_nForcedStance; // 0x20	
	bool m_bStanceCapabilities[2]; // 0x24	
	bool m_bTemporaryDisabledStances[2]; // 0x26	
};

// Alignment: 9
// Size: 0x58
class CAI_AssaultBehavior
{
public:
	CHandle< CAssaultPoint > m_hAssaultPoint; // 0x28	
	CHandle< CRallyPoint > m_hRallyPoint; // 0x2c	
private:
	[[maybe_unused]] uint8_t __pad0030[0x8]; 	// 0x30
public:
	bool m_bHitRallyPoint; // 0x38	
	bool m_bHitAssaultPoint; // 0x39	
	bool m_bDiverting; // 0x3a	
private:
	[[maybe_unused]] uint8_t __pad003b[0x1]; 	// 0x3b
public:
	float m_flLastSawAnEnemyAt; // 0x3c	
	float m_flTimeDeferScheduleSelection; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad0044[0x4]; 	// 0x44
public:
	CUtlSymbolLarge m_AssaultPointName; // 0x48	
	CHandle< CAI_AssaultGoal > m_hAssaultGoal; // 0x50	
	static CUtlSymbolLarge &Get_SCHED_MOVE_TO_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_ASSAULT_FAILED_TO_MOVE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FAIL_MOVE_TO_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_MOVE_TO_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_AT_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_HOLD_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[5]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_HOLD_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[6]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_WAIT_AND_CLEAR(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[7]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_ASSAULT_MOVE_AWAY(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[8]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_CLEAR_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[9]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GET_PATH_TO_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[10]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FACE_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[11]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GET_PATH_TO_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[12]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FACE_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[13]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_HIT_ASSAULT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[14]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_HIT_RALLY_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[15]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_AWAIT_CUE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[16]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_AWAIT_ASSAULT_TIMEOUT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[17]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_ANNOUNCE_CLEAR(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[18]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_WAIT_ASSAULT_DELAY(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[19]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_ASSAULT_MOVE_AWAY_PATH(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[20]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_ASSAULT_DEFER_SCHEDULE_SELECTION(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AssaultBehavior")->m_static_fields[21]->m_instance);};
};

// Alignment: 3
// Size: 0x78
class CAI_FightFromCoverBehavior
{
public:
	CHandle< CAI_FightFromCoverGoal > m_hFightFromCoverGoal; // 0x28	
	CAI_MoveMonitor m_FrontMoveMonitor; // 0x2c	
	CSimpleSimTimer m_FrontTimer; // 0x3c	
	static CUtlSymbolLarge &Get_SCHED_FFC_RUN_TO_HINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FFC_HOLD_COVER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FFC_PEEK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FFC_HOLD_PEEK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FFC_RELOAD(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FFC_ATTACK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[5]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FFC_GET_PATH_TO_HINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[6]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FFC_COVER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[7]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FFC_PEEK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[8]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FFC_ATTACK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[9]->m_instance);};
	static ConditionId_t &Get_COND_FFC_HINT_CHANGE(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FightFromCoverBehavior")->m_static_fields[10]->m_instance);};
};

// Alignment: 23
// Size: 0x128
class CAI_FollowBehavior
{
public:
	CHandle< CBaseEntity > m_hFollowTarget; // 0x28	
private:
	[[maybe_unused]] uint8_t __pad002c[0x38]; 	// 0x2c
public:
	float m_flTimeUpdatedFollowPosition; // 0x64	
	bool m_bFirstFacing; // 0x68	
private:
	[[maybe_unused]] uint8_t __pad0069[0x3]; 	// 0x69
public:
	float m_flTimeFollowTargetVisible; // 0x6c	
	CAI_MoveMonitor m_TargetMonitor; // 0x70	
	bool m_bTargetUnreachable; // 0x80	
	bool m_bFollowNavFailed; // 0x81	
private:
	[[maybe_unused]] uint8_t __pad0082[0x2]; 	// 0x82
public:
	int32_t m_nFailedFollowAttempts; // 0x84	
	float m_flTimeFailFollowStarted; // 0x88	
	Vector m_vFollowMoveAnchor; // 0x8c	
	bool m_bMovingToCover; // 0x98	
private:
	[[maybe_unused]] uint8_t __pad0099[0x3]; 	// 0x99
public:
	float m_flOriginalEnemyDiscardDuration; // 0x9c	
	float m_flOriginalEnemyFreeKnowledgeDuration; // 0xa0	
	float m_SavedDistTooFar; // 0xa4	
	float m_flLastIdleTalk; // 0xa8	
private:
	[[maybe_unused]] uint8_t __pad00ac[0x4]; 	// 0xac
public:
	CRandStopwatch m_FollowDelay; // 0xb0	
	CSimpleSimTimer m_RepathOnFollowTimer; // 0xc8	
	int32_t m_CurrentFollowActivity; // 0xcc	
	CRandSimTimer m_TimeBlockUseWaitPoint; // 0xd0	
	CSimTimer m_TimeCheckForWaitPoint; // 0xdc	
private:
	[[maybe_unused]] uint8_t __pad00e4[0xc]; 	// 0xe4
public:
	CRandSimTimer m_TimeBeforeSpreadFacing; // 0xf0	
	CRandSimTimer m_TimeNextSpreadFacing; // 0xfc	
private:
	[[maybe_unused]] uint8_t __pad0108[0x18]; 	// 0x108
public:
	CHandle< CAI_FollowGoal > m_hFollowGoalEnt; // 0x120	
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_MOVE_AWAY_FAIL(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_MOVE_AWAY_END(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOW(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_IDLE_STAND(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_MOVE_TO_FACE_FOLLOW_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FACE_FOLLOW_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[5]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_COMBAT_FACE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[6]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_GO_TO_WAIT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[7]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_GO_TO_WAIT_POINT_FAIL(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[8]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_FOLLOWER_STAND_AT_WAIT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[9]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_CANT_FOLLOW(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[10]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FACE_FOLLOW_TARGET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[11]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_MOVE_TO_FOLLOW_POSITION(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[12]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GET_PATH_TO_FOLLOW_POSITION(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[13]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SET_FOLLOW_TARGET_MARK(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[14]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_FOLLOWER_FACE_TACTICAL(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[15]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SET_FOLLOW_DELAY(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[16]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GET_PATH_TO_FOLLOW_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[17]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_ARRIVE_AT_FOLLOW_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[18]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_SET_FOLLOW_POINT_STAND_SCHEDULE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[19]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_BEGIN_STAND_AT_WAIT_POINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[20]->m_instance);};
	static ConditionId_t &Get_COND_TARGET_MOVED_FROM_MARK(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[21]->m_instance);};
	static ConditionId_t &Get_COND_FOLLOW_DELAY_EXPIRED(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[22]->m_instance);};
	static ConditionId_t &Get_COND_FOLLOW_TARGET_VISIBLE(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[23]->m_instance);};
	static ConditionId_t &Get_COND_FOLLOW_TARGET_NOT_VISIBLE(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[24]->m_instance);};
	static ConditionId_t &Get_COND_FOLLOW_WAIT_POINT_INVALID(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[25]->m_instance);};
	static ConditionId_t &Get_COND_FOUND_WAIT_POINT(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_FollowBehavior")->m_static_fields[26]->m_instance);};
};

// Alignment: 22
// Size: 0x100
class CAI_LeadBehavior
{
public:
	CHandle< CBaseEntity > m_hSinkImplementor; // 0x68	
	Vector m_goal; // 0x6c	
	float m_goalyaw; // 0x78	
	Vector m_waitpoint; // 0x7c	
	float m_waitdistance; // 0x88	
	float m_leaddistance; // 0x8c	
	float m_retrievedistance; // 0x90	
	float m_successdistance; // 0x94	
	CUtlSymbolLarge m_weaponname; // 0x98	
	bool m_run; // 0xa0	
	bool m_gagleader; // 0xa1	
	bool m_hasspokenstart; // 0xa2	
	bool m_hasspokenarrival; // 0xa3	
	bool m_hasPausedScenes; // 0xa4	
private:
	[[maybe_unused]] uint8_t __pad00a5[0x3]; 	// 0xa5
public:
	float m_flSpeakNextNagTime; // 0xa8	
	float m_flWeaponSafetyTimeOut; // 0xac	
	float m_flForceRetrieveTimeout; // 0xb0	
	float m_flNextLeadIdle; // 0xb4	
	bool m_bInitialAheadTest; // 0xb8	
private:
	[[maybe_unused]] uint8_t __pad00b9[0x3]; 	// 0xb9
public:
	CAI_MoveMonitor m_MoveMonitor; // 0xbc	
private:
	[[maybe_unused]] uint8_t __pad00cc[0x4]; 	// 0xcc
public:
	CRandStopwatch m_LostTimer; // 0xd0	
	CRandStopwatch m_LostLOSTimer; // 0xe8	
	static CUtlSymbolLarge &Get_SCHED_LEAD_PLAYER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_PAUSE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_PAUSE_COMBAT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_RETRIEVE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_RETRIEVE_WAIT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_SUCCEED(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[5]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_AWAIT_SUCCESS(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[6]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_WAITFORPLAYER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[7]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_WAITFORPLAYERIDLE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[8]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_PLAYERNEEDSWEAPON(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[9]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_SPEAK_START(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[10]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_SPEAK_THEN_RETRIEVE_PLAYER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[11]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_LEAD_SPEAK_THEN_LEAD_PLAYER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[12]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GET_PATH_TO_LEAD_GOAL(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[13]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_STOP_LEADING(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[14]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_FACE_GOAL(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[15]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_ARRIVE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[16]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_SUCCEED(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[17]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_GET_PATH_TO_WAITPOINT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[18]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_WAVE_TO_PLAYER(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[19]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_PLAYER_NEEDS_WEAPON(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[20]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_SPEAK_START(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[21]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_MOVE_TO_RANGE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[22]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_RETRIEVE_WAIT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[23]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_LEAD_WALK_PATH(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[24]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_LOST(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[25]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_LAGGING(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[26]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_NOT_LAGGING(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[27]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_VERY_CLOSE(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[28]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_SUCCESS(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[29]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_HAVE_FOLLOWER_LOS(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[30]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_MOVED_FROM_MARK(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[31]->m_instance);};
	static ConditionId_t &Get_COND_LEAD_FOLLOWER_MOVING_TOWARDS_ME(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_LeadBehavior")->m_static_fields[32]->m_instance);};
};

// Alignment: 10
// Size: 0x24
struct AI_StandoffParams_t
{
public:
	AI_HintChangeReaction_t hintChangeReaction; // 0x0	
	bool fCoverOnReload; // 0x4	
	bool fPlayerIsBattleline; // 0x5	
private:
	[[maybe_unused]] uint8_t __pad0006[0x2]; 	// 0x6
public:
	float minTimeShots; // 0x8	
	float maxTimeShots; // 0xc	
	int32_t minShots; // 0x10	
	int32_t maxShots; // 0x14	
	int32_t oddsCover; // 0x18	
	bool fStayAtCover; // 0x1c	
private:
	[[maybe_unused]] uint8_t __pad001d[0x3]; 	// 0x1d
public:
	float flAbandonTimeLimit; // 0x20	
};

// Alignment: 19
// Size: 0xd0
class CAI_StandoffBehavior
{
public:
	bool m_fActive; // 0x28	
	bool m_fTestNoDamage; // 0x29	
private:
	[[maybe_unused]] uint8_t __pad002a[0x2]; 	// 0x2a
public:
	Vector m_vecStandoffGoalPosition; // 0x2c	
	AI_Posture_t m_posture; // 0x38	
	AI_StandoffParams_t m_params; // 0x3c	
	CHandle< CBaseEntity > m_hStandoffGoal; // 0x60	
	bool m_fTakeCover; // 0x64	
private:
	[[maybe_unused]] uint8_t __pad0065[0x3]; 	// 0x65
public:
	float m_SavedDistTooFar; // 0x68	
	bool m_fForceNewEnemy; // 0x6c	
private:
	[[maybe_unused]] uint8_t __pad006d[0x3]; 	// 0x6d
public:
	CAI_MoveMonitor m_PlayerMoveMonitor; // 0x70	
	CSimTimer m_TimeForceCoverHint; // 0x80	
	CSimTimer m_TimePreventForceNewEnemy; // 0x88	
	CRandSimTimer m_RandomCoverChangeTimer; // 0x90	
	int32_t m_nSavedMinShots; // 0x9c	
	int32_t m_nSavedMaxShots; // 0xa0	
	float m_flSavedMinRest; // 0xa4	
	float m_flSavedMaxRest; // 0xa8	
private:
	[[maybe_unused]] uint8_t __pad00ac[0x1c]; 	// 0xac
public:
	bool m_fIgnoreFronts; // 0xc8	
	bool m_bHasLowCoverActivity; // 0xc9	
	static ConditionId_t &Get_COND_ABANDON_TIME_EXPIRED(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_StandoffBehavior")->m_static_fields[0]->m_instance);};
};

// Alignment: 3
// Size: 0x18
struct NPCAbilityBodyLocationOverride_t
{
public:
	// MPropertyDescription "Body location to inherit from in the owning NPC. If unspecified, the Ability Body Location is used."
	CUtlString m_sOwnerBodyLocationName; // 0x0	
	// MPropertyAttributeEditor "VDataModelAttachment( m_sModelName )"
	CUtlString m_sAttachmentName; // 0x8	
	bool m_bAttachmentIsOnAbilityModel; // 0x10	
};

// Alignment: 1
// Size: 0x4
struct NPCAbilityUseTriggerBase_t
{
public:
	// MPropertyDescription "When triggered, the ability is used"
	GameAnimEventIndex_t m_nAnimEventTrigger; // 0x0	
};

// Alignment: 62
// Size: 0x3b8
class CBaseNPCAbilityVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyDescription "Priority relative to other abilities on this NPC. All abilities will be evaluated, and the highest priority one that passes its evaluation step will be used."
	int32_t m_nPriority; // 0x28	
	// MPropertyDescription "Does this ability operate on the current enemy?"
	// MPropertyGroupName "Evaluating"
	bool m_bAbilityOperatesOnCurrentEnemy; // 0x2c	
	// MPropertyDescription "Must this ability be held (only 1 can be held at a time) to be active?"
	bool m_bMustBeHeld; // 0x2d	
private:
	[[maybe_unused]] uint8_t __pad002e[0x2]; 	// 0x2e
public:
	// MPropertyDescription "Only used for held abilities. Should be the desired value of the 'e_weapon' animgraph variable on this NPC, when it is holding this Ability."
	CUtlString m_sDeployedAnimgraphWeaponEnum; // 0x30	
	// MPropertyDescription "Model to be bonemerged to the parent NPC"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x38	
	// MPropertyDescription "Entity to be bonemerged to the parent NPC"
	// MPropertyGroupName "Visuals"
	CEmbeddedSubclass< CBaseEntity > m_hModelEntity; // 0x118	
	// MPropertyDescription "Allows the ability to override body locations specified in the owner NPC"
	// MPropertyGroupName "Visuals"
	CUtlMap< BodyLocations_t, NPCAbilityBodyLocationOverride_t > m_mapBodyLocationOverrides; // 0x128	
	// MPropertyDescription "Model used by the tools only to populate comboboxes for things like animgraph parameter pickers"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sToolsOnlyOwnerModelName; // 0x148	
	CUtlMap< NPCAbilitySound_t, CSoundEventName > m_mapAbilitySounds; // 0x228	
	CSkillDamage m_damageInfo; // 0x248	
	DamageTypes_t m_nDamageType; // 0x25c	
	CUtlVector< CEmbeddedSubclass< CSteamPalModifier > > m_vecIntrinsicModifiers; // 0x260	
	// MPropertyAttributeEditor "VDataChoice( scripts/ammo.vdata )"
	// MPropertyGroupName "Ammo"
	// MPropertyCustomFGDType
	AmmoIndex_t m_iAmmoType; // 0x278	
private:
	[[maybe_unused]] uint8_t __pad0279[0x3]; 	// 0x279
public:
	// MPropertyDescription "How many bullets this gun can fire before it reloads (0 if no clip)"
	// MPropertyAttributeRange "0 100"
	// MPropertyGroupName "Ammo"
	int32_t m_nMaxAmmo; // 0x27c	
	// MPropertyDescription "If set, and this is a Secondary ability attached to a Primary one, this Ability will require/consume the ammunition of the Primary ability, not its own."
	// MPropertyGroupName "Ammo"
	bool m_bUsePrimaryAbilityAmmo; // 0x280	
private:
	[[maybe_unused]] uint8_t __pad0281[0x3]; 	// 0x281
public:
	// MPropertyGroupName "Range"
	// MPropertyDescription "Min Range. By default, this corresponds both to the range at which the ability will be seeked (for schedule selection) as well as used. You can separately override the 'move to' range to cause the system to attempt to move to use range automatically."
	float m_fMinRange; // 0x284	
	// MPropertyGroupName "Range"
	// MPropertyDescription "Max Range. By default, this corresponds both to the range at which the ability will be seeked (for schedule selection) as well as used. You can separately override the 'move to' range to cause the system to attempt to move to use range automatically."
	float m_fMaxRange; // 0x288	
	// MPropertyGroupName "Range"
	float m_fMinAdvanceToRange; // 0x28c	
	// MPropertyGroupName "Range"
	// MPropertyDescription "Min Range to move to before using the ability ( <0 on both min + max disables move to )"
	float m_flMinMoveToRange; // 0x290	
	// MPropertyGroupName "Range"
	// MPropertyDescription "Max Range to move to before using the ability ( <0 on both min + max disables move to )"
	float m_flMaxMoveToRange; // 0x294	
	// MPropertyDescription "When cooling down yourself, or squadmates, if this name is specified, it will cool down all abilities with the same scope name. Useful to put all grenade throws on a shared cooldown for example."
	// MPropertyGroupName "Cooldown"
	CUtlString m_sSharedCooldownName; // 0x298	
	// MPropertyDescription "The amount of time after using this ability before it can be used again."
	// MPropertyGroupName "Cooldown"
	CRangeFloat m_flCooldownDuration; // 0x2a0	
	// MPropertyDescription "If set, use of this ability will also cause squad mates to delay their usage of this same ability."
	// MPropertyGroupName "Cooldown"
	CRangeFloat m_flCooldownDurationSquadMates; // 0x2a8	
	// MPropertyDescription "Should this ability start on cooldown?"
	// MPropertyGroupName "Cooldown"
	bool m_bStartOnCooldown; // 0x2b0	
private:
	[[maybe_unused]] uint8_t __pad02b1[0x3]; 	// 0x2b1
public:
	// MPropertyDescription "The amount of time after using this ability before the NPC is allowed to use *any* of its abilities."
	// MPropertyGroupName "Cooldown"
	CRangeFloat m_flAttackDelay; // 0x2b4	
	// MPropertyDescription "Can this ability interrupt other schedules?"
	// MPropertyGroupName "Evaluating"
	bool m_bCanInterruptSchedules; // 0x2bc	
	// MPropertyDescription "Should this ability attempt to suggest a schedule how to get into position in order to use it? An NPC can only seek to get one ability usable at a time."
	// MPropertyGroupName "Evaluating"
	bool m_bShouldSeekToBeUsable; // 0x2bd	
private:
	[[maybe_unused]] uint8_t __pad02be[0x2]; 	// 0x2be
public:
	// MPropertyDescription "If the ability usage evaluation indicates it cannot be used, this is the delay before the ability can check again."
	// MPropertyGroupName "Evaluating"
	CRangeFloat m_flEvaluationDelay; // 0x2c0	
	// MPropertyDescription "Body location on the owning NPC to use for gathering LOS conditions from"
	// MPropertyGroupName "Evaluating"
	BodyLocations_t m_nLOSTestLocation; // 0x2c8	
	// MPropertyDescription "Sets whether or not the owner of this ability is required to have LOS to a target to be able to use the ability. If it does, the ability won't attempt to gather conditions if the owner doesn't have LOS to the target."
	// MPropertyGroupName "Evaluating"
	bool m_bRequiresOwnerHasLOS; // 0x2cc	
private:
	[[maybe_unused]] uint8_t __pad02cd[0x3]; 	// 0x2cd
public:
	// MPropertyDescription "The enemy location that this ability will use when gathering conditions to determine whether or not it can be performed. Last Seen Position is the last place we saw our enemy. Last Known Position is updated for a short time after lose sight of our enemy. So if our enemy ran around a corner, Last Seen Position would be right before they vanished around the corner, and Last Known Position would be around the corner and out of sight."
	// MPropertyGroupName "Evaluating"
	TargetOriginType_t m_nGatherCondEnemyOriginType; // 0x2d0	
	// MPropertyDescription "What angle relative to the eyes direction does the target have to be in to use the ability?"
	// MPropertyGroupName "Evaluating"
	// MPropertyAttributeRange "0 360"
	float m_flFacingAngle; // 0x2d4	
	// MPropertyDescription "The name of the first squad slot in a range of squad slots, one of which must be claimable to use this ability."
	// MPropertyGroupName "Evaluating"
	SquadSlotId_t m_nSquadSlotRangeMin; // 0x2d8	
	// MPropertyDescription "The name of the last squad slot in a range of squad slots, one of which must be claimable to use this ability. If this is left blank, it'll be considered as matching the 'Squad Slot Range Min', meaning the ability will use a single squad slot."
	// MPropertyGroupName "Evaluating"
	SquadSlotId_t m_nSquadSlotRangeMax; // 0x2dc	
	// MPropertyDescription "Only usable if there aren't any squad mates within this range of our enemy target. Useful for preventing explosive attacks from damaging squad mates."
	// MPropertyGroupName "Evaluating"
	float m_flMinDistToSquadMates; // 0x2e0	
private:
	[[maybe_unused]] uint8_t __pad02e4[0x4]; 	// 0x2e4
public:
	// MPropertyFriendlyName "Pre-Attack Animgraph Parameter"
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph before it performs this attack, if it's not set already. If it's not set, it will be set, and the NPC will wait for the 'Pre-Attack Animgraph Finish Tag' to be fired by the animgraph before continuing."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphParamPre; // 0x2e8	
	// MPropertyFriendlyName "Pre-Attack Animgraph Finish Tag"
	// MPropertyDescription "The animgraph status tag that will be set by the animgraph when it has finished performing the 'Pre-Attack Animgraph Parameter' step."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlString m_sAnimgraphFinishTagPre; // 0x2f0	
	// MPropertyDescription "Optional amount of time the NPC waits after performing the pre-attack phase, before continuing its AI."
	// MPropertyGroupName "Animation"
	CRangeFloat m_flPreAbilityUseWait; // 0x2f8	
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph when it performs this attack."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphParam; // 0x300	
	// MPropertyDescription "The animgraph status tag that will be waited for by the NPC when it has finished performing the attack."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlString m_sAnimgraphFinishTag; // 0x308	
	// MPropertyFriendlyName "Post-Attack Animgraph Parameter"
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph after it performs this attack."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphParamPost; // 0x310	
	// MPropertyFriendlyName "Post-Attack Animgraph Finish Tag"
	// MPropertyDescription "The animgraph status tag that will be waited for by the NPC when it has finished performing the Post Attack animation step."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlString m_sAnimgraphFinishTagPost; // 0x318	
	// MPropertyDescription "Is the anim graph capable of auto-repeating the attack if the ability still thinks it's valid to attack? Note auto-repeating will not trigger cooldowns."
	// MPropertyGroupName "Animation"
	bool m_bCanAutoRepeat; // 0x320	
private:
	[[maybe_unused]] uint8_t __pad0321[0x3]; 	// 0x321
public:
	// MPropertyDescription "Optional amount of time the NPC waits after attacking before continuing its AI."
	// MPropertyGroupName "Animation"
	CRangeFloat m_flPostAbilityUseWait; // 0x324	
	// MPropertyDescription "When triggered, it causes the ability to run ability-specific pre-triggering code.  Used for two-stage hits (like a leap or spot where the attack commits to a direction before it's actually performed)."
	// MPropertyGroupName "Animation"
	GameAnimEventIndex_t m_nAnimEventSetup; // 0x32c	
	// MPropertyDescription "When triggered, the ability is used"
	// MPropertyGroupName "Animation"
	GameAnimEventIndex_t m_nAnimEventTrigger; // 0x330	
	// MPropertyFriendlyName "Enemy Location To Target When Performing"
	// MPropertyDescription "The enemy location that this ability will target when performing the ability. Last Seen Position is the last place we saw our enemy. Last Known Position is updated for a short time after lose sight of our enemy. So if our enemy ran around a corner, Last Seen Position would be right before they vanished around the corner, and Last Known Position would be around the corner and out of sight."
	// MPropertyGroupName "Using"
	TargetOriginType_t m_nUsageCondEnemyOriginType; // 0x334	
	// MPropertyDescription "When firing at the player, is this weapon allowed to miss and hit interesting targets nearby, for visual flair?"
	// MPropertyGroupName "Using"
	bool m_bAllowedToMiss; // 0x338	
	// MPropertyDescription "If an NPC uses this ability while moving, should the usage be aborted if the NPC finishes the movement?"
	// MPropertyGroupName "Using"
	bool m_bAbortUsageOnMoveFinish; // 0x339	
	// MPropertyGroupName "Using"
	// MPropertyDescription "Is the NPC allowed to do displacement during non-interrupt staggers while performing this ability? Generally only true for attacking abilities."
	bool m_bAllowFlinchDisplacementDuringUsage; // 0x33a	
private:
	[[maybe_unused]] uint8_t __pad033b[0x5]; 	// 0x33b
public:
	// MPropertyGroupName "Using"
	// MPropertyDescription "A modifier that will be added to our NPC when it starts using this ability, and removed once it finishes."
	CEmbeddedSubclass< CBaseModifier > m_OwnerModifierWhileUsing; // 0x340	
	// MPropertyGroupName "Using"
	// MPropertyDescription "A modifier that will be added to our NPC when it finishes using this ability."
	CEmbeddedSubclass< CBaseModifier > m_OwnerModifierAfterUsage; // 0x350	
	// MPropertyGroupName "Using"
	// MPropertyDescription "A modifier that will be added to our NPC whenever the ability trigger occurs."
	CEmbeddedSubclass< CBaseModifier > m_OwnerModifierOnTrigger; // 0x360	
	// MPropertyDescription "Only used for held abilities. Never drop this ability, always immediately remove it instead."
	// MPropertyGroupName "Drop"
	bool m_bDestroyInsteadOfDrop; // 0x370	
	// MPropertyDescription "Always Drop this ability."
	// MPropertyGroupName "Drop"
	bool m_bAlwaysDrop; // 0x371	
	// MPropertyGroupName "Drop"
	bool m_bAddRandomDropVelocity; // 0x372	
private:
	[[maybe_unused]] uint8_t __pad0373[0x5]; 	// 0x373
public:
	// MPropertyGroupName "Drop"
	CUtlVector< NPCAbilityDropBehavior_t > m_vecDropBehaviors; // 0x378	
	// MPropertyGroupName "Drop"
	CUtlVector< NPCAbilityPickupBehavior_t > m_vecPickupBehaviors; // 0x390	
	// MPropertyDescription "When pathing to the target, range tolerance"
	// MPropertyGroupName "Evaluating"
	float m_flRangeTolerance; // 0x3a8	
	// MPropertyDescription "When building a path to the target, avoid our enemy by this distance"
	float m_flEnemyPathAvoidance; // 0x3ac	
	// MPropertyDescription "Time to hold unreachable targets before reevaluating"
	float m_flTargetEntityUnreachableTimeout; // 0x3b0	
	// MPropertyDescription "Should this ability be visible when other NPCs ask this ability's NPC what it's capable of?"
	bool m_bIncludeInNPCsCapabilityQueries; // 0x3b4	
};

// Alignment: 2
// Size: 0x120
class CNPCAbilityModelVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyAttributeEditor "AssetBrowse( vmdl )"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	CUtlVector< CEmbeddedSubclass< CSteamPalModifier > > m_vecIntrinsicModifiers; // 0x108	
};

// Alignment: 1
// Size: 0x3c8
class CNPCAbilityAddModifierVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyFriendlyName "Modifier VData: Modifier to Apply to Caster"
	CEmbeddedSubclass< CBaseModifier > m_Modifier; // 0x3b8	
};

// Alignment: 1
// Size: 0x3c0
class CNPCAbilityRemoveModifierVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyFriendlyName "Modifier to Remove"
	CUtlString m_sRemoveModifier; // 0x3b8	
};

// Alignment: 3
// Size: 0x20
struct MeleeAttackUseTrigger_t : public NPCAbilityUseTriggerBase_t
{
public:
	// MPropertyDescription "The view angle punch applied to the player when they receive this hit. Angle is specifed as Pitch / Yaw / Roll."
	QAngle m_angViewPunch; // 0x4	
	// MPropertyDescription "Force applied to the player when they receive this hit. X is the push back, and Y is the push to the side, based on the attacker's facing."
	Vector m_vecShoveForce; // 0x10	
	// MPropertyDescription "MELEE Range of this hit. Generally should remain within the evaluation Min/Max ranges, unless you know the animation significantly moves the NPC before this hit occurs."
	float m_flRange; // 0x1c	
};

// Alignment: 7
// Size: 0x418
class CNPCAbilityMeleeAttackVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyFriendlyName "Hit Triggers"
	// MPropertyGroupName "Animation"
	CUtlVector< MeleeAttackUseTrigger_t > m_vecTriggers; // 0x3b8	
	// MPropertyGroupName "Evaluating"
	ENPCAbilityMeleeAttackEvaluationTest m_EvaluationTest; // 0x3d0	
	// MPropertyGroupName "Evaluating"
	Vector m_vecEvaluatingMeleeAttackMins; // 0x3d4	
	// MPropertyGroupName "Evaluating"
	Vector m_vecEvaluatingMeleeAttackMaxs; // 0x3e0	
	// MPropertyGroupName "Using"
	Vector m_vecUsingMeleeAttackMins; // 0x3ec	
	// MPropertyGroupName "Using"
	Vector m_vecUsingMeleeAttackMaxs; // 0x3f8	
private:
	[[maybe_unused]] uint8_t __pad0404[0x4]; 	// 0x404
public:
	// MPropertyGroupName "Using"
	CEmbeddedSubclass< CBaseModifier > m_ModifierOnHit; // 0x408	
};

// Alignment: 1
// Size: 0x8
class CRangeInt
{
public:
	int32_t m_pValue[2]; // 0x0	
};

// Alignment: 8
// Size: 0x5a0
class CNPCWeaponHitscanVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyDescription "Effect when firing this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szMuzzleFlashParticle; // 0x3b8	
	// MPropertyDescription "Effect to actually fire into the world from this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szTracerParticle; // 0x498	
	// MPropertyGroupName "Using"
	CRangeInt m_nBurstSize; // 0x578	
	// MPropertyGroupName "Using"
	Vector m_vecBulletSpreadCone; // 0x580	
	// MPropertyGroupName "Using"
	float m_flSpreadBias; // 0x58c	
	// MPropertyGroupName "Using"
	int32_t m_nPellets; // 0x590	
	// MPropertyDescription "When calculating the aim spread, should this ability apply the current aim refinement value of the wielding NPC?"
	// MPropertyGroupName "Using"
	bool m_bApplyAimRefinement; // 0x594	
private:
	[[maybe_unused]] uint8_t __pad0595[0x3]; 	// 0x595
public:
	// MPropertyGroupName "Using"
	int32_t m_nPowerCostPerShot; // 0x598	
};

// Alignment: 4
// Size: 0x20
struct HitscanGatherData_t
{
public:
	CBitVec< 2 > m_FiringOccludedHere; // 0x0	
	Vector m_vecFiringAtPos; // 0x4	
	Vector m_vecFiringTargetPos; // 0x10	
	bool m_bWeaponFireOccludedLastTime; // 0x1c	
};

// Alignment: 28
// Size: 0xc0
class CBaseAchievement
{
public:
	char* m_pszName; // 0x18	
	int32_t m_iAchievementID; // 0x20	
	int32_t m_iFlags; // 0x24	
	int32_t m_iGoal; // 0x28	
	int32_t m_iProgressMsgIncrement; // 0x2c	
	int32_t m_iProgressMsgMinimum; // 0x30	
	int32_t m_iPointValue; // 0x34	
	bool m_bHideUntilAchieved; // 0x38	
	bool m_bStoreProgressInSteam; // 0x39	
private:
	[[maybe_unused]] uint8_t __pad003a[0x6]; 	// 0x3a
public:
	char* m_pInflictorClassNameFilter; // 0x40	
	char* m_pInflictorEntityNameFilter; // 0x48	
	char* m_pVictimClassNameFilter; // 0x50	
	char* m_pAttackerClassNameFilter; // 0x58	
	char* m_pMapNameFilter; // 0x60	
	char* m_pGameDirFilter; // 0x68	
	char** m_pszComponentNames; // 0x70	
	char** m_pszComponentDisplayNames; // 0x78	
	int32_t m_iNumComponents; // 0x80	
private:
	[[maybe_unused]] uint8_t __pad0084[0x4]; 	// 0x84
public:
	char* m_pszComponentPrefix; // 0x88	
	int32_t m_iComponentPrefixLen; // 0x90	
	bool m_bAchieved; // 0x94	
private:
	[[maybe_unused]] uint8_t __pad0095[0x3]; 	// 0x95
public:
	int32_t m_iCount; // 0x98	
	int32_t m_iProgressShown; // 0x9c	
	uint64_t m_iComponentBits; // 0xa0	
private:
	[[maybe_unused]] uint8_t __pad00a8[0x8]; 	// 0xa8
public:
	int32_t m_nUserSlot; // 0xb0	
	int32_t m_iDisplayOrder; // 0xb4	
	bool m_bShowOnHUD; // 0xb8	
private:
	[[maybe_unused]] uint8_t __pad00b9[0x3]; 	// 0xb9
public:
	int32_t m_iAssetAwardID; // 0xbc	
};

// Alignment: 2
// Size: 0xc8
class CFailableAchievement : public CBaseAchievement
{
public:
	bool m_bActivated; // 0xc0	
	bool m_bFailed; // 0xc1	
};

// Alignment: 1
// Size: 0x2
struct ModifierQueuedRefreshHandle_t
{
public:
	uint16_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 5
// Size: 0x1d8
struct ModifierScriptValue_t
{
public:
	EModifierValue m_eModifierValue; // 0x0	
	EModifierScriptVariantType m_eType; // 0x4	
	// MPropertySuppressExpr "m_eType != MODIFIER_SCRIPT_VARIANT_MODIFIER_FLOAT"
	CModifierLevelFloat m_value; // 0x8	
	// MPropertySuppressExpr "m_eType != MODIFIER_SCRIPT_VARIANT_MODEL"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelValue; // 0x18	
	// MPropertySuppressExpr "m_eType != MODIFIER_SCRIPT_VARIANT_PARTICLE"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sParticleValue; // 0xf8	
};

// Alignment: 2
// Size: 0x20
struct ModifierScriptedEventHandler_t
{
public:
	EModifierScriptedEvent m_eEvent; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad000c[0x4]; 	// 0xc
public:
	CEmbeddedSubclassGeneric< 4 > m_sModifierToAdd; // 0x10	
};

// Alignment: 2
// Size: 0x18
struct ModifierRenderAttribute_t
{
public:
	CUtlString m_sAttribute; // 0x0	
	Vector4D m_vValues; // 0x8	
};

// Alignment: 4
// Size: 0x8
struct ModifierTrackedParticle_t
{
public:
	ParticleIndex_t m_nParticleIndex; // 0x0	
	bool m_bDestroyImmediately; // 0x4	
	bool m_bStatusEffect; // 0x5	
	int16_t m_nStatusEffectPriority; // 0x6	
};

// Alignment: 2
// Size: 0x20
struct ModifierTrackedGraphParameter_t
{
public:
	CUtlString m_sParamName; // 0x0	
	CAnimVariant m_restoreValue; // 0x8	
};

// Alignment: 0
// Size: 0x8
struct ModifierTrackedSound_t
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 2
// Size: 0x10
struct ModifierTrackedBodyGroup_t
{
public:
	CUtlString m_strBodygroupName; // 0x0	
	int32_t m_nRestoreValue; // 0x8	
};

// Alignment: 19
// Size: 0x390
class CModifierVData : public CEntitySubclassVDataBase
{
public:
	CModifierLevelFloat m_flDuration; // 0x28	
	// MPropertyGroupName "Visuals"
	// MPropertyDescription "Particle system to attach to the parent of the modifier"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_strParticleEffect; // 0x38	
	// MPropertyGroupName "Visuals"
	// MPropertyDescription "Status Effect to apply to the parent of the modifier"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_strParticleStatusEffect; // 0x118	
	// MPropertyGroupName "Visuals"
	// MPropertyDescription "Screen-space particle system to create if the parent of the modifier is the local player"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_strScreenParticleEffect; // 0x1f8	
	// MPropertyGroupName "Visuals"
	// MPropertyDescription "Priority of this status effect relative to others"
	int32_t m_nStatusEffectPriority; // 0x2d8	
private:
	[[maybe_unused]] uint8_t __pad02dc[0x4]; 	// 0x2dc
public:
	// MPropertyGroupName "Visuals"
	CUtlVector< ModifierRenderAttribute_t > m_vecRenderAttributes; // 0x2e0	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sStartSound; // 0x2f8	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sAmbientLoopingSound; // 0x308	
	// MPropertyGroupName "Sounds"
	ModifierSoundRecipients_t m_nAmbientLoopingSoundRecipients; // 0x318	
private:
	[[maybe_unused]] uint8_t __pad031c[0x4]; 	// 0x31c
public:
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sEndSound; // 0x320	
	// MPropertyGroupName "Scripted Settings"
	CBitVecEnum< EModifierState > m_nEnabledStateMask; // 0x330	
	// MPropertyGroupName "Scripted Settings"
	CBitVecEnum< EModifierState > m_nDisabledStateMask; // 0x334	
	// MPropertyGroupName "Scripted Settings"
	ModifierAttribute_t m_nAttributes; // 0x338	
private:
	[[maybe_unused]] uint8_t __pad033c[0x4]; 	// 0x33c
public:
	// MPropertyGroupName "Scripted Settings"
	// MPropertyDescription "Scripted Modifier Values"
	CUtlVector< ModifierScriptValue_t > m_vecScriptValues; // 0x340	
	// MPropertyGroupName "Scripted Settings"
	// MPropertyDescription "Scripted Event Handlers"
	CUtlVector< ModifierScriptedEventHandler_t > m_vecScriptEventHandlers; // 0x358	
	ModifierDisableGroup_t m_nDisableGroupsMask; // 0x370	
	// MPropertyDescription "When set, the modifier only provides data to requests made directly to the attached entity and not to other modifier properties that the owner provides to."
	bool m_bPrivateAccess; // 0x374	
	// MPropertyDescription "When set, the modifier will not be visible to UI or visible modifier list."
	bool m_bIsHidden; // 0x375	
private:
	[[maybe_unused]] uint8_t __pad0376[0x2]; 	// 0x376
public:
	// MPropertyDescription "When to consider the modifier a debuff."
	ModifierDebuffType_t m_eDebuffType; // 0x378	
};

// Alignment: 1
// Size: 0x4
struct ModifierSerialNumber_t
{
public:
	int32_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 3
// Size: 0x3b8
class CModifierVData_BaseAura : public CModifierVData
{
public:
	CModifierLevelFloat m_flAuraRadius; // 0x390	
	int32_t m_nAmbientParticleRadiusControlPoint; // 0x3a0	
private:
	[[maybe_unused]] uint8_t __pad03a4[0x4]; 	// 0x3a4
public:
	// MPropertyDescription "Aura - Modifier to Apply"
	// MPropertyFriendlyName "Modifier Provided By Aura"
	CEmbeddedSubclass< CBaseModifier > m_modifierProvidedByAura; // 0x3a8	
};

// Alignment: 1
// Size: 0x2
struct ModifierPropRuntimeHandle_t
{
public:
	uint16_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 10
// Size: 0xc8
class CModifierProperty
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x8	
	CHandle< CBaseEntity > m_hOwner; // 0x20	
private:
	[[maybe_unused]] uint8_t __pad0024[0x6a]; 	// 0x24
public:
	uint8_t m_nProviderVisitedFlags; // 0x8e	
	bool m_bModifierStatesDirty; // 0x8f	
	int8_t m_iLockRefCount; // 0x90	
private:
	[[maybe_unused]] uint8_t __pad0091[0x1]; 	// 0x91
public:
	ModifierPropRuntimeHandle_t m_hHandle; // 0x92	
	uint16_t m_nBroadcastEventListenerMask; // 0x94	
private:
	[[maybe_unused]] uint8_t __pad0096[0xa]; 	// 0x96
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseEntity > > m_vecProviders; // 0xa0	
	// MNetworkEnable
	uint32_t m_nDisabledGroups; // 0xb8	
	// MNetworkEnable
	// MNetworkChangeCallback "modifierStatesChanged"
	uint32_t m_bvEnabledStateMask[1]; // 0xbc	
};

// Alignment: 1
// Size: 0x4
struct ModifierRuntimeHandle_t
{
public:
	uint32_t m_nBoxedTypeSafeInt; // 0x0	
};

// Alignment: 1
// Size: 0x18
class CModifierHandleBase
{
public:
	// MNetworkEnable
	// MNetworkSerializer "modifier_handle"
	uint64_t m_hStableHandle; // 0x8	
};

// Alignment: 20
// Size: 0x80
class CBaseModifier
{
public:
	ModifierSerialNumber_t m_nSerialNumber; // 0x24	
	float m_flLastAppliedTime; // 0x28	
	float m_flDuration; // 0x2c	
	CHandle< CBaseEntity > m_hCaster; // 0x30	
	CHandle< CBaseEntity > m_hAbility; // 0x34	
	CModifierHandleBase m_hAuraProvider; // 0x38	
	ModifierQueuedRefreshHandle_t m_nQueuedModifierRefreshHandle; // 0x50	
	uint8_t m_iAttributes; // 0x52	
	uint8_t m_iTeam; // 0x53	
	int16_t m_iStackCount; // 0x54	
	int16_t m_iMaxStackCount; // 0x56	
	uint8_t m_eDestroyReason; // 0x58	
	bool m_bDisabled; // 0x59	
private:
	[[maybe_unused]] uint8_t __pad005a[0x2]; 	// 0x5a
public:
	float m_flPreviousTick; // 0x5c	
	float m_flThinkInterval; // 0x60	
	float m_flThinkIntervalStartTime; // 0x64	
	float m_flTimeScale; // 0x68	
private:
	[[maybe_unused]] uint8_t __pad006c[0x4]; 	// 0x6c
public:
	CUtlVector< IModifierTrackedObject* >* m_pVecTrackedObjects; // 0x70	
	ModifierRuntimeHandle_t m_hModifierListHandle; // 0x78	
	int32_t m_iStringIndex; // 0x7c	
};

// Alignment: 1
// Size: 0x18
struct ModifierVariant_t
{
public:
	ModifierVariantType_t m_eType; // 0x0	
};

// Alignment: 0
// Size: 0x8
class IModifierTrackedObject
{
public:
	uint8_t __pad0000[0x8]; 	// @note: autoaligned
};

// Alignment: 4
// Size: 0x198
class CSteamPalPlayer_CameraServices : public CPlayer_CameraServices
{
public:
	// MNetworkEnable
	bool m_bViewFrozen; // 0x178	
private:
	[[maybe_unused]] uint8_t __pad0179[0x3]; 	// 0x179
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hCameraTarget; // 0x17c	
	// MNetworkEnable
	Vector m_vMoveOffset; // 0x180	
	// MNetworkEnable
	QAngle m_vLookOffset; // 0x18c	
};

// Alignment: 0
// Size: 0x90
class CSteamPalPlayer_MovementServices : public CPlayer_MovementServices
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0xb8
class CSteamPalGameRules : public CSingleplayRules
{
public:
	bool m_bIsInAscentSection; // 0xb0	
private:
	[[maybe_unused]] uint8_t __pad00b1[0x3]; 	// 0xb1
public:
	CHandle< CBaseEntity > m_hPlayerResource; // 0xb4	
};

// Alignment: 1
// Size: 0x40
class COffscreenParticleHelper
{
public:
	RenderMultisampleType_t m_nMultisampleType; // 0x1c	
};

// Alignment: 0
// Size: 0x80
class CSteamPalModifier : public CBaseModifier
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x80
class CSteamPalModifier_Base : public CSteamPalModifier
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x3b8
class CSteamPalModifierAuraVData : public CModifierVData_BaseAura
{
public:
	// @note: no members available
};

// Alignment: 7
// Size: 0x98
class CSteampal_Turret_ManagerVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sIntroTurretType; // 0x28	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sIntroSmokingTurretType; // 0x38	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sUltraTurretType; // 0x48	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sBadTurretType; // 0x58	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sGoodTurretType; // 0x68	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sAscentTurretType; // 0x78	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sCaveJohnsonTurretType; // 0x88	
};

// Alignment: 4
// Size: 0x20
struct CSteamPal_SequencerTrackDef_t
{
public:
	int32_t m_nStandardNoteHold; // 0x0	
	CUtlString m_sPlayerInputLeftPadNotes; // 0x8	
	CUtlString m_sPlayerInputRightPadNotes; // 0x10	
	CUtlString m_sName; // 0x18	
};

// Alignment: 1
// Size: 0x18
struct CSteamPal_SequencerSequenceDef_t
{
public:
	CUtlVector< CUtlString > m_vMusicTracks; // 0x0	
};

// Alignment: 11
// Size: 0x80
class CSteamPal_SequencerVData : public CEntitySubclassVDataBase
{
public:
	float m_flBPM; // 0x28	
	bool m_bStartPaused; // 0x2c	
private:
	[[maybe_unused]] uint8_t __pad002d[0x3]; 	// 0x2d
public:
	int32_t m_nGridWidth; // 0x30	
	int32_t m_nGridHeight; // 0x34	
	int32_t m_nTestDisplayTrackNum; // 0x38	
	float m_flDebugGridSize; // 0x3c	
	float m_flDebugGridElementGap; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad0044[0x4]; 	// 0x44
public:
	CUtlVector< CSteamPal_SequencerTrackDef_t > m_vTrackDefs; // 0x48	
	CUtlVector< CSteamPal_SequencerSequenceDef_t > m_vIntroSequences; // 0x60	
	bool m_bAutoPlayIntro; // 0x78	
	bool m_bLoopIntroTracks; // 0x79	
};

// Alignment: 8
// Size: 0x138
class CSteamPal_BaseSingingEntity_VData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	CSoundEventName m_sTestToneSound; // 0x108	
	CSoundEventName m_sGreetingSound; // 0x118	
	bool m_bAutoSingTracks; // 0x128	
	bool m_bPlayAnimGraphOnly; // 0x129	
private:
	[[maybe_unused]] uint8_t __pad012a[0x2]; 	// 0x12a
public:
	float m_flBaseMidiNote; // 0x12c	
	float m_flWingAnimateInTime; // 0x130	
	float m_flVolume; // 0x134	
};

// Alignment: 10
// Size: 0xb0
class CSteamPal_NameFormVData : public CEntitySubclassVDataBase
{
public:
	CSkillFloat m_flMaxTimeSayingName; // 0x28	
	CSkillFloat m_flMaxTimeTypingFaceButtons; // 0x38	
	int32_t m_nNumFaceButtonLettersNeededToSucceed; // 0x48	
	CSkillFloat m_flMaxTimeTypingKeyboard; // 0x4c	
	int32_t m_nNumKeyboardLettersNeededToSucceed; // 0x5c	
	CSkillFloat m_flMaxTimeSigningName; // 0x60	
	CSkillFloat m_flTaskTimeAfterUsefulAction; // 0x70	
	// MPropertyAttributeEditor "VDataChoice( scripts/misc.vdata )"
	CSubclassName< 0 > m_sWritingSurfaceToSpawn; // 0x80	
	QAngle m_qWritingSurfaceAttachAngles; // 0x90	
private:
	[[maybe_unused]] uint8_t __pad009c[0x4]; 	// 0x9c
public:
	CSoundEventName m_sDingToneSound; // 0xa0	
};

// Alignment: 4
// Size: 0x118
class CSteamPal_WritingSurfaceVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	Color m_BackgroundColor; // 0x108	
	Color m_WritingColor; // 0x10c	
	float m_flWritingTipSize; // 0x110	
};

// Alignment: 6
// Size: 0x18
struct CSteamPal_Turret_Wing_t
{
public:
	float m_flPitchMin; // 0x0	
	float m_flPitchMax; // 0x4	
	float m_flPitchRate; // 0x8	
	float m_flYawMin; // 0xc	
	float m_flYawMax; // 0x10	
	float m_flYawRate; // 0x14	
};

// Alignment: 36
// Size: 0x5a0
class CSteamPal_TurretVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sMuzzleFlashEffect; // 0x108	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sTracerEffect; // 0x1e8	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sLaserSightEffect; // 0x2c8	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sExplodeEffect; // 0x3a8	
	CSteamPal_Turret_Wing_t m_sLeftWing; // 0x488	
	CSteamPal_Turret_Wing_t m_sRightWing; // 0x4a0	
	Steampal_TurretType_t m_TurretType; // 0x4b8	
private:
	[[maybe_unused]] uint8_t __pad04bc[0x4]; 	// 0x4bc
public:
	CUtlVector< CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > > m_BreakPieces; // 0x4c0	
	CUtlVector< CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > > m_WhiteBreakPieces; // 0x4d8	
	bool m_bTakeOverCamera; // 0x4f0	
	bool m_bSynchedWings; // 0x4f1	
	bool m_bRawAiming; // 0x4f2	
	bool m_bUseInterpolationHack; // 0x4f3	
	float m_flTraceLength; // 0x4f4	
	float m_flXInputExponent; // 0x4f8	
	float m_flYInputExponent; // 0x4fc	
	float m_flAxialDeadZoneX; // 0x500	
	float m_flAxialDeadZoneY; // 0x504	
	float m_flCircularDeadzoneMin; // 0x508	
	float m_flCircularDeadzoneMax; // 0x50c	
	float m_flCircularExponent; // 0x510	
	float m_flWingDeployExplodeThreshold; // 0x514	
	int32_t m_nMaxAmmo; // 0x518	
	float m_flCameraOverShoulderOffset; // 0x51c	
	float m_flCameraOverShoulderFOV; // 0x520	
	bool m_bOnlyValidTargetIfControlledByPlayer; // 0x524	
private:
	[[maybe_unused]] uint8_t __pad0525[0x3]; 	// 0x525
public:
	int32_t m_nHealth; // 0x528	
private:
	[[maybe_unused]] uint8_t __pad052c[0x4]; 	// 0x52c
public:
	CSoundEventName m_sWingOpenSound; // 0x530	
	CSoundEventName m_sWingCloseSound; // 0x540	
	CSoundEventName m_sWingMoveCompleteSound; // 0x550	
	CSoundEventName m_sWingMoveSound; // 0x560	
	Vector m_vDeployingVibration; // 0x570	
	Vector m_vShootingVibration; // 0x57c	
	Vector m_vTakingDamageVibration; // 0x588	
	Vector m_vExplodingVibration; // 0x594	
};

// Alignment: 10
// Size: 0x938
class CSteamPal_Intro_ToiletVData : public CSteamPal_TurretVData
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sBidetWaterEffect; // 0x5a0	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sToiletFlushEffect; // 0x680	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sSmokingToiletSmokeEffect; // 0x760	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sBidetShootingBulletsEffect; // 0x840	
	float m_flTestSpringStrength; // 0x920	
	float m_flTestRequiredDuration; // 0x924	
	float m_flFlushWaitTime; // 0x928	
	float m_flCisternFillDuration; // 0x92c	
	float m_flFlushDuration; // 0x930	
	bool m_bSmoking; // 0x934	
};

// Alignment: 1
// Size: 0x108
class CSteamPal_ToiletTestPanelVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
};

// Alignment: 8
// Size: 0x1f8
struct CSteamPal_Ultra_Toilet_Gun_VData_t
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sMuzzleFlashEffect; // 0x0	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sTracerEffect; // 0xe0	
	CUtlString m_strMuzzleAttachment; // 0x1c0	
	int32_t m_nAmmo; // 0x1c8	
	float m_flRateOfFire; // 0x1cc	
	float m_flDamage; // 0x1d0	
private:
	[[maybe_unused]] uint8_t __pad01d4[0x4]; 	// 0x1d4
public:
	CSoundEventName m_sShootSound; // 0x1d8	
	CSoundEventName m_sEmptySound; // 0x1e8	
};

// Alignment: 12
// Size: 0x1558
class CSteamPal_Ultra_ToiletVData : public CSteamPal_TurretVData
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sUltraModelName; // 0x5a0	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_Minigun; // 0x680	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_SMG; // 0x878	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_AAGun_L1; // 0xa70	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_AAGun_L2; // 0xc68	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_AAGun_R1; // 0xe60	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_AAGun_R2; // 0x1058	
	CSteamPal_Ultra_Toilet_Gun_VData_t m_Rocket; // 0x1250	
	CSoundEventName m_sMinigunWindUpSound; // 0x1448	
	CSoundEventName m_sMinigunWindDownSound; // 0x1458	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sRadarSparksEffect; // 0x1468	
	CSoundEventName m_sRadarSparksSound; // 0x1548	
};

// Alignment: 4
// Size: 0x200
class CSteamPal_Ultra_Toilet_RocketVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sRocketTrailEffect; // 0x28	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sRocketExplosionEffect; // 0x108	
	CSoundEventName m_sRocketExplodeSound; // 0x1e8	
	int32_t m_nNumRocketPaths; // 0x1f8	
};

// Alignment: 5
// Size: 0x18
struct SteamPal_Ultra_Toilet_Gun_t
{
public:
	SteampalUltraToiletGunType_t m_eGunType; // 0x0	
	AttachmentHandle_t m_nMuzzleAttachment; // 0x4	
private:
	[[maybe_unused]] uint8_t __pad0005[0x3]; 	// 0x5
public:
	int32_t m_nNumShotsFired; // 0x8	
	float m_flNextAttackTime; // 0xc	
	CSteamPal_Ultra_Toilet_Gun_VData_t* m_pGunVData; // 0x10	
};

// Alignment: 10
// Size: 0x40
struct SteampalConveyorSection_t
{
public:
	float m_flStartT; // 0x0	
	float m_flEndT; // 0x4	
	float m_flSectionLength; // 0x8	
	float m_flCurrentT; // 0xc	
	float m_flMaxSegmentLength; // 0x10	
	float m_flSegmentLengthT; // 0x14	
	int32_t m_nStartingSegmentIndex; // 0x18	
	Color m_DebugColor; // 0x1c	
private:
	[[maybe_unused]] uint8_t __pad0020[0x18]; 	// 0x20
public:
	CHandle< CSteamPalConveyorPathNode > m_hStartNode; // 0x38	
	CHandle< CSteamPalConveyorPathNode > m_hEndNode; // 0x3c	
};

// Alignment: 1
// Size: 0x108
class CSteamPal_TrackballVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
};

// Alignment: 1
// Size: 0x108
class CSteamPal_TouchScreenVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
};

// Alignment: 10
// Size: 0x230
class CSteamPal_DeskVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	// MPropertyDescription "Trackball Class"
	CEmbeddedSubclass< CSteamPal_Trackball > m_sTrackballClassToSpawn; // 0x108	
	CUtlString m_szLeftTrackballAttachmentName; // 0x118	
	CUtlString m_szRightTrackballAttachmentName; // 0x120	
	float m_flButtonAnimationDuration; // 0x128	
	float m_flButtonBlinkFrequency; // 0x12c	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sRocketBoostEffect; // 0x130	
	CUtlString m_strRecordedWavPath; // 0x210	
	CEmbeddedSubclass< CSteamPal_TouchScreen > m_sTouchScreenClassToSpawn; // 0x218	
	CUtlString m_szTouchScreenAttachment; // 0x228	
};

// Alignment: 4
// Size: 0x1f8
class CSteamPal_Toaster_VData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sToastModel; // 0x28	
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sPopupTartModel; // 0x108	
	CUtlString m_strLauncher1Attachment; // 0x1e8	
	CUtlString m_strLauncher2Attachment; // 0x1f0	
};

// Alignment: 1
// Size: 0x8
struct NPCApplianceBulletAttachment_t
{
public:
	CUtlString m_strAttachmentName; // 0x0	
};

// Alignment: 18
// Size: 0x5e0
class CNPCApplianceWeaponBulletsVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyDescription "Effect when firing this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szMuzzleFlashEffect; // 0x3b8	
	// MPropertyDescription "Effect to actually fire into the world from this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szTracerEffect; // 0x498	
	// MPropertyDescription "Muzzle attachements"
	CUtlVector< NPCApplianceBulletAttachment_t > m_vecMuzzleAttachments; // 0x578	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sFiringLoopingSound; // 0x590	
	// MPropertyGroupName "Using"
	CRangeInt m_nBurstSize; // 0x5a0	
	// MPropertyGroupName "Using"
	Vector m_vecBulletSpreadCone; // 0x5a8	
	// MPropertyGroupName "Using"
	float m_flSpreadBias; // 0x5b4	
	// MPropertyGroupName "Using"
	int32_t m_nPellets; // 0x5b8	
	// MPropertyGroupName "Using"
	bool m_bTargetingBullets; // 0x5bc	
	// MPropertyDescription "When calculating the aim spread, should this ability apply the current aim refinement value of the wielding NPC?"
	// MPropertyGroupName "Using"
	bool m_bApplyAimRefinement; // 0x5bd	
private:
	[[maybe_unused]] uint8_t __pad05be[0x2]; 	// 0x5be
public:
	float m_flAttackVerticalFOV; // 0x5c0	
	float m_flAttackHorizontalFOV; // 0x5c4	
	float m_flAttackMaxHeightDelta; // 0x5c8	
	float m_flAttackMinHeightDelta; // 0x5cc	
	float m_flMinAngleX; // 0x5d0	
	float m_flMaxAngleX; // 0x5d4	
	float m_flMinAngleY; // 0x5d8	
	float m_flMaxAngleY; // 0x5dc	
};

// Alignment: 2
// Size: 0x18
struct NPCApplianceProjectileAttachment_t
{
public:
	CUtlString m_sAttachmentName; // 0x0	
	CSubclassName< 0 > m_sProjectileName; // 0x8	
};

// Alignment: 13
// Size: 0x330
class CNPCApplianceProjectileVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyAttributeEditor "AssetBrowse( vmdl )"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	float m_flShootVelocity; // 0x108	
	bool m_bExplode; // 0x10c	
private:
	[[maybe_unused]] uint8_t __pad010d[0x3]; 	// 0x10d
public:
	float m_flExplodeRadius; // 0x110	
	float m_flExplodeDamage; // 0x114	
	// MPropertyDescription "Damage to apply on projectile touch"
	float m_flTouchDamage; // 0x118	
private:
	[[maybe_unused]] uint8_t __pad011c[0x4]; 	// 0x11c
public:
	// MPropertyGroupName "Particles"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sTrailParticle; // 0x120	
	// MPropertyGroupName "Particles"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_sExplosionParticle; // 0x200	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sHitWorldSound; // 0x2e0	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sHitBodySound; // 0x2f0	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sNearMissSound; // 0x300	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sPreExplodeSound; // 0x310	
	// MPropertyGroupName "Sounds"
	CSoundEventName m_sExplodeSound; // 0x320	
};

// Alignment: 10
// Size: 0x410
class CNPCApplianceWeaponVData : public CBaseNPCAbilityVData
{
public:
	CUtlVector< NPCApplianceProjectileAttachment_t > m_vecProjectiles; // 0x3b8	
	float m_flOpenConeAngle; // 0x3d0	
	float m_flAttackConeAngle; // 0x3d4	
	bool m_bPickRandomProjectile; // 0x3d8	
private:
	[[maybe_unused]] uint8_t __pad03d9[0x7]; 	// 0x3d9
public:
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph when it performs the open animation."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphOpenParam; // 0x3e0	
	// MPropertyDescription "The animgraph status tag that will be waited for by the NPC when it has finished performing the open animation."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlStringToken m_sAnimgraphFinishOpenTag; // 0x3e8	
private:
	[[maybe_unused]] uint8_t __pad03ec[0x4]; 	// 0x3ec
public:
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph when it performs the attack."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphAttackParam; // 0x3f0	
	// MPropertyDescription "The animgraph status tag that will be waited for by the NPC when it has finished performing the attack."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlStringToken m_sAnimgraphFinishAttackTag; // 0x3f8	
private:
	[[maybe_unused]] uint8_t __pad03fc[0x4]; 	// 0x3fc
public:
	// MPropertyDescription "The animgraph parameter that should be set on the NPC's animgraph when it performs the close animation."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphParam( m_sModelName )"
	CUtlString m_sAnimgraphCloseParam; // 0x400	
	// MPropertyDescription "The animgraph status tag that will be waited for by the NPC when it has finished performing the close animation."
	// MPropertyGroupName "Animation"
	// MPropertyAttributeEditor "VDataAnimGraphTag( m_sModelName )"
	CUtlStringToken m_sAnimgraphFinishCloseTag; // 0x408	
};

// Alignment: 2
// Size: 0x18
struct NPCApplianceProjectileRuntime_t
{
public:
	QAngle m_qPreviousAngle; // 0x0	
	RotationVector m_vAngularVelocity; // 0xc	
};

// Alignment: 2
// Size: 0x288
class CNPC_ApplianceVData : public CAI_DefaultNPCVData
{
public:
	float m_flInstantKillSpeed; // 0x280	
	float m_flInstantKillMultiplier; // 0x284	
};

// Alignment: 5
// Size: 0x38
struct AmmoTypeInfo_t
{
public:
	int32_t m_nMaxCarry; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0014[0x8]; 	// 0x14
public:
	CRangeInt m_nSplashSize; // 0x1c	
	AmmoFlags_t m_nFlags; // 0x24	
	float m_flMass; // 0x28	
	CRangeFloat m_flSpeed; // 0x2c	
};

// Alignment: 4
// Size: 0x3d8
class CNPCAbilitySpawnVData : public CBaseNPCAbilityVData
{
public:
	// MPropertyAttributeEditor "VDataChoice( scripts/npc_units.vdata )"
	// MPropertyGroupName "Using"
	CSubclassNameGeneric m_sSubclassToSpawn; // 0x3b8	
	// MPropertyGroupName "Using"
	CRangeInt m_nNumToSpawn; // 0x3c8	
	// MPropertyGroupName "Using"
	bool m_bSpawnInRagdoll; // 0x3d0	
private:
	[[maybe_unused]] uint8_t __pad03d1[0x3]; 	// 0x3d1
public:
	// MPropertyGroupName "Using"
	float m_flRagdollSpawnForceMultiplier; // 0x3d4	
};

// Alignment: 2
// Size: 0x18
class Extent
{
public:
	Vector lo; // 0x0	
	Vector hi; // 0xc	
};

// Alignment: 0
// Size: 0x70
class CNavVolume
{
public:
	uint8_t __pad0000[0x70]; 	// @note: autoaligned
};

// Alignment: 1
// Size: 0x98
class CNavVolumeVector : public CNavVolume
{
public:
	bool m_bHasBeenPreFiltered; // 0x78	
};

// Alignment: 0
// Size: 0x98
class CNavVolumeAll : public CNavVolumeVector
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x80
class CNavVolumeSphere : public CNavVolume
{
public:
	Vector m_vCenter; // 0x70	
	float m_flRadius; // 0x7c	
};

// Alignment: 1
// Size: 0x88
class CNavVolumeSphericalShell : public CNavVolumeSphere
{
public:
	float m_flRadiusInner; // 0x80	
};

// Alignment: 11
// Size: 0x78
class CEntityIdentity
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "entityIdentityNameChanged"
	int32_t m_nameStringableIndex; // 0x14	
	CUtlSymbolLarge m_name; // 0x18	
	CUtlSymbolLarge m_designerName; // 0x20	
private:
	[[maybe_unused]] uint8_t __pad0028[0x8]; 	// 0x28
public:
	uint32_t m_flags; // 0x30	
private:
	[[maybe_unused]] uint8_t __pad0034[0x4]; 	// 0x34
public:
	uint32_t m_fDataObjectTypes; // 0x38	
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	ChangeAccessorFieldPathIndex_t m_PathIndex; // 0x3c	
private:
	[[maybe_unused]] uint8_t __pad003e[0x12]; 	// 0x3e
public:
	CEntityIdentity* m_pPrev; // 0x50	
	CEntityIdentity* m_pNext; // 0x58	
	CEntityIdentity* m_pPrevByClass; // 0x60	
	CEntityIdentity* m_pNextByClass; // 0x68	
	V_uuid_t* m_pId; // 0x70	
};

// Alignment: 4
// Size: 0x38
class CEntityInstance : public IHandleEntity
{
public:
	// MNetworkDisable
	CUtlSymbolLarge m_iszPrivateVScripts; // 0x8	
	// MNetworkEnable
	// MNetworkPriority "56"
	CEntityIdentity* m_pEntity; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0018[0x8]; 	// 0x18
public:
	// MNetworkDisable
	CUtlStringToken m_worldGroupId; // 0x20	
private:
	[[maybe_unused]] uint8_t __pad0024[0xc]; 	// 0x24
public:
	// MNetworkEnable
	// MNetworkDisable
	CScriptComponent* m_CScriptComponent; // 0x30	
};

// Alignment: 1
// Size: 0x38
class CScriptComponent : public CEntityComponent
{
public:
	CUtlSymbolLarge m_scriptClassName; // 0x30	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CScriptComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CScriptComponent")->m_static_fields[1]->m_instance);};
};

// Alignment: 2
// Size: 0x40
class CBodyComponent : public CEntityComponent
{
public:
	// MNetworkDisable
	CGameSceneNode* m_pSceneNode; // 0x8	
private:
	[[maybe_unused]] uint8_t __pad0010[0x10]; 	// 0x10
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x20	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponent")->m_static_fields[1]->m_instance);};
};

// Alignment: 2
// Size: 0x1c0
class CBodyComponentPoint : public CBodyComponent
{
public:
	// MNetworkEnable
	CGameSceneNode m_sceneNode; // 0x40	
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x1a0	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentPoint")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentPoint")->m_static_fields[1]->m_instance);};
};

// Alignment: 2
// Size: 0x520
class CBodyComponentSkeletonInstance : public CBodyComponent
{
public:
	// MNetworkEnable
	CSkeletonInstance m_skeletonInstance; // 0x40	
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x500	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentSkeletonInstance")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentSkeletonInstance")->m_static_fields[1]->m_instance);};
};

// Alignment: 1
// Size: 0x20
class CHitboxComponent : public CEntityComponent
{
public:
	uint32_t m_unDisabledHitGroupMask; // 0x1c	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CHitboxComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_referenced_but_impl_is_contained(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CHitboxComponent")->m_static_fields[1]->m_instance);};
};

// Alignment: 66
// Size: 0x1c0
class CLightComponent : public CEntityComponent
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x48	
private:
	[[maybe_unused]] uint8_t __pad0060[0x15]; 	// 0x60
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	Color m_Color; // 0x75	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	Color m_SecondaryColor; // 0x79	
private:
	[[maybe_unused]] uint8_t __pad007d[0x3]; 	// 0x7d
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flBrightness; // 0x80	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flBrightnessMult; // 0x84	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flRange; // 0x88	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flFalloff; // 0x8c	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flAttenuation0; // 0x90	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flAttenuation1; // 0x94	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flAttenuation2; // 0x98	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flTheta; // 0x9c	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flPhi; // 0xa0	
private:
	[[maybe_unused]] uint8_t __pad00a4[0x4]; 	// 0xa4
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightCookie; // 0xa8	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nCascades; // 0xb0	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nCastShadows; // 0xb4	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowWidth; // 0xb8	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowHeight; // 0xbc	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bRenderDiffuse; // 0xc0	
private:
	[[maybe_unused]] uint8_t __pad00c1[0x3]; 	// 0xc1
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nRenderSpecular; // 0xc4	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bRenderTransmissive; // 0xc8	
private:
	[[maybe_unused]] uint8_t __pad00c9[0x3]; 	// 0xc9
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flOrthoLightWidth; // 0xcc	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flOrthoLightHeight; // 0xd0	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nStyle; // 0xd4	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	CUtlString m_Pattern; // 0xd8	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nCascadeRenderStaticObjects; // 0xe0	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeCrossFade; // 0xe4	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeDistanceFade; // 0xe8	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeDistance0; // 0xec	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeDistance1; // 0xf0	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeDistance2; // 0xf4	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowCascadeDistance3; // 0xf8	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowCascadeResolution0; // 0xfc	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowCascadeResolution1; // 0x100	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowCascadeResolution2; // 0x104	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowCascadeResolution3; // 0x108	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bUsesBakedShadowing; // 0x10c	
private:
	[[maybe_unused]] uint8_t __pad010d[0x3]; 	// 0x10d
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nShadowPriority; // 0x110	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	int32_t m_nBakedShadowIndex; // 0x114	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bRenderToCubemaps; // 0x118	
private:
	[[maybe_unused]] uint8_t __pad0119[0x7]; 	// 0x119
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	CUtlSymbolLarge m_LightGroups; // 0x120	
	// MNetworkEnable
	int32_t m_nDirectLight; // 0x128	
	// MNetworkEnable
	int32_t m_nIndirectLight; // 0x12c	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flFadeMinDist; // 0x130	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flFadeMaxDist; // 0x134	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowFadeMinDist; // 0x138	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flShadowFadeMaxDist; // 0x13c	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bEnabled; // 0x140	
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	bool m_bFlicker; // 0x141	
	// MNetworkEnable
	bool m_bPrecomputedFieldsValid; // 0x142	
private:
	[[maybe_unused]] uint8_t __pad0143[0x1]; 	// 0x143
public:
	// MNetworkEnable
	Vector m_vPrecomputedBoundsMins; // 0x144	
	// MNetworkEnable
	Vector m_vPrecomputedBoundsMaxs; // 0x150	
	// MNetworkEnable
	Vector m_vPrecomputedOBBOrigin; // 0x15c	
	// MNetworkEnable
	QAngle m_vPrecomputedOBBAngles; // 0x168	
	// MNetworkEnable
	Vector m_vPrecomputedOBBExtent; // 0x174	
	// MNetworkEnable
	float m_flPrecomputedMaxRange; // 0x180	
	// MNetworkEnable
	int32_t m_nFogLightingMode; // 0x184	
	// MNetworkEnable
	float m_flFogContributionStength; // 0x188	
	// MNetworkEnable
	float m_flNearClipPlane; // 0x18c	
	// MNetworkEnable
	Color m_SkyColor; // 0x190	
	// MNetworkEnable
	float m_flSkyIntensity; // 0x194	
	// MNetworkEnable
	Color m_SkyAmbientBounce; // 0x198	
	// MNetworkEnable
	bool m_bUseSecondaryColor; // 0x19c	
	// MNetworkEnable
	// MNetworkChangeCallback "MixedShadowsChanged"
	bool m_bMixedShadows; // 0x19d	
private:
	[[maybe_unused]] uint8_t __pad019e[0x2]; 	// 0x19e
public:
	// MNetworkEnable
	// MNetworkChangeCallback "LightRenderingChanged"
	float m_flLightStyleStartTime; // 0x1a0	
	// MNetworkEnable
	float m_flCapsuleLength; // 0x1a4	
private:
	[[maybe_unused]] uint8_t __pad01a8[0x10]; 	// 0x1a8
public:
	bool m_bPvsModifyEntity; // 0x1b8	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CLightComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CLightComponent")->m_static_fields[1]->m_instance);};
};

// Alignment: 5
// Size: 0xa8
class CRenderComponent : public CEntityComponent
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x10	
private:
	[[maybe_unused]] uint8_t __pad0028[0x18]; 	// 0x28
public:
	bool m_bIsRenderingWithViewModels; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad0041[0x3]; 	// 0x41
public:
	uint32_t m_nSplitscreenFlags; // 0x44	
private:
	[[maybe_unused]] uint8_t __pad0048[0x8]; 	// 0x48
public:
	bool m_bEnableRendering; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0051[0x4f]; 	// 0x51
public:
	bool m_bInterpolationReadyToDraw; // 0xa0	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CRenderComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CRenderComponent")->m_static_fields[1]->m_instance);};
};

// Alignment: 21
// Size: 0x338
class CBasePlayerWeaponVData : public CEntitySubclassVDataBase
{
public:
	// MPropertyDescription "Model used on the ground or held by an entity"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_szWorldModel; // 0x28	
	// MPropertyDescription "Was the weapon was built right-handed?"
	// MPropertyGroupName "Visuals"
	bool m_bBuiltRightHanded; // 0x108	
	// MPropertyDescription "Allows flipping the model, regardless of whether it is built left or right handed"
	// MPropertyGroupName "Visuals"
	bool m_bAllowFlipping; // 0x109	
private:
	[[maybe_unused]] uint8_t __pad010a[0x6]; 	// 0x10a
public:
	// MPropertyGroupName "Visuals"
	// MPropertyDescription "Attachment to fire bullets from"
	// MPropertyAttributeEditor "VDataModelAttachment( m_szWorldModel )"
	CUtlString m_sMuzzleAttachment; // 0x110	
	// MPropertyDescription "Effect when firing this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szMuzzleFlashParticle; // 0x118	
	// MPropertyDescription "Effect to actually fire into the world from this weapon"
	// MPropertyGroupName "Visuals"
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szTracerParticle; // 0x1f8	
	CUtlVector< CEmbeddedSubclass< CSteamPalModifier > > m_vecIntrinsicModifiers; // 0x2d8	
	ItemFlagTypes_t m_iFlags; // 0x2f0	
	// MPropertyAttributeEditor "VDataChoice( scripts/ammo.vdata )"
	// MPropertyGroupName "Ammo"
	// MPropertyCustomFGDType
	AmmoIndex_t m_nPrimaryAmmoType; // 0x2f1	
	// MPropertyAttributeEditor "VDataChoice( scripts/ammo.vdata )"
	// MPropertyGroupName "Ammo"
	// MPropertyCustomFGDType
	AmmoIndex_t m_nSecondaryAmmoType; // 0x2f2	
private:
	[[maybe_unused]] uint8_t __pad02f3[0x1]; 	// 0x2f3
public:
	// MPropertyFriendlyName "Primary Clip Size"
	// MPropertyDescription "How many bullets this gun can fire before it reloads (0 if no clip)"
	// MPropertyAttributeRange "0 255"
	// MPropertyGroupName "Ammo"
	int32_t m_iMaxClip1; // 0x2f4	
	// MPropertyFriendlyName "Secondary Clip Size"
	// MPropertyDescription "How many secondary bullets this gun can fire before it reloads (0 if no clip)"
	// MPropertyGroupName "Ammo"
	// MPropertyAttributeRange "0 255"
	int32_t m_iMaxClip2; // 0x2f8	
	// MPropertyDescription "Primary Initial Clip (-1 means use clip size)"
	// MPropertyGroupName "Ammo"
	// MPropertyAttributeRange "-1 255"
	int32_t m_iDefaultClip1; // 0x2fc	
	// MPropertyDescription "Secondary Initial Clip (-1 means use clip size)"
	// MPropertyGroupName "Ammo"
	// MPropertyAttributeRange "-1 255"
	int32_t m_iDefaultClip2; // 0x300	
	// MPropertyFriendlyName "HUD Bucket"
	// MPropertyDescription "Which 'column' to display this weapon in the HUD"
	// MPropertyGroupName "UI"
	int32_t m_iSlot; // 0x304	
	// MPropertyFriendlyName "HUD Bucket Position"
	// MPropertyDescription "Which 'row' to display this weapon in the HUD"
	// MPropertyGroupName "UI"
	int32_t m_iPosition; // 0x308	
	// MPropertyDescription "This value used to determine this weapon's importance in autoselection"
	// MPropertyGroupName "UI"
	int32_t m_iWeight; // 0x30c	
	// MPropertyFriendlyName "Safe To Auto-Switch To"
	// MPropertyDescription "Whether this weapon is safe to automatically switch to (should be false for eg. explosives that can the player may accidentally hurt themselves with)"
	// MPropertyGroupName "UI"
	bool m_bAutoSwitchTo; // 0x310	
	// MPropertyFriendlyName "Safe To Auto-Switch Away From"
	// MPropertyGroupName "UI"
	bool m_bAutoSwitchFrom; // 0x311	
private:
	[[maybe_unused]] uint8_t __pad0312[0x2]; 	// 0x312
public:
	// MPropertyGroupName "UI"
	RumbleEffect_t m_iRumbleEffect; // 0x314	
	CUtlMap< WeaponSound_t, CSoundEventName > m_aShootSounds; // 0x318	
};

// Alignment: 18
// Size: 0x5a0
class CBaseAnimatingController : public CSkeletonAnimationController
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "baseAnimBaseLayerChanged"
	CNetworkedSequenceOperation m_baseLayer; // 0x18	
	// MNetworkEnable
	CAnimGraphNetworkedVariables m_animGraphNetworkedVars; // 0x58	
private:
	[[maybe_unused]] uint8_t __pad02b8[0x8]; 	// 0x2b8
public:
	// MNetworkDisable
	bool m_bSequenceFinished; // 0x2c0	
private:
	[[maybe_unused]] uint8_t __pad02c1[0x3]; 	// 0x2c1
public:
	// MNetworkDisable
	float m_flGroundSpeed; // 0x2c4	
	// MNetworkDisable
	float m_flLastEventCycle; // 0x2c8	
	// MNetworkDisable
	float m_flLastEventAnimTime; // 0x2cc	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "-4"
	// MNetworkMaxValue "12"
	// MNetworkEncodeFlags
	// MNetworkPriority "32"
	// MNetworkChangeCallback "playbackRateChanged"
	CNetworkedQuantizedFloat m_flPlaybackRate; // 0x2d0	
	// MNetworkDisable
	float m_flPrevAnimTime; // 0x2e8	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkUserGroup "m_flPoseParameter"
	// MNetworkChangeCallback "poseParametersChanged"
	float m_flPoseParameter[24]; // 0x2ec	
	// MNetworkEnable
	// MNetworkChangeCallback "clientSideAnimationChanged"
	bool m_bClientSideAnimation; // 0x34c	
	// MNetworkDisable
	bool m_bNetworkedAnimationInputsChanged; // 0x34d	
private:
	[[maybe_unused]] uint8_t __pad034e[0x2]; 	// 0x34e
public:
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkChangeCallback "clientSideAnimCycleReset"
	int32_t m_nNewSequenceParity; // 0x350	
	// MNetworkEnable
	// MNetworkPriority "32"
	int32_t m_nResetEventsParity; // 0x354	
	// MNetworkDisable
	float m_flIKGroundContactTime; // 0x358	
	// MNetworkDisable
	float m_flIKGroundMinHeight; // 0x35c	
	// MNetworkDisable
	float m_flIKGroundMaxHeight; // 0x360	
	// MNetworkDisable
	float m_flIkZAdjustAmount; // 0x364	
private:
	[[maybe_unused]] uint8_t __pad0368[0x28]; 	// 0x368
public:
	// MNetworkDisable
	CSequenceTransitioner2 m_SequenceTransitioner; // 0x390	
};

// Alignment: 2
// Size: 0xae0
class CBodyComponentBaseAnimating : public CBodyComponentSkeletonInstance
{
public:
	// MNetworkEnable
	CBaseAnimatingController m_animationController; // 0x520	
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0xac0	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseAnimating")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseAnimating")->m_static_fields[1]->m_instance);};
};

// Alignment: 1
// Size: 0x5f0
class CBaseAnimatingOverlayController : public CBaseAnimatingController
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "overlay_vars"
	// MNetworkChangeCallback "OnOverlaysChanged2"
	CUtlVectorEmbeddedNetworkVar< CAnimationLayer > m_AnimOverlay; // 0x5a0	
};

// Alignment: 2
// Size: 0xb30
class CBodyComponentBaseAnimatingOverlay : public CBodyComponentSkeletonInstance
{
public:
	// MNetworkEnable
	CBaseAnimatingOverlayController m_animationController; // 0x520	
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0xb10	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseAnimatingOverlay")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseAnimatingOverlay")->m_static_fields[1]->m_instance);};
};

// Alignment: 1
// Size: 0x540
class CBodyComponentBaseModelEntity : public CBodyComponentSkeletonInstance
{
public:
	// MNetworkDisable
	// MNetworkChangeAccessorFieldPathIndex
	CNetworkVarChainer __m_pChainEntity; // 0x520	
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseModelEntity")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_contained_but_impl_is_referenced(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBodyComponentBaseModelEntity")->m_static_fields[1]->m_instance);};
};

// Alignment: 0
// Size: 0x20
class CTouchExpansionComponent : public CEntityComponent
{
public:
	static EntComponentInfo_t &Get_s_EntComponentInfo(){return *reinterpret_cast<EntComponentInfo_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CTouchExpansionComponent")->m_static_fields[0]->m_instance);};
	static int32_t &Get_entity_component_error_class_decl_says_referenced_but_impl_is_contained(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CTouchExpansionComponent")->m_static_fields[1]->m_instance);};
	// @note: no members available
};

// Alignment: 2
// Size: 0x10
struct RelationshipOverride_t : public Relationship_t
{
public:
	CHandle< CBaseEntity > entity; // 0x8	
	Class_T classType; // 0xc	
};

// Alignment: 79
// Size: 0x4f0
class CBaseEntity : public CEntityInstance
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "CBodyComponent"
	// MNetworkAlias "CBodyComponent"
	// MNetworkTypeAlias "CBodyComponent"
	// MNetworkPriority "48"
	CBodyComponent* m_CBodyComponent; // 0x38	
	CNetworkTransmitComponent m_NetworkTransmitComponent; // 0x40	
private:
	[[maybe_unused]] uint8_t __pad01e0[0x40]; 	// 0x1e0
public:
	CUtlVector< thinkfunc_t > m_aThinkFunctions; // 0x220	
	int32_t m_iCurrentThinkContext; // 0x238	
	int32_t m_nLastThinkTick; // 0x23c	
	CGameSceneNode* m_pGameSceneNode; // 0x240	
	CBitVec< 64 > m_isSteadyState; // 0x248	
	float m_lastNetworkChange; // 0x250	
private:
	[[maybe_unused]] uint8_t __pad0254[0xc]; 	// 0x254
public:
	CUtlVector< ResponseContext_t > m_ResponseContexts; // 0x260	
	CUtlSymbolLarge m_iszResponseContext; // 0x278	
private:
	[[maybe_unused]] uint8_t __pad0280[0x20]; 	// 0x280
public:
	// MNetworkEnable
	// MNetworkSerializer "ClampHealth"
	// MNetworkUserGroup "Player"
	// MNetworkPriority "32"
	int32_t m_iHealth; // 0x2a0	
	// MNetworkEnable
	int32_t m_iMaxHealth; // 0x2a4	
	// MNetworkEnable
	// MNetworkUserGroup "Player"
	// MNetworkPriority "32"
	uint8_t m_lifeState; // 0x2a8	
private:
	[[maybe_unused]] uint8_t __pad02a9[0x3]; 	// 0x2a9
public:
	float m_flDamageAccumulator; // 0x2ac	
	// MNetworkEnable
	bool m_bTakesDamage; // 0x2b0	
private:
	[[maybe_unused]] uint8_t __pad02b1[0x1]; 	// 0x2b1
public:
	// MNetworkEnable
	TakeDamageFlags_t m_nTakeDamageFlags; // 0x2b2	
private:
	[[maybe_unused]] uint8_t __pad02b4[0x1]; 	// 0x2b4
public:
	// MNetworkEnable
	MoveCollide_t m_MoveCollide; // 0x2b5	
	// MNetworkEnable
	MoveType_t m_MoveType; // 0x2b6	
	uint8_t m_nWaterTouch; // 0x2b7	
	uint8_t m_nSlimeTouch; // 0x2b8	
	bool m_bRestoreInHierarchy; // 0x2b9	
private:
	[[maybe_unused]] uint8_t __pad02ba[0x6]; 	// 0x2ba
public:
	CUtlSymbolLarge m_target; // 0x2c0	
	float m_flMoveDoneTime; // 0x2c8	
	CHandle< CBaseEntity > m_hDamageFilter; // 0x2cc	
	CUtlSymbolLarge m_iszDamageFilterName; // 0x2d0	
	// MNetworkEnable
	// MNetworkSendProxyRecipientsFilter
	CUtlStringToken m_nSubclassID; // 0x2d8	
private:
	[[maybe_unused]] uint8_t __pad02dc[0xc]; 	// 0x2dc
public:
	// MNetworkEnable
	// MNetworkPriority "0"
	// MNetworkSerializer "animTimeSerializer"
	// MNetworkSendProxyRecipientsFilter
	float m_flAnimTime; // 0x2e8	
	// MNetworkEnable
	// MNetworkPriority "1"
	// MNetworkSerializer "simulationTimeSerializer"
	float m_flSimulationTime; // 0x2ec	
	// MNetworkEnable
	float m_flCreateTime; // 0x2f0	
	// MNetworkEnable
	bool m_bClientSideRagdoll; // 0x2f4	
	// MNetworkEnable
	uint8_t m_ubInterpolationFrame; // 0x2f5	
private:
	[[maybe_unused]] uint8_t __pad02f6[0x2]; 	// 0x2f6
public:
	Vector m_vPrevVPhysicsUpdatePos; // 0x2f8	
	// MNetworkEnable
	uint8_t m_iTeamNum; // 0x304	
private:
	[[maybe_unused]] uint8_t __pad0305[0x3]; 	// 0x305
public:
	CUtlSymbolLarge m_iGlobalname; // 0x308	
	int32_t m_iSentToClients; // 0x310	
	float m_flSpeed; // 0x314	
	CUtlString m_sUniqueHammerID; // 0x318	
	// MNetworkEnable
	uint32_t m_spawnflags; // 0x320	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	int32_t m_nNextThinkTick; // 0x324	
	int32_t m_nSimulationTick; // 0x328	
private:
	[[maybe_unused]] uint8_t __pad032c[0x4]; 	// 0x32c
public:
	CEntityIOOutput m_OnKilled; // 0x330	
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkUserGroup "Player"
	uint32_t m_fFlags; // 0x358	
	Vector m_vecAbsVelocity; // 0x35c	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	// MNetworkPriority "32"
	CNetworkVelocityVector m_vecVelocity; // 0x368	
private:
	[[maybe_unused]] uint8_t __pad03c8[0x8]; 	// 0x3c8
public:
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	Vector m_vecBaseVelocity; // 0x3d0	
	int32_t m_nPushEnumCount; // 0x3dc	
	CCollisionProperty* m_pCollision; // 0x3e0	
	// MNetworkEnable
	CModifierProperty* m_pModifierProp; // 0x3e8	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hEffectEntity; // 0x3f0	
	// MNetworkEnable
	// MNetworkPriority "32"
	CHandle< CBaseEntity > m_hOwnerEntity; // 0x3f4	
	// MNetworkEnable
	// MNetworkChangeCallback "OnEffectsChanged"
	uint32_t m_fEffects; // 0x3f8	
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkUserGroup "Player"
	CHandle< CBaseEntity > m_hGroundEntity; // 0x3fc	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "4"
	// MNetworkEncodeFlags
	// MNetworkUserGroup "LocalPlayerExclusive"
	float m_flFriction; // 0x400	
	// MNetworkEnable
	// MNetworkEncoder
	float m_flElasticity; // 0x404	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	float m_flGravityScale; // 0x408	
	// MNetworkEnable
	// MNetworkUserGroup "Player"
	uint8_t m_nWaterLevel; // 0x40c	
	// MNetworkEnable
	bool m_bSimulatedEveryTick; // 0x40d	
	// MNetworkEnable
	bool m_bAnimatedEveryTick; // 0x40e	
	// MNetworkEnable
	// MNetworkUserGroup "ScalabilityOptions"
	uint8_t m_nMinCPULevel; // 0x40f	
	// MNetworkEnable
	// MNetworkUserGroup "ScalabilityOptions"
	uint8_t m_nMaxCPULevel; // 0x410	
	// MNetworkEnable
	// MNetworkUserGroup "ScalabilityOptions"
	uint8_t m_nMinGPULevel; // 0x411	
	// MNetworkEnable
	// MNetworkUserGroup "ScalabilityOptions"
	uint8_t m_nMaxGPULevel; // 0x412	
	bool m_bDisableLowViolence; // 0x413	
	uint8_t m_nWaterType; // 0x414	
private:
	[[maybe_unused]] uint8_t __pad0415[0x3]; 	// 0x415
public:
	int32_t m_iEFlags; // 0x418	
private:
	[[maybe_unused]] uint8_t __pad041c[0x4]; 	// 0x41c
public:
	CEntityIOOutput m_OnUser1; // 0x420	
	CEntityIOOutput m_OnUser2; // 0x448	
	CEntityIOOutput m_OnUser3; // 0x470	
	CEntityIOOutput m_OnUser4; // 0x498	
	int32_t m_iInitialTeamNum; // 0x4c0	
	// MNetworkEnable
	float m_flNavIgnoreUntilTime; // 0x4c4	
	QAngle m_vecAngVelocity; // 0x4c8	
	float m_flGroundChangeTime; // 0x4d4	
	bool m_bNetworkQuantizeOriginAndAngles; // 0x4d8	
	bool m_bLagCompensate; // 0x4d9	
private:
	[[maybe_unused]] uint8_t __pad04da[0x2]; 	// 0x4da
public:
	float m_flOverriddenFriction; // 0x4dc	
	CHandle< CBaseEntity > m_pBlocker; // 0x4e0	
	float m_flLocalTime; // 0x4e4	
	float m_flVPhysicsUpdateLocalTime; // 0x4e8	
	static Relationship_t** &Get_sm_DefaultRelationship(){return *reinterpret_cast<Relationship_t***>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[0]->m_instance);};
	static bool &Get_sm_bAccurateTriggerBboxChecks(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[1]->m_instance);};
	static bool &Get_sm_bDisableTouchFuncs(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[2]->m_instance);};
	static bool &Get_m_bAllowPrecache(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[3]->m_instance);};
	static bool &Get_s_bAbsQueriesValid(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[4]->m_instance);};
	static bool &Get_s_bPreventingSetAnimRunAnimEvents(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[5]->m_instance);};
	static int32_t &Get_m_nPredictionRandomSeed(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[6]->m_instance);};
	static CBasePlayerController* &Get_m_pPredictionPlayerController(){return *reinterpret_cast<CBasePlayerController**>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[7]->m_instance);};
	static bool &Get_sm_bDatadescValidating(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseEntity")->m_static_fields[8]->m_instance);};
};

// Alignment: 0
// Size: 0x4f0
class CServerOnlyEntity : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CServerOnlyPointEntity : public CServerOnlyEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CLogicalEntity : public CServerOnlyEntity
{
public:
	// @note: no members available
};

// Alignment: 17
// Size: 0x728
class CColorCorrection : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flFadeInDuration; // 0x4f0	
	// MNetworkEnable
	float m_flFadeOutDuration; // 0x4f4	
	float m_flStartFadeInWeight; // 0x4f8	
	float m_flStartFadeOutWeight; // 0x4fc	
	float m_flTimeStartFadeIn; // 0x500	
	float m_flTimeStartFadeOut; // 0x504	
	// MNetworkEnable
	float m_flMaxWeight; // 0x508	
	bool m_bStartDisabled; // 0x50c	
	// MNetworkEnable
	bool m_bEnabled; // 0x50d	
	// MNetworkEnable
	bool m_bMaster; // 0x50e	
	// MNetworkEnable
	bool m_bClientSide; // 0x50f	
	// MNetworkEnable
	bool m_bExclusive; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0511[0x3]; 	// 0x511
public:
	// MNetworkEnable
	float m_MinFalloff; // 0x514	
	// MNetworkEnable
	float m_MaxFalloff; // 0x518	
	// MNetworkEnable
	float m_flCurWeight; // 0x51c	
	// MNetworkEnable
	char m_netlookupFilename[512]; // 0x520	
	CUtlSymbolLarge m_lookupFilename; // 0x720	
};

// Alignment: 11
// Size: 0x528
class CEntityFlame : public CBaseEntity
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hEntAttached; // 0x4f0	
	// MNetworkEnable
	bool m_bCheapEffect; // 0x4f4	
private:
	[[maybe_unused]] uint8_t __pad04f5[0x3]; 	// 0x4f5
public:
	float m_flSize; // 0x4f8	
	bool m_bUseHitboxes; // 0x4fc	
private:
	[[maybe_unused]] uint8_t __pad04fd[0x3]; 	// 0x4fd
public:
	int32_t m_iNumHitboxFires; // 0x500	
	float m_flHitboxFireScale; // 0x504	
	float m_flLifetime; // 0x508	
	CHandle< CBaseEntity > m_hAttacker; // 0x50c	
	int32_t m_iDangerSound; // 0x510	
	float m_flDirectDamagePerSecond; // 0x514	
	int32_t m_iCustomDamageType; // 0x518	
};

// Alignment: 3
// Size: 0x548
class CBaseFilter : public CLogicalEntity
{
public:
	bool m_bNegated; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	CEntityIOOutput m_OnPass; // 0x4f8	
	CEntityIOOutput m_OnFail; // 0x520	
};

// Alignment: 4
// Size: 0x5d0
class CFilterMultiple : public CBaseFilter
{
public:
	filter_t m_nFilterType; // 0x548	
private:
	[[maybe_unused]] uint8_t __pad054c[0x4]; 	// 0x54c
public:
	CUtlSymbolLarge m_iFilterName[10]; // 0x550	
	CHandle< CBaseEntity > m_hFilter[10]; // 0x5a0	
	int32_t m_nFilterCount; // 0x5c8	
};

// Alignment: 1
// Size: 0x550
class CFilterProximity : public CBaseFilter
{
public:
	float m_flRadius; // 0x548	
};

// Alignment: 0
// Size: 0x548
class CFilterLOS : public CBaseFilter
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x550
class CFilterClass : public CBaseFilter
{
public:
	CUtlSymbolLarge m_iFilterClass; // 0x548	
};

// Alignment: 4
// Size: 0x500
class CBaseFire : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flScale; // 0x4f0	
	// MNetworkEnable
	float m_flStartScale; // 0x4f4	
	// MNetworkEnable
	float m_flScaleTime; // 0x4f8	
	// MNetworkEnable
	uint32_t m_nFlags; // 0x4fc	
};

// Alignment: 2
// Size: 0x508
class CFireSmoke : public CBaseFire
{
public:
	// MNetworkEnable
	int32_t m_nFlameModelIndex; // 0x500	
	// MNetworkEnable
	int32_t m_nFlameFromAboveModelIndex; // 0x504	
};

// Alignment: 7
// Size: 0x540
class CFishPool : public CBaseEntity
{
public:
	int32_t m_fishCount; // 0x500	
	float m_maxRange; // 0x504	
	float m_swimDepth; // 0x508	
	float m_waterLevel; // 0x50c	
	bool m_isDormant; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0511[0x7]; 	// 0x511
public:
	CUtlVector< CHandle< CFish > > m_fishes; // 0x518	
	CountdownTimer m_visTimer; // 0x530	
};

// Alignment: 0
// Size: 0x880
class CInfoData : public CServerOnlyEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x8
class IServerVehicle : public IVehicle
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x560
class CLogicBranch : public CLogicalEntity
{
public:
	bool m_bInValue; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	CUtlVector< CHandle< CBaseEntity > > m_Listeners; // 0x4f8	
	CEntityIOOutput m_OnTrue; // 0x510	
	CEntityIOOutput m_OnFalse; // 0x538	
};

// Alignment: 7
// Size: 0x580
class CLogicDistanceCheck : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszEntityA; // 0x4f0	
	CUtlSymbolLarge m_iszEntityB; // 0x4f8	
	float m_flZone1Distance; // 0x500	
	float m_flZone2Distance; // 0x504	
	CEntityIOOutput m_InZone1; // 0x508	
	CEntityIOOutput m_InZone2; // 0x530	
	CEntityIOOutput m_InZone3; // 0x558	
};

// Alignment: 3
// Size: 0x508
class CPointPrefab : public CServerOnlyPointEntity
{
public:
	CUtlSymbolLarge m_targetMapName; // 0x4f0	
	CUtlSymbolLarge m_forceWorldGroupID; // 0x4f8	
	bool m_fixupNames; // 0x500	
};

// Alignment: 2
// Size: 0x4f8
class CSkyboxReference : public CBaseEntity
{
public:
	CUtlStringToken m_worldGroupId; // 0x4f0	
	CHandle< CSkyCamera > m_hSkyCamera; // 0x4f4	
};

// Alignment: 4
// Size: 0x590
class CSkyCamera : public CBaseEntity
{
public:
	// MNetworkEnable
	sky3dparams_t m_skyboxData; // 0x4f0	
	// MNetworkEnable
	CUtlStringToken m_skyboxSlotToken; // 0x580	
	bool m_bUseAngles; // 0x584	
private:
	[[maybe_unused]] uint8_t __pad0585[0x3]; 	// 0x585
public:
	CSkyCamera* m_pNext; // 0x588	
};

// Alignment: 8
// Size: 0x578
class CEnvSoundscape : public CServerOnlyEntity
{
public:
	CEntityIOOutput m_OnPlay; // 0x4f0	
	float m_flRadius; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad051c[0x4]; 	// 0x51c
public:
	CUtlSymbolLarge m_soundscapeName; // 0x520	
	int32_t m_soundscapeIndex; // 0x528	
	int32_t m_soundscapeEntityListId; // 0x52c	
	CUtlSymbolLarge m_positionNames[8]; // 0x530	
	CHandle< CEnvSoundscape > m_hProxySoundscape; // 0x570	
	bool m_bDisabled; // 0x574	
};

// Alignment: 1
// Size: 0x580
class CEnvSoundscapeProxy : public CEnvSoundscape
{
public:
	CUtlSymbolLarge m_MainSoundscapeName; // 0x578	
};

// Alignment: 0
// Size: 0x578
class CEnvSoundscapeTriggerable : public CEnvSoundscape
{
public:
	// @note: no members available
};

// Alignment: 27
// Size: 0x5a0
class CTriggerCamera : public CBaseEntity
{
public:
	CHandle< CBaseEntity > m_hPlayer; // 0x4f0	
	CHandle< CBaseEntity > m_hTarget; // 0x4f4	
	CBaseEntity* m_pPath; // 0x4f8	
	CUtlSymbolLarge m_sPath; // 0x500	
	float m_flWait; // 0x508	
	float m_flReturnTime; // 0x50c	
	float m_flStopTime; // 0x510	
	float m_moveDistance; // 0x514	
	float m_targetSpeed; // 0x518	
	float m_initialSpeed; // 0x51c	
	float m_acceleration; // 0x520	
	float m_deceleration; // 0x524	
	int32_t m_state; // 0x528	
	Vector m_vecMoveDir; // 0x52c	
	float m_fov; // 0x538	
	float m_fovSpeed; // 0x53c	
	CUtlSymbolLarge m_iszTargetAttachment; // 0x540	
	AttachmentHandle_t m_iAttachmentIndex; // 0x548	
	bool m_bSnapToGoal; // 0x549	
	bool m_bInterpolatePosition; // 0x54a	
private:
	[[maybe_unused]] uint8_t __pad054b[0x1]; 	// 0x54b
public:
	Vector m_vStartPos; // 0x54c	
	Vector m_vEndPos; // 0x558	
	float m_flInterpStartTime; // 0x564	
	uint64_t m_nPlayerButtons; // 0x568	
	bool m_bOldTakesDamage; // 0x570	
private:
	[[maybe_unused]] uint8_t __pad0571[0x1]; 	// 0x571
public:
	TakeDamageFlags_t m_nOldTakeDamageFlags; // 0x572	
private:
	[[maybe_unused]] uint8_t __pad0574[0x4]; 	// 0x574
public:
	CEntityIOOutput m_OnEndFollow; // 0x578	
	static float &Get_kflPosInterpTime(){return *reinterpret_cast<float*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CTriggerCamera")->m_static_fields[0]->m_instance);};
};

// Alignment: 21
// Size: 0x250
class CBaseServerVehicle : public IServerVehicle
{
public:
	CUtlVector< CPassengerInfo > m_PassengerInfo; // 0x8	
	CUtlVector< CPassengerRole > m_PassengerRoles; // 0x20	
	CBaseEntity* m_pVehicle; // 0x38	
private:
	[[maybe_unused]] uint8_t __pad0040[0x8]; 	// 0x40
public:
	int32_t m_nNPCButtons; // 0x48	
	int32_t m_nPrevNPCButtons; // 0x4c	
	float m_flTurnDegrees; // 0x50	
private:
	[[maybe_unused]] uint8_t __pad0054[0x4]; 	// 0x54
public:
	CUtlVector< CBaseServerVehicle::entryanim_t > m_EntryAnimations; // 0x58	
	CUtlVector< CBaseServerVehicle::exitanim_t > m_ExitAnimations; // 0x70	
	bool m_bParsedAnimations; // 0x88	
	bool m_bUseLegacyExitChecks; // 0x89	
private:
	[[maybe_unused]] uint8_t __pad008a[0x2]; 	// 0x8a
public:
	int32_t m_iCurrentExitAnim; // 0x8c	
	Vector m_vecCurrentExitEndPoint; // 0x90	
	Vector m_savedViewOffset; // 0x9c	
	CHandle< CEntityBlocker > m_hExitBlocker; // 0xa8	
private:
	[[maybe_unused]] uint8_t __pad00ac[0x4]; 	// 0xac
public:
	vehiclesounds_t m_vehicleSounds; // 0xb0	
	float m_flVehicleVolume; // 0x220	
	int32_t m_iSoundGear; // 0x224	
	float m_flSpeedPercentage; // 0x228	
private:
	[[maybe_unused]] uint8_t __pad022c[0x14]; 	// 0x22c
public:
	sound_states m_soundState; // 0x240	
	float m_soundStateStartTime; // 0x244	
	float m_lastSpeed; // 0x248	
};

// Alignment: 0
// Size: 0xd8
class CNavVolumeMarkupVolume : public CNavVolume
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x98
class CNavVolumeCalculatedVector : public CNavVolume
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0xb8
class CNavVolumeBreadthFirstSearch : public CNavVolumeCalculatedVector
{
public:
	Vector m_vStartPos; // 0xa0	
	float m_flSearchDist; // 0xac	
};

// Alignment: 14
// Size: 0x190
class CBasePlayerVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeCModel > > m_sModelName; // 0x28	
	CUtlVector< CEmbeddedSubclass< CSteamPalModifier > > m_vecIntrinsicModifiers; // 0x108	
	CSkillFloat m_flHeadDamageMultiplier; // 0x120	
	CSkillFloat m_flChestDamageMultiplier; // 0x130	
	CSkillFloat m_flStomachDamageMultiplier; // 0x140	
	CSkillFloat m_flArmDamageMultiplier; // 0x150	
	CSkillFloat m_flLegDamageMultiplier; // 0x160	
	// MPropertyGroupName "Water"
	float m_flHoldBreathTime; // 0x170	
	// MPropertyGroupName "Water"
	// MPropertyDescription "Seconds between drowning ticks"
	float m_flDrowningDamageInterval; // 0x174	
	// MPropertyGroupName "Water"
	// MPropertyDescription "Amount of damage done on the first drowning tick (+1 each subsequent interval)"
	int32_t m_nDrowningDamageInitial; // 0x178	
	// MPropertyGroupName "Water"
	// MPropertyDescription "Max damage done by a drowning tick"
	int32_t m_nDrowningDamageMax; // 0x17c	
	// MPropertyGroupName "Water"
	int32_t m_nWaterSpeed; // 0x180	
	// MPropertyGroupName "Use"
	float m_flUseRange; // 0x184	
	// MPropertyGroupName "Use"
	float m_flUseAngleTolerance; // 0x188	
};

// Alignment: 2
// Size: 0x4f8
class CEnvDetailController : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flFadeStartDist; // 0x4f0	
	// MNetworkEnable
	float m_flFadeEndDist; // 0x4f4	
};

// Alignment: 0
// Size: 0x4f0
class CInfoLadderDismount : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CGameRulesProxy : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 14
// Size: 0x540
class CPoseController : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bPoseValueParity; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	float m_fPoseValue; // 0x4f4	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "10"
	float m_fInterpolationDuration; // 0x4f8	
	// MNetworkEnable
	bool m_bInterpolationWrap; // 0x4fc	
private:
	[[maybe_unused]] uint8_t __pad04fd[0x3]; 	// 0x4fd
public:
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "-10"
	// MNetworkMaxValue "10"
	float m_fCycleFrequency; // 0x500	
	// MNetworkEnable
	PoseController_FModType_t m_nFModType; // 0x504	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "-1"
	// MNetworkMaxValue "1"
	float m_fFModTimeOffset; // 0x508	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "-10"
	// MNetworkMaxValue "10"
	float m_fFModRate; // 0x50c	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "10"
	float m_fFModAmplitude; // 0x510	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hProps[4]; // 0x514	
	// MNetworkEnable
	uint8_t m_chPoseIndex[4]; // 0x524	
	bool m_bDisablePropLookup; // 0x528	
private:
	[[maybe_unused]] uint8_t __pad0529[0x7]; 	// 0x529
public:
	CUtlSymbolLarge m_iszPropName; // 0x530	
	CUtlSymbolLarge m_iszPoseParameterName; // 0x538	
};

// Alignment: 7
// Size: 0x128
class CPrecipitationVData : public CEntitySubclassVDataBase
{
public:
	CResourceNameTyped< CWeakHandle< InfoForResourceTypeIParticleSystemDefinition > > m_szParticlePrecipitationEffect; // 0x28	
	float m_flInnerDistance; // 0x108	
	ParticleAttachment_t m_nAttachType; // 0x10c	
	bool m_bBatchSameVolumeType; // 0x110	
private:
	[[maybe_unused]] uint8_t __pad0111[0x3]; 	// 0x111
public:
	int32_t m_nRTEnvCP; // 0x114	
	int32_t m_nRTEnvCPComponent; // 0x118	
private:
	[[maybe_unused]] uint8_t __pad011c[0x4]; 	// 0x11c
public:
	CUtlString m_szModifier; // 0x120	
};

// Alignment: 9
// Size: 0x80
class CRagdoll : public IRagdoll
{
public:
	ragdoll_t m_ragdoll; // 0x8	
	Vector m_mins; // 0x40	
	Vector m_maxs; // 0x4c	
	Vector m_origin; // 0x58	
	float m_lastUpdate; // 0x64	
	bool m_allAsleep; // 0x68	
private:
	[[maybe_unused]] uint8_t __pad0069[0x3]; 	// 0x69
public:
	Vector m_vecLastOrigin; // 0x6c	
	float m_flLastOriginChangeTime; // 0x78	
	float m_flAwakeTime; // 0x7c	
	static uint32_t &Get_s_globalCount(){return *reinterpret_cast<uint32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CRagdoll")->m_static_fields[0]->m_instance);};
};

// Alignment: 9
// Size: 0x580
class CSoundOpvarSetPointBase : public CBaseEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	CEntityHandle m_hSource; // 0x4f4	
private:
	[[maybe_unused]] uint8_t __pad04f8[0x8]; 	// 0x4f8
public:
	CUtlSymbolLarge m_iszSourceEntityName; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0508[0x48]; 	// 0x508
public:
	Vector m_vLastPosition; // 0x550	
private:
	[[maybe_unused]] uint8_t __pad055c[0x4]; 	// 0x55c
public:
	// MNetworkEnable
	CUtlSymbolLarge m_iszStackName; // 0x560	
	// MNetworkEnable
	CUtlSymbolLarge m_iszOperatorName; // 0x568	
	// MNetworkEnable
	CUtlSymbolLarge m_iszOpvarName; // 0x570	
	// MNetworkEnable
	int32_t m_iOpvarIndex; // 0x578	
	// MNetworkEnable
	bool m_bUseAutoCompare; // 0x57c	
};

// Alignment: 21
// Size: 0x660
class CSoundOpvarSetPointEntity : public CSoundOpvarSetPointBase
{
public:
	CEntityIOOutput m_OnEnter; // 0x580	
	CEntityIOOutput m_OnExit; // 0x5a8	
	bool m_bAutoDisable; // 0x5d0	
private:
	[[maybe_unused]] uint8_t __pad05d1[0x23]; 	// 0x5d1
public:
	float m_flDistanceMin; // 0x5f4	
	float m_flDistanceMax; // 0x5f8	
	float m_flDistanceMapMin; // 0x5fc	
	float m_flDistanceMapMax; // 0x600	
	float m_flOcclusionRadius; // 0x604	
	float m_flOcclusionMin; // 0x608	
	float m_flOcclusionMax; // 0x60c	
	float m_flValSetOnDisable; // 0x610	
	bool m_bSetValueOnDisable; // 0x614	
private:
	[[maybe_unused]] uint8_t __pad0615[0x3]; 	// 0x615
public:
	int32_t m_nSimulationMode; // 0x618	
	int32_t m_nVisibilitySamples; // 0x61c	
	Vector m_vDynamicProxyPoint; // 0x620	
	float m_flDynamicMaximumOcclusion; // 0x62c	
	CEntityHandle m_hDynamicEntity; // 0x630	
private:
	[[maybe_unused]] uint8_t __pad0634[0x4]; 	// 0x634
public:
	CUtlSymbolLarge m_iszDynamicEntityName; // 0x638	
	float m_flPathingDistanceNormFactor; // 0x640	
	Vector m_vPathingSourcePos; // 0x644	
	Vector m_vPathingListenerPos; // 0x650	
};

// Alignment: 9
// Size: 0x6c8
class CSoundOpvarSetAABBEntity : public CSoundOpvarSetPointEntity
{
public:
	Vector m_vDistanceInnerMins; // 0x660	
	Vector m_vDistanceInnerMaxs; // 0x66c	
	Vector m_vDistanceOuterMins; // 0x678	
	Vector m_vDistanceOuterMaxs; // 0x684	
	int32_t m_nAABBDirection; // 0x690	
	Vector m_vInnerMins; // 0x694	
	Vector m_vInnerMaxs; // 0x6a0	
	Vector m_vOuterMins; // 0x6ac	
	Vector m_vOuterMaxs; // 0x6b8	
};

// Alignment: 0
// Size: 0x6c8
class CSoundOpvarSetOBBEntity : public CSoundOpvarSetAABBEntity
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x688
class CSoundOpvarSetPathCornerEntity : public CSoundOpvarSetPointEntity
{
public:
	float m_flDistMinSqr; // 0x678	
	float m_flDistMaxSqr; // 0x67c	
	CUtlSymbolLarge m_iszPathCornerEntityName; // 0x680	
};

// Alignment: 8
// Size: 0x5c0
class CSoundOpvarSetOBBWindEntity : public CSoundOpvarSetPointBase
{
public:
	Vector m_vMins; // 0x580	
	Vector m_vMaxs; // 0x58c	
	Vector m_vDistanceMins; // 0x598	
	Vector m_vDistanceMaxs; // 0x5a4	
	float m_flWindMin; // 0x5b0	
	float m_flWindMax; // 0x5b4	
	float m_flWindMapMin; // 0x5b8	
	float m_flWindMapMax; // 0x5bc	
};

// Alignment: 3
// Size: 0x28
class CAI_BehaviorBase : public CAI_Component
{
public:
	bool m_bActive; // 0x18	
	bool m_bOverrode; // 0x19	
private:
	[[maybe_unused]] uint8_t __pad001a[0x6]; 	// 0x1a
public:
	CAI_BehaviorBase* m_pActiveChildBehavior; // 0x20	
};

// Alignment: 6
// Size: 0x88
class CAI_AnimGraphServices : public CAI_Component
{
public:
	float m_flMinFaceTolerance; // 0x20	
	CUtlStringToken m_sFinishTagThatTaskIsWaitingFor; // 0x24	
	CUtlSymbolLarge m_iszGraphVariableToSetOnTaskEnd; // 0x28	
	CUtlSymbolLarge m_iszGraphVariableToSetOnScheduleEnd; // 0x30	
	CUtlSymbolLarge m_iszGraphVariableToSetOnFinishTag; // 0x38	
private:
	[[maybe_unused]] uint8_t __pad0040[0x20]; 	// 0x40
public:
	LastIncomingHit_t m_LastIncomingHit; // 0x60	
	static CUtlSymbolLarge &Get_TASK_GRAPH_VARIABLE_SET(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GRAPH_VARIABLE_SET_ON_TAG(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GRAPH_VARIABLE_SET_ON_SCHEDULEEND(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GRAPH_WAIT_FOR_TAG(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[3]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GRAPH_WAIT_FOR_TAG_FACE_ENEMY(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[4]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_GRAPH_WAIT_FOR_TAG_AND_MOVEMENT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AnimGraphServices")->m_static_fields[5]->m_instance);};
};

// Alignment: 8
// Size: 0x538
class CAI_GoalEntity : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszActor; // 0x4f8	
	CUtlSymbolLarge m_iszGoal; // 0x500	
	bool m_fStartActive; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad0509[0x3]; 	// 0x509
public:
	CAI_GoalEntity::SearchType_t m_SearchType; // 0x50c	
	CUtlSymbolLarge m_iszConceptModifiers; // 0x510	
	CUtlVector< CHandle< CAI_BaseNPC > > m_actors; // 0x518	
	CHandle< CBaseEntity > m_hGoalEntity; // 0x530	
	uint32_t m_flags; // 0x534	
};

// Alignment: 12
// Size: 0x5c0
class CAI_Hint : public CServerOnlyEntity
{
public:
	HintNodeData m_NodeData; // 0x4f0	
	CHandle< CBaseEntity > m_hHintOwner; // 0x530	
	float m_flNextUseTime; // 0x534	
	CEntityOutputTemplate< CHandle< CBaseEntity > > m_OnNPCStartedUsing; // 0x538	
	CEntityOutputTemplate< CHandle< CBaseEntity > > m_OnNPCStoppedUsing; // 0x560	
	float m_nodeFOV; // 0x588	
	Vector m_vecForward; // 0x58c	
	CUtlSymbolLarge m_iszAnimgraphEntryCmd; // 0x598	
	CUtlSymbolLarge m_iszAnimgraphEntryTag; // 0x5a0	
	CUtlSymbolLarge m_iszAnimgraphExitCmd; // 0x5a8	
	CUtlSymbolLarge m_iszAnimgraphExitTag; // 0x5b0	
	CUtlSymbolLarge m_iszNavlinkTargetName; // 0x5b8	
};

// Alignment: 3
// Size: 0x548
class CNodeEnt : public CServerOnlyPointEntity
{
public:
	bool m_bDontDropNode; // 0x4f0	
	HullFlags_t m_HullForceFlags; // 0x4f1	
private:
	[[maybe_unused]] uint8_t __pad04fa[0x6]; 	// 0x4fa
public:
	HintNodeData m_NodeData; // 0x500	
	static int32_t &Get_m_nNodeCount(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNodeEnt")->m_static_fields[0]->m_instance);};
};

// Alignment: 11
// Size: 0x530
class CAI_Relationship : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszSubject; // 0x4f8	
	CUtlSymbolLarge m_iszSubjectClass; // 0x500	
	CUtlSymbolLarge m_iszTargetClass; // 0x508	
	int32_t m_iDisposition; // 0x510	
	int32_t m_iRank; // 0x514	
	bool m_fStartActive; // 0x518	
	bool m_bIsActive; // 0x519	
private:
	[[maybe_unused]] uint8_t __pad051a[0x2]; 	// 0x51a
public:
	int32_t m_iPreviousDisposition; // 0x51c	
	float m_flRadius; // 0x520	
	int32_t m_iPreviousRank; // 0x524	
	bool m_bReciprocal; // 0x528	
};

// Alignment: 32
// Size: 0x608
class CAI_ScriptConditions : public CBaseEntity
{
public:
	CEntityIOOutput m_OnConditionsSatisfied; // 0x4f8	
	CEntityIOOutput m_OnConditionsTimeout; // 0x520	
	CEntityIOOutput m_NoValidActors; // 0x548	
	bool m_fDisabled; // 0x570	
	bool m_bLeaveAsleep; // 0x571	
private:
	[[maybe_unused]] uint8_t __pad0572[0x2]; 	// 0x572
public:
	CHandle< CBaseEntity > m_hTarget; // 0x574	
	float m_flRequiredDuration; // 0x578	
	NPC_STATE m_fMinState; // 0x57c	
	NPC_STATE m_fMaxState; // 0x580	
	ThreeState_t m_fScriptStatus; // 0x584	
	ThreeState_t m_fActorSeePlayer; // 0x588	
private:
	[[maybe_unused]] uint8_t __pad058c[0x4]; 	// 0x58c
public:
	CUtlSymbolLarge m_Actor; // 0x590	
	float m_flPlayerActorProximity; // 0x598	
	CAI_ProxTester m_PlayerActorProxTester; // 0x59c	
	float m_flPlayerActorFOV; // 0x5a4	
	bool m_bPlayerActorFOVTrueCone; // 0x5a8	
private:
	[[maybe_unused]] uint8_t __pad05a9[0x3]; 	// 0x5a9
public:
	ThreeState_t m_fPlayerActorLOS; // 0x5ac	
	ThreeState_t m_fActorSeeTarget; // 0x5b0	
	float m_flActorTargetProximity; // 0x5b4	
	CAI_ProxTester m_ActorTargetProxTester; // 0x5b8	
	float m_flPlayerTargetProximity; // 0x5c0	
	CAI_ProxTester m_PlayerTargetProxTester; // 0x5c4	
	float m_flPlayerTargetFOV; // 0x5cc	
	bool m_bPlayerTargetFOVTrueCone; // 0x5d0	
private:
	[[maybe_unused]] uint8_t __pad05d1[0x3]; 	// 0x5d1
public:
	ThreeState_t m_fPlayerTargetLOS; // 0x5d4	
	ThreeState_t m_fPlayerBlockingActor; // 0x5d8	
	ThreeState_t m_fActorInPVS; // 0x5dc	
	float m_flMinTimeout; // 0x5e0	
	float m_flMaxTimeout; // 0x5e4	
	ThreeState_t m_fActorInVehicle; // 0x5e8	
	ThreeState_t m_fPlayerInVehicle; // 0x5ec	
	CUtlVector< CAI_ScriptConditionsElement > m_ElementList; // 0x5f0	
};

// Alignment: 4
// Size: 0x508
class CAI_SpeechFilter : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszSubject; // 0x4f8	
	float m_flIdleModifier; // 0x500	
	bool m_bNeverSayHello; // 0x504	
	bool m_bDisabled; // 0x505	
};

// Alignment: 18
// Size: 0x5d8
class CBaseNPCMaker : public CBaseEntity
{
public:
	int32_t m_nMaxNumNPCs; // 0x4f0	
	float m_flSpawnFrequency; // 0x4f4	
	float m_flRetryFrequency; // 0x4f8	
	int32_t m_nHullCheckMode; // 0x4fc	
	CEntityOutputTemplate< CHandle< CBaseEntity > > m_OnSpawnNPC; // 0x500	
	CEntityIOOutput m_OnAllSpawned; // 0x528	
	CEntityIOOutput m_OnAllSpawnedDead; // 0x550	
	CEntityIOOutput m_OnAllLiveChildrenDead; // 0x578	
	int32_t m_nLiveChildren; // 0x5a0	
	int32_t m_nMaxLiveChildren; // 0x5a4	
	int32_t m_nMinSpawnDistance; // 0x5a8	
	float m_flRadius; // 0x5ac	
	bool m_bDisabled; // 0x5b0	
private:
	[[maybe_unused]] uint8_t __pad05b1[0x3]; 	// 0x5b1
public:
	CHandle< CBaseEntity > m_hIgnoreEntity; // 0x5b4	
	CUtlSymbolLarge m_iszIgnoreEnt; // 0x5b8	
	CUtlSymbolLarge m_iszDestinationGroup; // 0x5c0	
	CBaseNPCMaker::ThreeStateYesNo_t m_CriterionVisibility; // 0x5c8	
	CBaseNPCMaker::ThreeStateDist_t m_CriterionDistance; // 0x5cc	
};

// Alignment: 5
// Size: 0x600
class CNPCMaker : public CBaseNPCMaker
{
public:
	CUtlSymbolLarge m_iszNPCSubClass; // 0x5d8	
	CUtlSymbolLarge m_iszSquadName; // 0x5e0	
	CUtlSymbolLarge m_iszHintGroup; // 0x5e8	
	CUtlSymbolLarge m_RelationshipString; // 0x5f0	
	CUtlSymbolLarge m_ChildTargetName; // 0x5f8	
};

// Alignment: 2
// Size: 0x5e8
class CTemplateNPCMaker : public CBaseNPCMaker
{
public:
	CUtlSymbolLarge m_iszWorldName; // 0x5d8	
	CUtlSymbolLarge m_iszSource2EntityLumpName; // 0x5e0	
};

// Alignment: 5
// Size: 0x560
class CAttachedItemManager : public CServerOnlyPointEntity
{
public:
	CUtlSymbolLarge m_iszAddSubclassNames[4]; // 0x4f8	
	CUtlSymbolLarge m_iszRemoveAbilityNames[4]; // 0x518	
	CUtlSymbolLarge m_iszPrimaryAbilityNames[4]; // 0x538	
	bool m_bListenForFutureEntities; // 0x558	
	bool m_bMarkAsRemoveable; // 0x559	
};

// Alignment: 1
// Size: 0x520
class CAI_AllySpeechManager : public CLogicalEntity
{
public:
	CSimpleSimTimer m_ConceptCategoryTimers[3]; // 0x4f0	
	static CAI_AllySpeechManager* &Get_gm_pSpeechManager(){return *reinterpret_cast<CAI_AllySpeechManager**>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_AllySpeechManager")->m_static_fields[0]->m_instance);};
};

// Alignment: 4
// Size: 0x550
class CAI_AssaultGoal : public CAI_GoalEntity
{
public:
	CUtlSymbolLarge m_RallyPoint; // 0x538	
	int32_t m_AssaultCue; // 0x540	
	int32_t m_RallySelectMethod; // 0x544	
	int32_t m_BranchMethod; // 0x548	
};

// Alignment: 9
// Size: 0x578
class CAI_FightFromCoverGoal : public CAI_GoalEntity
{
public:
	CUtlSymbolLarge m_DirectionalMarker; // 0x538	
	CUtlSymbolLarge m_GenericHintType; // 0x540	
	CHandle< CBaseEntity > m_hDirectionalMarker; // 0x548	
	float m_WidthZone; // 0x54c	
	float m_LengthZone; // 0x550	
	float m_HeightZone; // 0x554	
	float m_BiasZone; // 0x558	
	Vector m_vFront; // 0x55c	
	Vector m_vDir; // 0x568	
};

// Alignment: 1
// Size: 0x550
class CAI_FollowGoal : public CAI_GoalEntity
{
public:
	int32_t m_iFormation; // 0x548	
};

// Alignment: 28
// Size: 0x680
class CAI_LeadGoal : public CAI_GoalEntity
{
public:
	bool m_fArrived; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad0541[0x3]; 	// 0x541
public:
	float m_flWaitDistance; // 0x544	
	float m_flLeadDistance; // 0x548	
	float m_flRetrieveDistance; // 0x54c	
	float m_flSuccessDistance; // 0x550	
	bool m_bRun; // 0x554	
private:
	[[maybe_unused]] uint8_t __pad0555[0x3]; 	// 0x555
public:
	int32_t m_iRetrievePlayer; // 0x558	
	int32_t m_iRetrieveWaitForSpeak; // 0x55c	
	int32_t m_iComingBackWaitForSpeak; // 0x560	
	bool m_bStopScenesWhenPlayerLost; // 0x564	
	bool m_bDontSpeakStart; // 0x565	
	bool m_bLeadDuringCombat; // 0x566	
	bool m_bGagLeader; // 0x567	
	CUtlSymbolLarge m_iszWaitPointName; // 0x568	
	CUtlSymbolLarge m_iszStartConceptModifier; // 0x570	
	CUtlSymbolLarge m_iszAttractPlayerConceptModifier; // 0x578	
	CUtlSymbolLarge m_iszWaitOverConceptModifier; // 0x580	
	CUtlSymbolLarge m_iszArrivalConceptModifier; // 0x588	
	CUtlSymbolLarge m_iszPostArrivalConceptModifier; // 0x590	
	CUtlSymbolLarge m_iszSuccessConceptModifier; // 0x598	
	CUtlSymbolLarge m_iszFailureConceptModifier; // 0x5a0	
	CUtlSymbolLarge m_iszRetrieveConceptModifier; // 0x5a8	
	CUtlSymbolLarge m_iszComingBackConceptModifier; // 0x5b0	
	CEntityIOOutput m_OnArrival; // 0x5b8	
	CEntityIOOutput m_OnArrivalDone; // 0x5e0	
	CEntityIOOutput m_OnSuccess; // 0x608	
	CEntityIOOutput m_OnFailure; // 0x630	
	CEntityIOOutput m_OnDone; // 0x658	
};

// Alignment: 2
// Size: 0x690
class CAI_LeadGoal_Weapon : public CAI_LeadGoal
{
public:
	CUtlSymbolLarge m_iszWeaponName; // 0x680	
	CUtlSymbolLarge m_iszMissingWeaponConceptModifier; // 0x688	
};

// Alignment: 5
// Size: 0x510
class CAI_BattleLine : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszActor; // 0x4f0	
	bool m_fActive; // 0x4f8	
	bool m_fStrict; // 0x4f9	
	bool m_bMatchByNameOnly; // 0x4fa	
private:
	[[maybe_unused]] uint8_t __pad04fb[0x1]; 	// 0x4fb
public:
	CAI_MoveMonitor m_SelfMoveMonitor; // 0x4fc	
};

// Alignment: 6
// Size: 0x568
class CAI_StandoffGoal : public CAI_GoalEntity
{
public:
	CAI_StandoffGoal::Aggressiveness_t m_aggressiveness; // 0x538	
	AI_HintChangeReaction_t m_HintChangeReaction; // 0x53c	
	bool m_fPlayerIsBattleline; // 0x540	
	bool m_fStayAtCover; // 0x541	
	bool m_bAbandonIfEnemyHides; // 0x542	
private:
	[[maybe_unused]] uint8_t __pad0543[0x1]; 	// 0x543
public:
	AI_StandoffParams_t m_customParams; // 0x544	
};

// Alignment: 9
// Size: 0x588
class CAI_ScriptedBase : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszNPC; // 0x4f0	
	CUtlSymbolLarge m_iszTarget; // 0x4f8	
	bool m_bResilient; // 0x500	
	bool m_bShouldSetEnemy; // 0x501	
	bool m_bSwitchIdleToAlert; // 0x502	
private:
	[[maybe_unused]] uint8_t __pad0503[0x5]; 	// 0x503
public:
	CUtlVector< CHandle< CAI_DefaultNPC > > m_vecReapplyToTargets; // 0x508	
	CUtlVector< CHandle< CBaseEntity > > m_vecTargetOverrides; // 0x520	
	CEntityIOOutput m_OnFailedToPerform; // 0x538	
	CEntityIOOutput m_OnSucceeded; // 0x560	
};

// Alignment: 3
// Size: 0x598
class CAI_ScriptedAbilityUsage : public CAI_ScriptedBase
{
public:
	CUtlSymbolLarge m_iszAbilityName; // 0x588	
	BodyLocations_t m_nAbilityTargetBodyLoc; // 0x590	
	TargetOriginType_t m_nAbilityTargetOrigin; // 0x594	
};

// Alignment: 1
// Size: 0x590
class CAI_ScriptedIdle : public CAI_ScriptedBase
{
public:
	Interruptability_t m_Interruptability; // 0x588	
};

// Alignment: 2
// Size: 0x590
class CAI_ScriptedMoveTo : public CAI_ScriptedBase
{
public:
	Interruptability_t m_Interruptability; // 0x588	
	ScriptedMovementType_t m_MovementType; // 0x58c	
};

// Alignment: 18
// Size: 0x558
class CBaseNPCAbility : public CBaseEntity
{
public:
	// MNetworkEnable
	CHandle< CNPCAbilityModel > m_hAbilityModel; // 0x4f0	
	// MNetworkEnable
	CHandle< CBaseNPCAbility > m_hLinkedAbility; // 0x4f4	
	// MNetworkEnable
	bool m_bHeld; // 0x4f8	
	// MNetworkEnable
	bool m_bEnabled; // 0x4f9	
	// MNetworkEnable
	bool m_bPrimaryAbility; // 0x4fa	
private:
	[[maybe_unused]] uint8_t __pad04fb[0xd]; 	// 0x4fb
public:
	bool m_bGenerateTargetname; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad0509[0x3]; 	// 0x509
public:
	int32_t m_iAmmoCount; // 0x50c	
	float m_flCooldownReadyTime; // 0x510	
	float m_flAdditionalAttackDelay; // 0x514	
	float m_flGatherConditionsPollTime; // 0x518	
	float m_flLastTriggeredAt; // 0x51c	
	CUtlStringToken m_autoRepeatFinishTag; // 0x520	
	ConditionId_t m_nCustomUsabilityCondition; // 0x524	
	ConditionId_t m_nCustomMoveAndUseCondition; // 0x528	
	bool m_bReceivedAutoRepeatFinishedTag; // 0x52c	
	bool m_bWasAddedByVData; // 0x52d	
	bool m_bParticipatesInCanUseAnyAbility; // 0x52e	
private:
	[[maybe_unused]] uint8_t __pad052f[0x1]; 	// 0x52f
public:
	// MNetworkEnable
	// MNetworkVarEmbeddedNotFlattened
	// MNetworkSendProxyRecipientsFilter
	NPCAbilityTarget_t m_UsageTarget; // 0x530	
};

// Alignment: 0
// Size: 0x558
class CNPCAbilityAddModifier : public CBaseNPCAbility
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x558
class CNPCAbilityRemoveModifier : public CBaseNPCAbility
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x558
class CNPCAbilityBaseRanged : public CBaseNPCAbility
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x558
class CNPCAbilityMeleeAttack : public CBaseNPCAbility
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x570
class CNPCAbilitySpawn : public CBaseNPCAbility
{
public:
	CUtlVector< CHandle< CAI_DefaultNPC > > m_vecSpawnedNPCs; // 0x558	
};

// Alignment: 6
// Size: 0x590
class CNPCWeaponHitscan : public CBaseNPCAbility
{
public:
	float m_flNextTimeToFireBullet; // 0x558	
	int32_t m_nShotsToFire; // 0x55c	
	float m_flDelayOcclusionMarkingUntil; // 0x560	
	int32_t m_nCurrentBurstShotsOccluded; // 0x564	
	HitscanGatherData_t m_GatherData; // 0x568	
	AttachmentHandle_t m_nTracerAttachmentIndex; // 0x588	
};

// Alignment: 1
// Size: 0x10
class CTrackedObject_MODIFIER_TRACKED_PARTICLE : public IModifierTrackedObject
{
public:
	ModifierTrackedParticle_t m_objectData; // 0x8	
};

// Alignment: 1
// Size: 0x20
class CTrackedObject_MODIFIER_TRACKED_RENDER_ATTRIBUTE : public IModifierTrackedObject
{
public:
	ModifierRenderAttribute_t m_objectData; // 0x8	
};

// Alignment: 1
// Size: 0x28
class CTrackedObject_MODIFIER_TRACKED_GRAPH_PARAMETER : public IModifierTrackedObject
{
public:
	ModifierTrackedGraphParameter_t m_objectData; // 0x8	
};

// Alignment: 1
// Size: 0x10
class CTrackedObject_MODIFIER_TRACKED_SOUND : public IModifierTrackedObject
{
public:
	ModifierTrackedSound_t m_objectData; // 0x8	
};

// Alignment: 1
// Size: 0x18
class CTrackedObject_MODIFIER_TRACKED_BODYGROUP : public IModifierTrackedObject
{
public:
	ModifierTrackedBodyGroup_t m_objectData; // 0x8	
};

// Alignment: 2
// Size: 0xa0
class CBaseModifierAura : public CSteamPalModifier
{
public:
	CUtlVector< CHandle< CBaseEntity > > m_hAuraUnits; // 0x80	
	ParticleIndex_t m_hAmbientEffect; // 0x98	
};

// Alignment: 2
// Size: 0x510
class CPointModifierThinker : public CBaseEntity
{
public:
	CModifierHandleTyped< CSteamPalModifier > m_hModifier; // 0x4f0	
	bool m_bSendToClients; // 0x508	
};

// Alignment: 1
// Size: 0x4f8
class CSteamPalGameRulesProxy : public CGameRulesProxy
{
public:
	// MNetworkEnable
	CSteamPalGameRules* m_pSteamPalGameRules; // 0x4f0	
};

// Alignment: 0
// Size: 0xa0
class CSteamPalModifierAura : public CBaseModifierAura
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0xa0
class CSteamPalModifierAura_Default : public CSteamPalModifierAura
{
public:
	// @note: no members available
};

// Alignment: 8
// Size: 0x520
class CSteampal_Turret_Manager : public CBaseEntity
{
public:
	int32_t m_nNumTurretsSpawned; // 0x4f0	
	int32_t m_nNumIntroToiletsSpawned; // 0x4f4	
	CHandle< CSteamPal_Turret > m_hSpawnedTurret; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	CUtlSymbolLarge m_szSpawnTarget; // 0x500	
	CHandle< CBaseEntity > m_hSpawnTarget; // 0x508	
	bool m_bTakeControlOfTurretsOnSpawn; // 0x50c	
	bool m_bTakeOverCamera; // 0x50d	
private:
	[[maybe_unused]] uint8_t __pad050e[0x2]; 	// 0x50e
public:
	Vector m_vQueuedExplosionPos; // 0x510	
};

// Alignment: 20
// Size: 0x570
class CSteamPal_Sequencer : public CBaseEntity
{
public:
	CUtlString m_strCurrentSequence; // 0x4f0	
	float m_flStartTime; // 0x4f8	
	float m_flTimePaused; // 0x4fc	
	bool m_bAtBeginning; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0501[0x3]; 	// 0x501
public:
	float m_flCurSpeedPct; // 0x504	
	float m_flLastScrollTime; // 0x508	
	float m_flTimeLastSixteenthNote; // 0x50c	
	int32_t m_nNextSixteenthNote; // 0x510	
	int32_t m_nShowingTrack; // 0x514	
	int32_t m_nEditGridX; // 0x518	
	int32_t m_nEditGridY; // 0x51c	
	float m_flTimeLastEditGridMove; // 0x520	
private:
	[[maybe_unused]] uint8_t __pad0524[0x4]; 	// 0x524
public:
	CUtlVector< CSteamPal_SequencerSequenceDef_t > m_vSequences; // 0x528	
	CUtlVector< CHandle< CSteamPal_BaseSingingEntity > > m_Singers; // 0x540	
	float m_flTimePlayerStartedPressingNote; // 0x558	
	float m_flTimeLastPlayerNoteSaved; // 0x55c	
	int32_t m_nLastNoteIndexSaved; // 0x560	
	char m_cLastPlayerNoteInputSaved; // 0x564	
	bool m_bStartThinking; // 0x565	
private:
	[[maybe_unused]] uint8_t __pad0566[0x2]; 	// 0x566
public:
	int32_t m_nCurrentIntroSequence; // 0x568	
};

// Alignment: 19
// Size: 0x548
class CSteamPal_NameForm : public CBaseEntity
{
public:
	bool m_bBeginOnActivate; // 0x4f8	
	bool m_bAutoAdvanceTasks; // 0x4f9	
	bool m_bDebugDraw; // 0x4fa	
private:
	[[maybe_unused]] uint8_t __pad04fb[0x5]; 	// 0x4fb
public:
	CUtlSymbolLarge m_strWritingSurfaceOverride; // 0x500	
	// MNetworkEnable
	float m_flTimeUserLastDidUsefulActivity; // 0x508	
	// MNetworkEnable
	float m_flDurationCurrentTask; // 0x50c	
	// MNetworkEnable
	float m_flTimeStartedCurrentTask; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0514[0x4]; 	// 0x514
public:
	// MNetworkEnable
	// MNetworkChangeCallback "TypedNameChanged"
	CUtlString m_strTypedName; // 0x518	
	// MNetworkEnable
	bool m_bIsTaskSuccess; // 0x520	
private:
	[[maybe_unused]] uint8_t __pad0521[0x3]; 	// 0x521
public:
	// MNetworkEnable
	float m_flLastMicLevel; // 0x524	
	// MNetworkEnable
	bool m_bIsRecording; // 0x528	
	// MNetworkEnable
	bool m_bIsWarmingUpMicrophone; // 0x529	
private:
	[[maybe_unused]] uint8_t __pad052a[0x2]; 	// 0x52a
public:
	// MNetworkEnable
	int32_t m_nNumFramesOfAudioDBsRecorded; // 0x52c	
	// MNetworkEnable
	bool m_bUserTypedWithKeyboard; // 0x530	
	// MNetworkEnable
	bool m_bIsShowingWritingSurface; // 0x531	
private:
	[[maybe_unused]] uint8_t __pad0532[0x2]; 	// 0x532
public:
	// MNetworkEnable
	float m_flFrameRateLimitBeforeDrawing; // 0x534	
	// MNetworkEnable
	CHandle< CSteamPal_Desk > m_hDesk; // 0x538	
	// MNetworkEnable
	CHandle< CSteamPal_WritingSurface > m_hWritingSurface; // 0x53c	
	// MNetworkEnable
	CHandle< CInfoOffscreenPanoramaTexture > m_hOffscreenTexture; // 0x540	
};

// Alignment: 3
// Size: 0x500
class CSteamPal_Turret_Laser : public CBaseEntity
{
public:
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hTurret; // 0x4f0	
	// MNetworkEnable
	bool m_bIsLaserOn; // 0x4f4	
private:
	[[maybe_unused]] uint8_t __pad04f5[0x3]; 	// 0x4f5
public:
	CUtlSymbolLarge m_szTurretName; // 0x4f8	
};

// Alignment: 14
// Size: 0x570
class CSteamPal_Turret_Wing : public CBaseEntity
{
public:
	// MNetworkEnable
	CHandle< CSteamPal_Turret > m_hTurret; // 0x4f0	
	// MNetworkEnable
	bool m_bIsLeftWing; // 0x4f4	
	// MNetworkEnable
	bool m_bBeingControlled; // 0x4f5	
	AttachmentHandle_t m_nMuzzleAttachments[2]; // 0x4f6	
	// MNetworkEnable
	int32_t m_nCurrentMuzzle; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	CUtlString m_strWingOutParam; // 0x500	
	CUtlString m_strWingAimXParam; // 0x508	
	CUtlString m_strWingAimYParam; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0518[0x3c]; 	// 0x518
public:
	float m_flNextAttackTime; // 0x554	
	float m_flCurrentWingDeploy; // 0x558	
	float m_flCurrentAimX; // 0x55c	
	float m_flCurrentAimY; // 0x560	
	bool m_bSynchedWings; // 0x564	
private:
	[[maybe_unused]] uint8_t __pad0565[0x3]; 	// 0x565
public:
	float m_flSndLastVal; // 0x568	
};

// Alignment: 23
// Size: 0x6e8
class CSteamPalConveyorEntitySpawner : public CLogicalEntity
{
public:
	bool m_bSpawnAlongConveyorOnStartup; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_flProbabilityToSpawnAlongConveyor; // 0x4f4	
	bool m_bAutoSpawnEntities; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04f9[0x3]; 	// 0x4f9
public:
	float m_flProbabilityToAutoSpawn; // 0x4fc	
	CSteamPalConveyorEntitySpawner::SpawnOrder_t m_eSpawnOrder; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_szSpawnConveyorPathNodeOverride; // 0x508	
	CUtlString m_strSpawnConveyorPathNodeOverride; // 0x510	
	CUtlSymbolLarge m_szSpawnAnglesTargetOverride; // 0x518	
	CHandle< CBaseEntity > m_hAnglesOverrideTarget; // 0x520	
private:
	[[maybe_unused]] uint8_t __pad0524[0x4]; 	// 0x524
public:
	CUtlSymbolLarge m_szSpawnTemplates[16]; // 0x528	
	CHandle< CSteamPalConveyor > m_hConveyor; // 0x5a8	
private:
	[[maybe_unused]] uint8_t __pad05ac[0x4]; 	// 0x5ac
public:
	CEntityIOOutput m_OnSpawnedAlongConveyor; // 0x5b0	
	CEntityIOOutput m_OnSpawnedOnStartingNode; // 0x5d8	
	CEntityIOOutput m_OnPassedSpawnNode; // 0x600	
private:
	[[maybe_unused]] uint8_t __pad0628[0x30]; 	// 0x628
public:
	bool m_bSpawningAlongConveyor; // 0x658	
private:
	[[maybe_unused]] uint8_t __pad0659[0x7]; 	// 0x659
public:
	CUtlVector< CEntityHandle > m_hSpawnedAlongConveyorEntities; // 0x660	
	CUtlVector< int32 > m_ValidTemplateIndexes; // 0x678	
	CUtlVector< int32 > m_ShuffleTemplateIndexes; // 0x690	
	int32_t m_nNextSequenceIndex; // 0x6a8	
private:
	[[maybe_unused]] uint8_t __pad06ac[0x4]; 	// 0x6ac
public:
	CUtlVector< CUtlString > m_LargePropTemplateNames; // 0x6b0	
	CUtlVector< int32 > m_LargePropTemplateIndexes; // 0x6c8	
	bool m_bPreviousSpawnWasLargeEntity; // 0x6e0	
	bool m_bAutoSpawnedSomethingOnPreviousSegment; // 0x6e1	
};

// Alignment: 28
// Size: 0x6d8
class CSteamPalConveyor : public CBaseEntity
{
public:
	float m_flPathLength; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad0544[0x4]; 	// 0x544
public:
	CUtlSymbolLarge m_szConveyorModels; // 0x548	
	float m_flMoveSpeed; // 0x550	
	bool m_bStartOn; // 0x554	
	bool m_bPrecreateConveyorSegmentSpawnTargets; // 0x555	
private:
	[[maybe_unused]] uint8_t __pad0556[0x2]; 	// 0x556
public:
	CUtlSymbolLarge m_szDestinationNode; // 0x558	
	CHandle< CSteamPalConveyorPathNode > m_hDestinationNode; // 0x560	
	bool m_bHasReachedDestination; // 0x564	
private:
	[[maybe_unused]] uint8_t __pad0565[0x3]; 	// 0x565
public:
	int32_t m_nDestinationSectionIndex; // 0x568	
	int32_t m_nDestinationSegmentIndex; // 0x56c	
	Vector m_vReferenceSegmentSizeMins; // 0x570	
	Vector m_vReferenceSegmentSizeMaxs; // 0x57c	
	Vector m_vReferenceSegmentSize; // 0x588	
	Vector m_vActualSegmentSize; // 0x594	
	CUtlVector< SteampalConveyorSection_t > m_ConveyorSections; // 0x5a0	
private:
	[[maybe_unused]] uint8_t __pad05b8[0x28]; 	// 0x5b8
public:
	CUtlSymbolLarge m_szConveyorEntitySpawner; // 0x5e0	
	CHandle< CSteamPalConveyorEntitySpawner > m_hConveyorEntitySpawner; // 0x5e8	
	CHandle< CSteamPalConveyorPathNode > m_hSpawnerSpawnNode; // 0x5ec	
	float m_flLastThinkTime; // 0x5f0	
private:
	[[maybe_unused]] uint8_t __pad05f4[0x4]; 	// 0x5f4
public:
	CEntityIOOutput m_OnStart; // 0x5f8	
	CEntityIOOutput m_OnStop; // 0x620	
	CEntityIOOutput m_OnReset; // 0x648	
	CEntityIOOutput m_OnReachedDestination; // 0x670	
	// MNetworkEnable
	bool m_bMoving; // 0x698	
private:
	[[maybe_unused]] uint8_t __pad0699[0x3]; 	// 0x699
public:
	// MNetworkEnable
	float m_flCurrentSpeed; // 0x69c	
	// MNetworkEnable
	float m_flAnimationDirection; // 0x6a0	
private:
	[[maybe_unused]] uint8_t __pad06a4[0x4]; 	// 0x6a4
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseAnimating > > m_hConveyorModels; // 0x6a8	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CSteamPalConveyorPathNode > > m_hPathNodes; // 0x6c0	
};

// Alignment: 9
// Size: 0x540
class CSteamPal_PaintStreamPathNode : public CBaseEntity
{
public:
	float m_flNodeT; // 0x4f0	
	float m_flSegmentLength; // 0x4f4	
	float m_flPathLengthUpToNode; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	CUtlSymbolLarge m_szParentPathUniqueID; // 0x500	
	int32_t m_nPathIndex; // 0x508	
	Vector m_vInTangentLocal; // 0x50c	
	Vector m_vOutTangentLocal; // 0x518	
	// MNetworkEnable
	Vector m_vInTangentWorld; // 0x524	
	// MNetworkEnable
	Vector m_vOutTangentWorld; // 0x530	
};

// Alignment: 7
// Size: 0x570
class CSteamPal_PaintStream : public CBaseEntity
{
public:
	bool m_bStartOn; // 0x4f0	
	// MNetworkEnable
	bool m_bIsOn; // 0x4f1	
private:
	[[maybe_unused]] uint8_t __pad04f2[0x2]; 	// 0x4f2
public:
	// MNetworkEnable
	float m_flSpeed; // 0x4f4	
	// MNetworkEnable
	float m_flPathLength; // 0x4f8	
	// MNetworkEnable
	int32_t m_nNumPaintBlobs; // 0x4fc	
	// MNetworkEnable
	SteamPalPaintType m_PaintType; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CSteamPal_PaintStreamPathNode > > m_hPathNodes; // 0x508	
};

// Alignment: 4
// Size: 0x508
class CSteamPal_Projectile_Tag_Marker : public CBaseEntity
{
public:
	ParticleIndex_t m_nMarkerParticle; // 0x4f0	
	SteamPal_Projectile_Tag_Marker_Type_t m_eMarkerType; // 0x4f4	
	CHandle< CBaseEntity > m_hMarkedEntity; // 0x4f8	
	Vector m_vExplosionPos; // 0x4fc	
};

// Alignment: 13
// Size: 0x5d0
class CSteamPalCameraPathNode : public CBaseEntity
{
public:
	CEntityOutputTemplate< int32 > m_OnPass; // 0x4f0	
	CEntityOutputTemplate< int32 > m_OnPassForward; // 0x518	
	CEntityOutputTemplate< int32 > m_OnPassBackward; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad0568[0x18]; 	// 0x568
public:
	CUtlSymbolLarge m_szParentPathUniqueID; // 0x580	
	int32_t m_nPathIndex; // 0x588	
	Vector m_vInTangentLocal; // 0x58c	
	Vector m_vOutTangentLocal; // 0x598	
	float m_flFOV; // 0x5a4	
	float m_flSpeed; // 0x5a8	
	float m_flEaseIn; // 0x5ac	
	float m_flEaseOut; // 0x5b0	
	Vector m_vInTangentWorld; // 0x5b4	
	Vector m_vOutTangentWorld; // 0x5c0	
};

// Alignment: 9
// Size: 0x678
class CSteamPalCameraPath : public CBaseEntity
{
public:
	CEntityIOOutput m_OnTransitionTo; // 0x4f0	
	CEntityIOOutput m_OnTransitionFrom; // 0x518	
	CEntityIOOutput m_OnStart; // 0x540	
	CEntityIOOutput m_OnStop; // 0x568	
	CEntityIOOutput m_OnReset; // 0x590	
	CEntityIOOutput m_OnCompletion; // 0x5b8	
private:
	[[maybe_unused]] uint8_t __pad05e0[0x78]; 	// 0x5e0
public:
	// MNetworkEnable
	bool m_bRelativeFOV; // 0x658	
private:
	[[maybe_unused]] uint8_t __pad0659[0x3]; 	// 0x659
public:
	// MNetworkEnable
	Vector m_flFOVData; // 0x65c	
	// MNetworkEnable
	Vector m_vVelocity; // 0x668	
};

// Alignment: 5
// Size: 0x550
class CSteamPalPointCamera : public CBaseEntity
{
public:
	CEntityIOOutput m_OnTransitionTo; // 0x4f0	
	CEntityIOOutput m_OnTransitionFrom; // 0x518	
	// MNetworkEnable
	bool m_bRelativeFOV; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad0541[0x3]; 	// 0x541
public:
	// MNetworkEnable
	float m_flFOV; // 0x544	
	// MNetworkEnable
	bool m_bActive; // 0x548	
};

// Alignment: 2
// Size: 0x568
class CNPCApplianceWeaponBullets : public CBaseNPCAbility
{
public:
	float m_flTimeToStop; // 0x560	
	AttachmentHandle_t m_nTracerAttachmentIndex; // 0x564	
};

// Alignment: 2
// Size: 0x578
class CNPCApplianceWeaponProjectiles : public CBaseNPCAbility
{
public:
	ApplianceWeaponState m_eState; // 0x558	
private:
	[[maybe_unused]] uint8_t __pad055c[0x4]; 	// 0x55c
public:
	CUtlVector< NPCApplianceProjectileRuntime_t > m_vecProjectileInfo; // 0x560	
};

// Alignment: 2
// Size: 0x508
class CSteampalKillVolume : public CBaseEntity
{
public:
	Vector m_vBoxMins; // 0x4f0	
	Vector m_vBoxMaxs; // 0x4fc	
};

// Alignment: 4
// Size: 0x548
class CBaseCurveOverTime : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bLooping; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	// MNetworkEnable
	CUtlSymbolLarge m_CurveString; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad0500[0x40]; 	// 0x500
public:
	bool m_bStartEnabled; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad0541[0x3]; 	// 0x541
public:
	// MNetworkEnable
	float m_flStartTime; // 0x544	
};

// Alignment: 2
// Size: 0x560
class CPointRenderAttrCurve : public CBaseCurveOverTime
{
public:
	// MNetworkEnable
	CUtlSymbolLarge m_AttrName; // 0x548	
	// MNetworkEnable
	CUtlSymbolLarge m_ActiveComboName; // 0x550	
};

// Alignment: 7
// Size: 0x5a0
class CLogicAnimTagListener : public CLogicalEntity
{
public:
	bool m_bStartDisabled; // 0x508	
	// MNetworkEnable
	bool m_bEnabled; // 0x509	
private:
	[[maybe_unused]] uint8_t __pad050a[0x6]; 	// 0x50a
public:
	CUtlSymbolLarge m_szAnimTag; // 0x510	
	CUtlSymbolLarge m_szModelName; // 0x518	
	CEntityIOOutput m_OnTagFired; // 0x520	
	CEntityIOOutput m_OnTagStart; // 0x548	
	CEntityIOOutput m_OnTagEnd; // 0x570	
};

// Alignment: 0
// Size: 0x4f0
class CPointEntity : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 20
// Size: 0x1648
class CEnvCombinedLightProbeVolume : public CBaseEntity
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "StateChanged"
	Color m_Color; // 0x15b0	
	// MNetworkEnable
	// MNetworkChangeCallback "StateChanged"
	float m_flBrightness; // 0x15b4	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hCubemapTexture; // 0x15b8	
	// MNetworkEnable
	bool m_bCustomCubemapTexture; // 0x15c0	
private:
	[[maybe_unused]] uint8_t __pad15c1[0x7]; 	// 0x15c1
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeTexture; // 0x15c8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightIndicesTexture; // 0x15d0	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightScalarsTexture; // 0x15d8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightShadowsTexture; // 0x15e0	
	// MNetworkEnable
	Vector m_vBoxMins; // 0x15e8	
	// MNetworkEnable
	Vector m_vBoxMaxs; // 0x15f4	
	// MNetworkEnable
	CUtlSymbolLarge m_LightGroups; // 0x1600	
	// MNetworkEnable
	bool m_bMoveable; // 0x1608	
private:
	[[maybe_unused]] uint8_t __pad1609[0x3]; 	// 0x1609
public:
	// MNetworkEnable
	int32_t m_nHandshake; // 0x160c	
	// MNetworkEnable
	int32_t m_nEnvCubeMapArrayIndex; // 0x1610	
	// MNetworkEnable
	int32_t m_nPriority; // 0x1614	
	// MNetworkEnable
	int32_t m_nGgxCubemapBlurAccumulationPassCount; // 0x1618	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x161c	
private:
	[[maybe_unused]] uint8_t __pad161d[0x3]; 	// 0x161d
public:
	// MNetworkEnable
	float m_flEdgeFadeDist; // 0x1620	
	// MNetworkEnable
	Vector m_vEdgeFadeDists; // 0x1624	
private:
	[[maybe_unused]] uint8_t __pad1630[0x11]; 	// 0x1630
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x1641	
};

// Alignment: 21
// Size: 0x660
class CEnvCubemap : public CBaseEntity
{
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hCubemapTexture; // 0x5e8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hDepthmapTexture; // 0x5f0	
	// MNetworkEnable
	bool m_bCustomCubemapTexture; // 0x5f8	
private:
	[[maybe_unused]] uint8_t __pad05f9[0x3]; 	// 0x5f9
public:
	// MNetworkEnable
	float m_flInfluenceRadius; // 0x5fc	
	// MNetworkEnable
	Vector m_vBoxProjectMins; // 0x600	
	// MNetworkEnable
	Vector m_vBoxProjectMaxs; // 0x60c	
	// MNetworkEnable
	CUtlSymbolLarge m_LightGroups; // 0x618	
	// MNetworkEnable
	bool m_bMoveable; // 0x620	
private:
	[[maybe_unused]] uint8_t __pad0621[0x3]; 	// 0x621
public:
	// MNetworkEnable
	int32_t m_nHandshake; // 0x624	
	// MNetworkEnable
	int32_t m_nEnvCubeMapArrayIndex; // 0x628	
	// MNetworkEnable
	int32_t m_nPriority; // 0x62c	
	// MNetworkEnable
	int32_t m_nGgxCubemapBlurAccumulationPassCount; // 0x630	
	// MNetworkEnable
	float m_flEdgeFadeDist; // 0x634	
	// MNetworkEnable
	Vector m_vEdgeFadeDists; // 0x638	
	// MNetworkEnable
	float m_flDiffuseScale; // 0x644	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x648	
	// MNetworkEnable
	bool m_bDefaultEnvMap; // 0x649	
	// MNetworkEnable
	bool m_bDefaultSpecEnvMap; // 0x64a	
	// MNetworkEnable
	bool m_bRenderDepthMap; // 0x64b	
	// MNetworkEnable
	bool m_bCopyDiffuseFromDefaultCubemap; // 0x64c	
private:
	[[maybe_unused]] uint8_t __pad064d[0xb]; 	// 0x64d
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x658	
};

// Alignment: 0
// Size: 0x660
class CEnvCubemapBox : public CEnvCubemap
{
public:
	// @note: no members available
};

// Alignment: 18
// Size: 0x540
class CEnvCubemapFog : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flEndDistance; // 0x4f0	
	// MNetworkEnable
	float m_flStartDistance; // 0x4f4	
	// MNetworkEnable
	float m_flFogFalloffExponent; // 0x4f8	
	// MNetworkEnable
	bool m_bHeightFogEnabled; // 0x4fc	
private:
	[[maybe_unused]] uint8_t __pad04fd[0x3]; 	// 0x4fd
public:
	// MNetworkEnable
	float m_flFogHeightWidth; // 0x500	
	// MNetworkEnable
	float m_flFogHeightEnd; // 0x504	
	// MNetworkEnable
	float m_flFogHeightStart; // 0x508	
	// MNetworkEnable
	float m_flFogHeightExponent; // 0x50c	
	// MNetworkEnable
	float m_flLODBias; // 0x510	
	// MNetworkEnable
	bool m_bActive; // 0x514	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x515	
private:
	[[maybe_unused]] uint8_t __pad0516[0x2]; 	// 0x516
public:
	// MNetworkEnable
	float m_flFogMaxOpacity; // 0x518	
	// MNetworkEnable
	int32_t m_nCubemapSourceType; // 0x51c	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hSkyMaterial; // 0x520	
	// MNetworkEnable
	CUtlSymbolLarge m_iszSkyEntity; // 0x528	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hFogCubemapTexture; // 0x530	
	// MNetworkEnable
	bool m_bHasHeightFogEnd; // 0x538	
	bool m_bFirstTime; // 0x539	
};

// Alignment: 12
// Size: 0x1518
class CEnvLightProbeVolume : public CBaseEntity
{
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeTexture; // 0x14b8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightIndicesTexture; // 0x14c0	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightScalarsTexture; // 0x14c8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightProbeDirectLightShadowsTexture; // 0x14d0	
	// MNetworkEnable
	Vector m_vBoxMins; // 0x14d8	
	// MNetworkEnable
	Vector m_vBoxMaxs; // 0x14e4	
	// MNetworkEnable
	CUtlSymbolLarge m_LightGroups; // 0x14f0	
	// MNetworkEnable
	bool m_bMoveable; // 0x14f8	
private:
	[[maybe_unused]] uint8_t __pad14f9[0x3]; 	// 0x14f9
public:
	// MNetworkEnable
	int32_t m_nHandshake; // 0x14fc	
	// MNetworkEnable
	int32_t m_nPriority; // 0x1500	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x1504	
private:
	[[maybe_unused]] uint8_t __pad1505[0xc]; 	// 0x1505
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x1511	
};

// Alignment: 8
// Size: 0x518
class CTonemapController2 : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flAutoExposureMin; // 0x4f0	
	// MNetworkEnable
	float m_flAutoExposureMax; // 0x4f4	
	// MNetworkEnable
	float m_flTonemapPercentTarget; // 0x4f8	
	// MNetworkEnable
	float m_flTonemapPercentBrightPixels; // 0x4fc	
	// MNetworkEnable
	float m_flTonemapMinAvgLum; // 0x500	
	// MNetworkEnable
	float m_flExposureAdaptationSpeedUp; // 0x504	
	// MNetworkEnable
	float m_flExposureAdaptationSpeedDown; // 0x508	
	// MNetworkEnable
	float m_flTonemapEVSmoothingRange; // 0x50c	
};

// Alignment: 28
// Size: 0x570
class CEnvVolumetricFogController : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_flScattering; // 0x4f0	
	// MNetworkEnable
	float m_flAnisotropy; // 0x4f4	
	// MNetworkEnable
	float m_flFadeSpeed; // 0x4f8	
	// MNetworkEnable
	float m_flDrawDistance; // 0x4fc	
	// MNetworkEnable
	float m_flFadeInStart; // 0x500	
	// MNetworkEnable
	float m_flFadeInEnd; // 0x504	
	// MNetworkEnable
	float m_flIndirectStrength; // 0x508	
	// MNetworkEnable
	int32_t m_nIndirectTextureDimX; // 0x50c	
	// MNetworkEnable
	int32_t m_nIndirectTextureDimY; // 0x510	
	// MNetworkEnable
	int32_t m_nIndirectTextureDimZ; // 0x514	
	// MNetworkEnable
	Vector m_vBoxMins; // 0x518	
	// MNetworkEnable
	Vector m_vBoxMaxs; // 0x524	
	// MNetworkEnable
	bool m_bActive; // 0x530	
private:
	[[maybe_unused]] uint8_t __pad0531[0x3]; 	// 0x531
public:
	// MNetworkEnable
	float m_flStartAnisoTime; // 0x534	
	// MNetworkEnable
	float m_flStartScatterTime; // 0x538	
	// MNetworkEnable
	float m_flStartDrawDistanceTime; // 0x53c	
	// MNetworkEnable
	float m_flStartAnisotropy; // 0x540	
	// MNetworkEnable
	float m_flStartScattering; // 0x544	
	// MNetworkEnable
	float m_flStartDrawDistance; // 0x548	
	// MNetworkEnable
	float m_flDefaultAnisotropy; // 0x54c	
	// MNetworkEnable
	float m_flDefaultScattering; // 0x550	
	// MNetworkEnable
	float m_flDefaultDrawDistance; // 0x554	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x558	
	// MNetworkEnable
	bool m_bEnableIndirect; // 0x559	
	// MNetworkEnable
	bool m_bIsMaster; // 0x55a	
private:
	[[maybe_unused]] uint8_t __pad055b[0x5]; 	// 0x55b
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hFogIndirectTexture; // 0x560	
	// MNetworkEnable
	int32_t m_nForceRefreshCount; // 0x568	
	bool m_bFirstTime; // 0x56c	
};

// Alignment: 7
// Size: 0x520
class CEnvVolumetricFogVolume : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bActive; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	// MNetworkEnable
	Vector m_vBoxMins; // 0x4f4	
	// MNetworkEnable
	Vector m_vBoxMaxs; // 0x500	
	// MNetworkEnable
	bool m_bStartDisabled; // 0x50c	
private:
	[[maybe_unused]] uint8_t __pad050d[0x3]; 	// 0x50d
public:
	// MNetworkEnable
	float m_flStrength; // 0x510	
	// MNetworkEnable
	int32_t m_nFalloffShape; // 0x514	
	// MNetworkEnable
	float m_flFalloffExponent; // 0x518	
};

// Alignment: 3
// Size: 0x560
class CFogController : public CBaseEntity
{
public:
	// MNetworkEnable
	fogparams_t m_fog; // 0x4f0	
	bool m_bUseAngles; // 0x558	
private:
	[[maybe_unused]] uint8_t __pad0559[0x3]; 	// 0x559
public:
	int32_t m_iChangedVariables; // 0x55c	
};

// Alignment: 0
// Size: 0x4f0
class CInfoTarget : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CInfoParticleTarget : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x508
class CInfoVisibilityBox : public CBaseEntity
{
public:
	// MNetworkEnable
	int32_t m_nMode; // 0x4f4	
	// MNetworkEnable
	Vector m_vBoxSize; // 0x4f8	
	// MNetworkEnable
	bool m_bEnabled; // 0x504	
};

// Alignment: 7
// Size: 0x530
class CInfoWorldLayer : public CBaseEntity
{
public:
	CEntityIOOutput m_pOutputOnEntitiesSpawned; // 0x4f0	
	// MNetworkEnable
	CUtlSymbolLarge m_worldName; // 0x518	
	// MNetworkEnable
	CUtlSymbolLarge m_layerName; // 0x520	
	// MNetworkEnable
	bool m_bWorldLayerVisible; // 0x528	
	// MNetworkEnable
	bool m_bEntitiesSpawned; // 0x529	
	bool m_bCreateAsChildSpawnGroup; // 0x52a	
private:
	[[maybe_unused]] uint8_t __pad052b[0x1]; 	// 0x52b
public:
	uint32_t m_hLayerSpawnGroup; // 0x52c	
};

// Alignment: 8
// Size: 0x530
class CMultiLightProxy : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszLightNameFilter; // 0x4f0	
	CUtlSymbolLarge m_iszLightClassFilter; // 0x4f8	
	float m_flLightRadiusFilter; // 0x500	
	float m_flBrightnessDelta; // 0x504	
	bool m_bPerformScreenFade; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad0509[0x3]; 	// 0x509
public:
	float m_flTargetBrightnessMultiplier; // 0x50c	
	float m_flCurrentBrightnessMultiplier; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0514[0x4]; 	// 0x514
public:
	CUtlVector< CHandle< CLightEntity > > m_vecLights; // 0x518	
};

// Alignment: 24
// Size: 0x550
class CPointCamera : public CBaseEntity
{
public:
	// MNetworkEnable
	float m_FOV; // 0x4f0	
	// MNetworkEnable
	float m_Resolution; // 0x4f4	
	// MNetworkEnable
	bool m_bFogEnable; // 0x4f8	
	// MNetworkEnable
	Color m_FogColor; // 0x4f9	
private:
	[[maybe_unused]] uint8_t __pad04fd[0x3]; 	// 0x4fd
public:
	// MNetworkEnable
	float m_flFogStart; // 0x500	
	// MNetworkEnable
	float m_flFogEnd; // 0x504	
	// MNetworkEnable
	float m_flFogMaxDensity; // 0x508	
	// MNetworkEnable
	bool m_bActive; // 0x50c	
	// MNetworkEnable
	bool m_bUseScreenAspectRatio; // 0x50d	
private:
	[[maybe_unused]] uint8_t __pad050e[0x2]; 	// 0x50e
public:
	// MNetworkEnable
	float m_flAspectRatio; // 0x510	
	// MNetworkEnable
	bool m_bNoSky; // 0x514	
private:
	[[maybe_unused]] uint8_t __pad0515[0x3]; 	// 0x515
public:
	// MNetworkEnable
	float m_fBrightness; // 0x518	
	// MNetworkEnable
	float m_flZFar; // 0x51c	
	// MNetworkEnable
	float m_flZNear; // 0x520	
	// MNetworkEnable
	bool m_bDofEnabled; // 0x524	
private:
	[[maybe_unused]] uint8_t __pad0525[0x3]; 	// 0x525
public:
	// MNetworkEnable
	float m_flDofNearBlurry; // 0x528	
	// MNetworkEnable
	float m_flDofNearCrisp; // 0x52c	
	// MNetworkEnable
	float m_flDofFarCrisp; // 0x530	
	// MNetworkEnable
	float m_flDofFarBlurry; // 0x534	
	// MNetworkEnable
	float m_flDofTiltToGround; // 0x538	
	float m_TargetFOV; // 0x53c	
	float m_DegreesPerSecond; // 0x540	
	bool m_bIsOn; // 0x544	
private:
	[[maybe_unused]] uint8_t __pad0545[0x3]; 	// 0x545
public:
	CPointCamera* m_pNext; // 0x548	
};

// Alignment: 9
// Size: 0x518
class CPointCameraVFOV : public CBaseEntity
{
public:
	float m_flVerticalFOV; // 0x4f0	
	float m_flZFar; // 0x4f4	
	float m_flZNear; // 0x4f8	
	bool m_bDofEnabled; // 0x4fc	
private:
	[[maybe_unused]] uint8_t __pad04fd[0x3]; 	// 0x4fd
public:
	float m_flDofNearBlurry; // 0x500	
	float m_flDofNearCrisp; // 0x504	
	float m_flDofFarCrisp; // 0x508	
	float m_flDofFarBlurry; // 0x50c	
	float m_flDofTiltToGround; // 0x510	
};

// Alignment: 12
// Size: 0x580
class CPointTemplate : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszWorldName; // 0x4f0	
	CUtlSymbolLarge m_iszSource2EntityLumpName; // 0x4f8	
	CUtlSymbolLarge m_iszEntityFilterName; // 0x500	
	float m_flTimeoutInterval; // 0x508	
	bool m_bAsynchronouslySpawnEntities; // 0x50c	
private:
	[[maybe_unused]] uint8_t __pad050d[0x3]; 	// 0x50d
public:
	CEntityIOOutput m_pOutputOnSpawned; // 0x510	
	PointTemplateClientOnlyEntityBehavior_t m_clientOnlyEntityBehavior; // 0x538	
	PointTemplateOwnerSpawnGroupType_t m_ownerSpawnGroupType; // 0x53c	
	CUtlVector< uint32 > m_createdSpawnGroupHandles; // 0x540	
	CUtlVector< CEntityHandle > m_SpawnedEntityHandles; // 0x558	
	HSCRIPT m_ScriptSpawnCallback; // 0x570	
	HSCRIPT m_ScriptCallbackScope; // 0x578	
};

// Alignment: 4
// Size: 0x520
class CGameGibManager : public CBaseEntity
{
public:
	bool m_bAllowNewGibs; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0511[0x3]; 	// 0x511
public:
	int32_t m_iCurrentMaxPieces; // 0x514	
	int32_t m_iMaxPieces; // 0x518	
	int32_t m_iLastFrame; // 0x51c	
};

// Alignment: 3
// Size: 0x510
class CSoundAreaEntityBase : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	// MNetworkEnable
	CUtlSymbolLarge m_iszSoundAreaType; // 0x4f8	
	// MNetworkEnable
	Vector m_vPos; // 0x500	
};

// Alignment: 1
// Size: 0x518
class CSoundAreaEntitySphere : public CSoundAreaEntityBase
{
public:
	// MNetworkEnable
	float m_flRadius; // 0x510	
};

// Alignment: 2
// Size: 0x528
class CSoundAreaEntityOrientedBox : public CSoundAreaEntityBase
{
public:
	// MNetworkEnable
	Vector m_vMin; // 0x510	
	// MNetworkEnable
	Vector m_vMax; // 0x51c	
};

// Alignment: 3
// Size: 0x590
class CTeam : public CBaseEntity
{
public:
	// MNetworkEnable
	// MNetworkAlias "m_aPlayers"
	CNetworkUtlVectorBase< CHandle< CBasePlayerController > > m_aPlayerControllers; // 0x4f0	
	// MNetworkEnable
	int32_t m_iScore; // 0x508	
	// MNetworkEnable
	char m_szTeamname[129]; // 0x50c	
};

// Alignment: 1
// Size: 0x540
class CPlayerResource : public CBaseEntity
{
public:
	// MNetworkEnable
	CUtlVectorEmbeddedNetworkVar< PlayerResourceData_t > m_vecPlayerData; // 0x4f8	
};

// Alignment: 2
// Size: 0x500
class CInfoGameEventProxy : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszEventName; // 0x4f0	
	float m_flRange; // 0x4f8	
};

// Alignment: 2
// Size: 0x4f8
class CProjectedDecal : public CPointEntity
{
public:
	int32_t m_nTexture; // 0x4f0	
	float m_flDistance; // 0x4f4	
};

// Alignment: 28
// Size: 0x778
class CBaseModelEntity : public CBaseEntity
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "CRenderComponent"
	// MNetworkAlias "CRenderComponent"
	// MNetworkTypeAlias "CRenderComponent"
	CRenderComponent* m_CRenderComponent; // 0x4f0	
	// MNetworkEnable
	RenderMode_t m_nRenderMode; // 0x4f8	
	// MNetworkEnable
	RenderFx_t m_nRenderFX; // 0x4f9	
	bool m_bAllowFadeInView; // 0x4fa	
	// MNetworkEnable
	// MNetworkChangeCallback "OnColorChanged"
	Color m_clrRender; // 0x4fb	
private:
	[[maybe_unused]] uint8_t __pad04ff[0x1]; 	// 0x4ff
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnRenderAttributesChanged"
	CUtlStringToken m_RenderAttributeIDs[4]; // 0x500	
	// MNetworkEnable
	// MNetworkChangeCallback "OnRenderAttributesChanged"
	Vector4D m_RenderAttributeValues[4]; // 0x510	
	// MNetworkEnable
	// MNetworkChangeCallback "OnLightGroupChanged"
	CUtlStringToken m_LightGroup; // 0x550	
	// MNetworkEnable
	bool m_bRenderToCubemaps; // 0x554	
private:
	[[maybe_unused]] uint8_t __pad0555[0x3]; 	// 0x555
public:
	// MNetworkEnable
	CCollisionProperty m_Collision; // 0x558	
	// MNetworkEnable
	CGlowProperty m_Glow; // 0x608	
	// MNetworkEnable
	float m_flGlowBackfaceMult; // 0x658	
	// MNetworkEnable
	float m_fadeMinDist; // 0x65c	
	// MNetworkEnable
	float m_fadeMaxDist; // 0x660	
	// MNetworkEnable
	float m_flFadeScale; // 0x664	
	// MNetworkEnable
	float m_flShadowStrength; // 0x668	
	// MNetworkEnable
	uint8_t m_nObjectCulling; // 0x66c	
private:
	[[maybe_unused]] uint8_t __pad066d[0x3]; 	// 0x66d
public:
	// MNetworkEnable
	int32_t m_nAddDecal; // 0x670	
	// MNetworkEnable
	Vector m_vDecalPosition; // 0x674	
	// MNetworkEnable
	Vector m_vDecalForwardAxis; // 0x680	
	// MNetworkEnable
	float m_flDecalHealBloodRate; // 0x68c	
	// MNetworkEnable
	float m_flDecalHealHeightRate; // 0x690	
private:
	[[maybe_unused]] uint8_t __pad0694[0x4]; 	// 0x694
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseModelEntity > > m_ConfigEntitiesToPropagateMaterialDecalsTo; // 0x698	
	// MNetworkEnable
	// MNetworkPriority "32"
	// MNetworkUserGroup "Player"
	CNetworkViewOffsetVector m_vecViewOffset; // 0x6b0	
private:
	[[maybe_unused]] uint8_t __pad0710[0x8]; 	// 0x710
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnLightingOriginChanged"
	Vector m_vLightingOrigin; // 0x718	
	// MNetworkEnable
	// MNetworkChangeCallback "OnLightingOriginChanged"
	bool m_bFixupLightingOriginToPlayerSide; // 0x724	
private:
	[[maybe_unused]] uint8_t __pad0725[0x3]; 	// 0x725
public:
	uint32_t m_nNextModelConfigSerialNumber; // 0x728	
private:
	[[maybe_unused]] uint8_t __pad072c[0x4]; 	// 0x72c
public:
	// MNetworkEnable
	CUtlVectorEmbeddedNetworkVar< ActiveModelConfig_t > m_ActiveModelConfigs; // 0x730	
};

// Alignment: 0
// Size: 0x778
class CServerOnlyModelEntity : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x778
class CModelPointEntity : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 7
// Size: 0x548
class CLogicRelay : public CLogicalEntity
{
public:
	CEntityIOOutput m_OnTrigger; // 0x4f0	
	CEntityIOOutput m_OnSpawn; // 0x518	
	bool m_bDisabled; // 0x540	
	bool m_bWaitForRefire; // 0x541	
	bool m_bTriggerOnce; // 0x542	
	bool m_bFastRetrigger; // 0x543	
	bool m_bPassthoughCaller; // 0x544	
};

// Alignment: 15
// Size: 0xcd8
class CParticleSystem : public CBaseModelEntity
{
public:
	// MNetworkEnable
	char m_szSnapshotFileName[512]; // 0x778	
	// MNetworkEnable
	bool m_bActive; // 0x978	
	// MNetworkEnable
	bool m_bFrozen; // 0x979	
private:
	[[maybe_unused]] uint8_t __pad097a[0x2]; 	// 0x97a
public:
	// MNetworkEnable
	int32_t m_nStopType; // 0x97c	
	// MNetworkEnable
	bool m_bAnimateDuringGameplayPause; // 0x980	
private:
	[[maybe_unused]] uint8_t __pad0981[0x7]; 	// 0x981
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIParticleSystemDefinition > m_iEffectIndex; // 0x988	
	// MNetworkEnable
	float m_flStartTime; // 0x990	
	// MNetworkEnable
	float m_flPreSimTime; // 0x994	
	// MNetworkEnable
	Vector m_vServerControlPoints[4]; // 0x998	
	// MNetworkEnable
	uint8_t m_iServerControlPointAssignments[4]; // 0x9c8	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hControlPointEnts[64]; // 0x9cc	
	bool m_bNoSave; // 0xacc	
	bool m_bStartActive; // 0xacd	
private:
	[[maybe_unused]] uint8_t __pad0ace[0x2]; 	// 0xace
public:
	CUtlSymbolLarge m_iszEffectName; // 0xad0	
	CUtlSymbolLarge m_iszControlPointNames[64]; // 0xad8	
};

// Alignment: 16
// Size: 0x5d0
class CPathParticleRope : public CBaseEntity
{
public:
	bool m_bStartActive; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_flMaxSimulationTime; // 0x4f4	
	CUtlSymbolLarge m_iszEffectName; // 0x4f8	
	CUtlVector< CUtlSymbolLarge > m_PathNodes_Name; // 0x500	
	// MNetworkEnable
	float m_flParticleSpacing; // 0x518	
	// MNetworkEnable
	// MNetworkChangeCallback "parametersChanged"
	float m_flSlack; // 0x51c	
	// MNetworkEnable
	// MNetworkChangeCallback "parametersChanged"
	float m_flRadius; // 0x520	
	// MNetworkEnable
	// MNetworkChangeCallback "parametersChanged"
	Color m_ColorTint; // 0x524	
	// MNetworkEnable
	// MNetworkChangeCallback "effectStateChanged"
	int32_t m_nEffectState; // 0x528	
private:
	[[maybe_unused]] uint8_t __pad052c[0x4]; 	// 0x52c
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIParticleSystemDefinition > m_iEffectIndex; // 0x530	
	// MNetworkEnable
	CNetworkUtlVectorBase< Vector > m_PathNodes_Position; // 0x538	
	// MNetworkEnable
	CNetworkUtlVectorBase< Vector > m_PathNodes_TangentIn; // 0x550	
	// MNetworkEnable
	CNetworkUtlVectorBase< Vector > m_PathNodes_TangentOut; // 0x568	
	// MNetworkEnable
	CNetworkUtlVectorBase< Vector > m_PathNodes_Color; // 0x580	
	// MNetworkEnable
	// MNetworkChangeCallback "pinStateChanged"
	CNetworkUtlVectorBase< bool > m_PathNodes_PinEnabled; // 0x598	
	// MNetworkEnable
	CNetworkUtlVectorBase< float32 > m_PathNodes_RadiusScale; // 0x5b0	
};

// Alignment: 1
// Size: 0x780
class CFuncWall : public CBaseModelEntity
{
public:
	int32_t m_nState; // 0x778	
};

// Alignment: 0
// Size: 0x780
class CFuncWallToggle : public CFuncWall
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x778
class CFuncVehicleClip : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x778
class CFuncIllusionary : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x780
class CFuncVPhysicsClip : public CBaseModelEntity
{
public:
	bool m_bDisabled; // 0x778	
};

// Alignment: 3
// Size: 0x790
class CFuncInteractionLayerClip : public CBaseModelEntity
{
public:
	bool m_bDisabled; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0779[0x7]; 	// 0x779
public:
	CUtlSymbolLarge m_iszInteractsAs; // 0x780	
	CUtlSymbolLarge m_iszInteractsWith; // 0x788	
};

// Alignment: 0
// Size: 0x4f0
class CPointClientCommand : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CPointServerCommand : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CPointBroadcastClientCommand : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x568
class CCommentaryAuto : public CBaseEntity
{
public:
	CEntityIOOutput m_OnCommentaryNewGame; // 0x4f0	
	CEntityIOOutput m_OnCommentaryMidGame; // 0x518	
	CEntityIOOutput m_OnCommentaryMultiplayerSpawn; // 0x540	
};

// Alignment: 9
// Size: 0x790
class CDynamicLight : public CBaseModelEntity
{
public:
	uint8_t m_ActualFlags; // 0x778	
	// MNetworkEnable
	uint8_t m_Flags; // 0x779	
	// MNetworkEnable
	uint8_t m_LightStyle; // 0x77a	
	bool m_On; // 0x77b	
	// MNetworkEnable
	float m_Radius; // 0x77c	
	// MNetworkEnable
	int32_t m_Exponent; // 0x780	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "360"
	float m_InnerAngle; // 0x784	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "360"
	float m_OuterAngle; // 0x788	
	// MNetworkEnable
	float m_SpotRadius; // 0x78c	
};

// Alignment: 3
// Size: 0x788
class CBubbling : public CBaseModelEntity
{
public:
	int32_t m_density; // 0x778	
	int32_t m_frequency; // 0x77c	
	int32_t m_state; // 0x780	
};

// Alignment: 2
// Size: 0x500
class CEnvTracer : public CPointEntity
{
public:
	Vector m_vecEnd; // 0x4f0	
	float m_flDelay; // 0x4fc	
};

// Alignment: 5
// Size: 0x620
class CTestEffect : public CBaseEntity
{
public:
	int32_t m_iLoop; // 0x4f0	
	int32_t m_iBeam; // 0x4f4	
	CBeam* m_pBeam[24]; // 0x4f8	
	float m_flBeamTime[24]; // 0x5b8	
	float m_flStartTime; // 0x618	
};

// Alignment: 4
// Size: 0x510
class CBlood : public CPointEntity
{
public:
	QAngle m_vecSprayAngles; // 0x4f0	
	Vector m_vecSprayDir; // 0x4fc	
	float m_flAmount; // 0x508	
	int32_t m_Color; // 0x50c	
};

// Alignment: 0
// Size: 0x4f0
class CEnvFunnel : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x4f8
class CEnvBeverage : public CBaseEntity
{
public:
	bool m_CanInDispenser; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	int32_t m_nBeverageType; // 0x4f4	
};

// Alignment: 0
// Size: 0x778
class CPrecipitationBlocker : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x770
class CEnvWind : public CBaseEntity
{
public:
	// MNetworkEnable
	CEnvWindShared m_EnvWindShared; // 0x4f0	
};

// Alignment: 1
// Size: 0x4f8
class CPhysicsWire : public CBaseEntity
{
public:
	int32_t m_nDensity; // 0x4f0	
};

// Alignment: 2
// Size: 0x500
class CEnvMuzzleFlash : public CPointEntity
{
public:
	float m_flScale; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_iszParentAttachment; // 0x4f8	
};

// Alignment: 1
// Size: 0x4f8
class CEnvSplash : public CPointEntity
{
public:
	float m_flScale; // 0x4f0	
};

// Alignment: 16
// Size: 0x550
class CEnvGunfire : public CPointEntity
{
public:
	int32_t m_iMinBurstSize; // 0x4f0	
	int32_t m_iMaxBurstSize; // 0x4f4	
	float m_flMinBurstDelay; // 0x4f8	
	float m_flMaxBurstDelay; // 0x4fc	
	float m_flRateOfFire; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_iszShootSound; // 0x508	
	CUtlSymbolLarge m_iszTracerType; // 0x510	
	bool m_bDisabled; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad0519[0x3]; 	// 0x519
public:
	int32_t m_iShotsRemaining; // 0x51c	
	int32_t m_iSpread; // 0x520	
	Vector m_vecSpread; // 0x524	
	Vector m_vecTargetPosition; // 0x530	
	float m_flTargetDist; // 0x53c	
	float m_flBias; // 0x540	
	bool m_bCollide; // 0x544	
private:
	[[maybe_unused]] uint8_t __pad0545[0x3]; 	// 0x545
public:
	CHandle< CBaseEntity > m_hTarget; // 0x548	
};

// Alignment: 2
// Size: 0x500
class CEnvViewPunch : public CPointEntity
{
public:
	float m_flRadius; // 0x4f0	
	QAngle m_angViewPunch; // 0x4f4	
};

// Alignment: 1
// Size: 0x4f8
class CEnvEntityIgniter : public CBaseEntity
{
public:
	float m_flLifetime; // 0x4f0	
};

// Alignment: 1
// Size: 0x54d8
class CDebugHistory : public CBaseEntity
{
public:
	int32_t m_nNpcEvents; // 0x1f4530	
};

// Alignment: 12
// Size: 0x590
class CEnvEntityMaker : public CPointEntity
{
public:
	Vector m_vecEntityMins; // 0x4f0	
	Vector m_vecEntityMaxs; // 0x4fc	
	CHandle< CBaseEntity > m_hCurrentInstance; // 0x508	
	CHandle< CBaseEntity > m_hCurrentBlocker; // 0x50c	
	Vector m_vecBlockerOrigin; // 0x510	
	QAngle m_angPostSpawnDirection; // 0x51c	
	float m_flPostSpawnDirectionVariance; // 0x528	
	float m_flPostSpawnSpeed; // 0x52c	
	bool m_bPostSpawnUseAngles; // 0x530	
private:
	[[maybe_unused]] uint8_t __pad0531[0x7]; 	// 0x531
public:
	CUtlSymbolLarge m_iszTemplate; // 0x538	
	CEntityIOOutput m_pOutputOnSpawned; // 0x540	
	CEntityIOOutput m_pOutputOnFailedSpawn; // 0x568	
};

// Alignment: 0
// Size: 0x4f0
class CInfoInstructorHintTarget : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 24
// Size: 0x560
class CEnvInstructorHint : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszName; // 0x4f0	
	CUtlSymbolLarge m_iszReplace_Key; // 0x4f8	
	CUtlSymbolLarge m_iszHintTargetEntity; // 0x500	
	int32_t m_iTimeout; // 0x508	
	int32_t m_iDisplayLimit; // 0x50c	
	CUtlSymbolLarge m_iszIcon_Onscreen; // 0x510	
	CUtlSymbolLarge m_iszIcon_Offscreen; // 0x518	
	CUtlSymbolLarge m_iszCaption; // 0x520	
	CUtlSymbolLarge m_iszActivatorCaption; // 0x528	
	Color m_Color; // 0x530	
	float m_fIconOffset; // 0x534	
	float m_fRange; // 0x538	
	uint8_t m_iPulseOption; // 0x53c	
	uint8_t m_iAlphaOption; // 0x53d	
	uint8_t m_iShakeOption; // 0x53e	
	bool m_bStatic; // 0x53f	
	bool m_bNoOffscreen; // 0x540	
	bool m_bForceCaption; // 0x541	
private:
	[[maybe_unused]] uint8_t __pad0542[0x2]; 	// 0x542
public:
	int32_t m_iInstanceType; // 0x544	
	bool m_bSuppressRest; // 0x548	
private:
	[[maybe_unused]] uint8_t __pad0549[0x7]; 	// 0x549
public:
	CUtlSymbolLarge m_iszBinding; // 0x550	
	bool m_bAllowNoDrawTarget; // 0x558	
	bool m_bAutoStart; // 0x559	
	bool m_bLocalPlayerOnly; // 0x55a	
};

// Alignment: 9
// Size: 0x530
class CEnvInstructorVRHint : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszName; // 0x4f0	
	CUtlSymbolLarge m_iszHintTargetEntity; // 0x4f8	
	int32_t m_iTimeout; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_iszCaption; // 0x508	
	CUtlSymbolLarge m_iszStartSound; // 0x510	
	int32_t m_iLayoutFileType; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad051c[0x4]; 	// 0x51c
public:
	CUtlSymbolLarge m_iszCustomLayoutFile; // 0x520	
	int32_t m_iAttachType; // 0x528	
	float m_flHeightOffset; // 0x52c	
};

// Alignment: 3
// Size: 0x508
class CInstructorEventEntity : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszName; // 0x4f0	
	CUtlSymbolLarge m_iszHintTargetEntity; // 0x4f8	
	CHandle< CBasePlayer > m_hTargetPlayer; // 0x500	
};

// Alignment: 5
// Size: 0x578
class CEnvScreenOverlay : public CPointEntity
{
public:
	// MNetworkEnable
	CUtlSymbolLarge m_iszOverlayNames[10]; // 0x4f0	
	// MNetworkEnable
	// MNetworkBitCount "11"
	// MNetworkMinValue "-1"
	// MNetworkMaxValue "63"
	float m_flOverlayTimes[10]; // 0x540	
	// MNetworkEnable
	float m_flStartTime; // 0x568	
	// MNetworkEnable
	int32_t m_iDesiredOverlay; // 0x56c	
	// MNetworkEnable
	bool m_bIsActive; // 0x570	
};

// Alignment: 2
// Size: 0x4f8
class CEnvZoom : public CPointEntity
{
public:
	float m_flSpeed; // 0x4f0	
	int32_t m_nFOV; // 0x4f4	
};

// Alignment: 4
// Size: 0x528
class CEnvFade : public CLogicalEntity
{
public:
	// MNetworkEnable
	Color m_fadeColor; // 0x4f0	
	float m_Duration; // 0x4f4	
	float m_HoldDuration; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	CEntityIOOutput m_OnBeginFade; // 0x500	
};

// Alignment: 3
// Size: 0x520
class CCredits : public CPointEntity
{
public:
	CEntityIOOutput m_OnCreditsDone; // 0x4f0	
	bool m_bRolledOutroCredits; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad0519[0x3]; 	// 0x519
public:
	float m_flLogoLength; // 0x51c	
};

// Alignment: 10
// Size: 0x540
class CEnvShake : public CPointEntity
{
public:
	CUtlSymbolLarge m_limitToEntity; // 0x4f0	
	float m_Amplitude; // 0x4f8	
	float m_Frequency; // 0x4fc	
	float m_Duration; // 0x500	
	float m_Radius; // 0x504	
	float m_stopTime; // 0x508	
	float m_nextShake; // 0x50c	
	float m_currentAmp; // 0x510	
	Vector m_maxForce; // 0x514	
private:
	[[maybe_unused]] uint8_t __pad0520[0x8]; 	// 0x520
public:
	CPhysicsShake m_shakeCallback; // 0x528	
};

// Alignment: 4
// Size: 0x500
class CEnvTilt : public CPointEntity
{
public:
	float m_Duration; // 0x4f0	
	float m_Radius; // 0x4f4	
	float m_TiltTime; // 0x4f8	
	float m_stopTime; // 0x4fc	
};

// Alignment: 5
// Size: 0x528
class CEnvSpark : public CPointEntity
{
public:
	float m_flDelay; // 0x4f0	
	int32_t m_nMagnitude; // 0x4f4	
	int32_t m_nTrailLength; // 0x4f8	
	int32_t m_nType; // 0x4fc	
	CEntityIOOutput m_OnSpark; // 0x500	
};

// Alignment: 0
// Size: 0x778
class CShower : public CModelPointEntity
{
public:
	// @note: no members available
};

// Alignment: 15
// Size: 0x7d0
class CEnvExplosion : public CModelPointEntity
{
public:
	int32_t m_iMagnitude; // 0x778	
	float m_flPlayerDamage; // 0x77c	
	int32_t m_iRadiusOverride; // 0x780	
	float m_flInnerRadius; // 0x784	
	int32_t m_spriteScale; // 0x788	
	float m_flDamageForce; // 0x78c	
	CHandle< CBaseEntity > m_hInflictor; // 0x790	
	int32_t m_iCustomDamageType; // 0x794	
private:
	[[maybe_unused]] uint8_t __pad0798[0x8]; 	// 0x798
public:
	CUtlSymbolLarge m_iszExplosionType; // 0x7a0	
	CUtlSymbolLarge m_iszCustomEffectName; // 0x7a8	
	CUtlSymbolLarge m_iszCustomSoundName; // 0x7b0	
	Class_T m_iClassIgnore; // 0x7b8	
	Class_T m_iClassIgnore2; // 0x7bc	
	CUtlSymbolLarge m_iszEntityIgnoreName; // 0x7c0	
	CHandle< CBaseEntity > m_hEntityIgnore; // 0x7c8	
};

// Alignment: 1
// Size: 0x550
class CFilterName : public CBaseFilter
{
public:
	CUtlSymbolLarge m_iFilterName; // 0x548	
};

// Alignment: 1
// Size: 0x550
class CFilterModel : public CBaseFilter
{
public:
	CUtlSymbolLarge m_iFilterModel; // 0x548	
};

// Alignment: 1
// Size: 0x550
class CFilterContext : public CBaseFilter
{
public:
	CUtlSymbolLarge m_iFilterContext; // 0x548	
};

// Alignment: 1
// Size: 0x550
class FilterTeam : public CBaseFilter
{
public:
	int32_t m_iFilterTeam; // 0x548	
};

// Alignment: 1
// Size: 0x550
class CFilterMassGreater : public CBaseFilter
{
public:
	float m_fFilterMass; // 0x548	
};

// Alignment: 1
// Size: 0x550
class FilterDamageType : public CBaseFilter
{
public:
	int32_t m_iDamageType; // 0x548	
};

// Alignment: 3
// Size: 0x558
class FilterHealth : public CBaseFilter
{
public:
	bool m_bAdrenalineActive; // 0x548	
private:
	[[maybe_unused]] uint8_t __pad0549[0x3]; 	// 0x549
public:
	int32_t m_iHealthMin; // 0x54c	
	int32_t m_iHealthMax; // 0x550	
};

// Alignment: 5
// Size: 0x568
class CFilterEnemy : public CBaseFilter
{
public:
	CUtlSymbolLarge m_iszEnemyName; // 0x548	
	float m_flRadius; // 0x550	
	float m_flOuterRadius; // 0x554	
	int32_t m_nMaxSquadmatesPerEnemy; // 0x558	
private:
	[[maybe_unused]] uint8_t __pad055c[0x4]; 	// 0x55c
public:
	CUtlSymbolLarge m_iszPlayerName; // 0x560	
};

// Alignment: 19
// Size: 0x808
class CFire : public CBaseModelEntity
{
public:
	CHandle< CBaseFire > m_hEffect; // 0x778	
	CHandle< CBaseEntity > m_hOwner; // 0x77c	
	int32_t m_nFireType; // 0x780	
	float m_flFuel; // 0x784	
	float m_flDamageTime; // 0x788	
	float m_lastDamage; // 0x78c	
	float m_flFireSize; // 0x790	
	float m_flLastNavUpdateTime; // 0x794	
	float m_flHeatLevel; // 0x798	
	float m_flHeatAbsorb; // 0x79c	
	float m_flDamageScale; // 0x7a0	
	float m_flMaxHeat; // 0x7a4	
	float m_flLastHeatLevel; // 0x7a8	
	float m_flAttackTime; // 0x7ac	
	bool m_bEnabled; // 0x7b0	
	bool m_bStartDisabled; // 0x7b1	
	bool m_bDidActivate; // 0x7b2	
private:
	[[maybe_unused]] uint8_t __pad07b3[0x5]; 	// 0x7b3
public:
	CEntityIOOutput m_OnIgnited; // 0x7b8	
	CEntityIOOutput m_OnExtinguished; // 0x7e0	
};

// Alignment: 3
// Size: 0x500
class CEnvFireSource : public CBaseEntity
{
public:
	bool m_bEnabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_radius; // 0x4f4	
	float m_damage; // 0x4f8	
};

// Alignment: 8
// Size: 0x558
class CEnvFireSensor : public CBaseEntity
{
public:
	bool m_bEnabled; // 0x4f0	
	bool m_bHeatAtLevel; // 0x4f1	
private:
	[[maybe_unused]] uint8_t __pad04f2[0x2]; 	// 0x4f2
public:
	float m_radius; // 0x4f4	
	float m_targetLevel; // 0x4f8	
	float m_targetTime; // 0x4fc	
	float m_levelTime; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CEntityIOOutput m_OnHeatLevelStart; // 0x508	
	CEntityIOOutput m_OnHeatLevelEnd; // 0x530	
};

// Alignment: 5
// Size: 0x508
class CFuncTimescale : public CBaseEntity
{
public:
	float m_flDesiredTimescale; // 0x4f0	
	float m_flAcceleration; // 0x4f4	
	float m_flMinBlendRate; // 0x4f8	
	float m_flBlendDeltaMultiplier; // 0x4fc	
	bool m_isStarted; // 0x500	
};

// Alignment: 23
// Size: 0x7e0
class CGameUI : public CBaseEntity
{
public:
	float m_flFieldOfView; // 0x4f0	
	CHandle< CBasePlayerWeapon > m_hSaveWeapon; // 0x4f4	
	CEntityIOOutput m_playerOn; // 0x4f8	
	CEntityIOOutput m_playerOff; // 0x520	
	CEntityIOOutput m_pressedMoveLeft; // 0x548	
	CEntityIOOutput m_pressedMoveRight; // 0x570	
	CEntityIOOutput m_pressedForward; // 0x598	
	CEntityIOOutput m_pressedBack; // 0x5c0	
	CEntityIOOutput m_pressedAttack; // 0x5e8	
	CEntityIOOutput m_pressedAttack2; // 0x610	
	CEntityIOOutput m_unpressedMoveLeft; // 0x638	
	CEntityIOOutput m_unpressedMoveRight; // 0x660	
	CEntityIOOutput m_unpressedForward; // 0x688	
	CEntityIOOutput m_unpressedBack; // 0x6b0	
	CEntityIOOutput m_unpressedAttack; // 0x6d8	
	CEntityIOOutput m_unpressedAttack2; // 0x700	
	CEntityOutputTemplate< float32 > m_xaxis; // 0x728	
	CEntityOutputTemplate< float32 > m_yaxis; // 0x750	
	CEntityOutputTemplate< float32 > m_attackaxis; // 0x778	
	CEntityOutputTemplate< float32 > m_attack2axis; // 0x7a0	
	bool m_bForceUpdate; // 0x7c8	
private:
	[[maybe_unused]] uint8_t __pad07c9[0x7]; 	// 0x7c9
public:
	uint64_t m_nLastButtonState; // 0x7d0	
	CHandle< CBasePlayer > m_player; // 0x7d8	
};

// Alignment: 5
// Size: 0x528
class CGameWeaponManager : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszWeaponName; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f8[0x8]; 	// 0x4f8
public:
	int32_t m_iMaxPieces; // 0x500	
	float m_flAmmoMod; // 0x504	
	bool m_bExpectingWeapon; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad0509[0x7]; 	// 0x509
public:
	CUtlVector< CHandle< CBaseEntity > > m_ManagedNonWeapons; // 0x510	
};

// Alignment: 7
// Size: 0x798
class CLightGlow : public CBaseModelEntity
{
public:
	// MNetworkEnable
	uint32_t m_nHorizontalSize; // 0x778	
	// MNetworkEnable
	uint32_t m_nVerticalSize; // 0x77c	
	// MNetworkEnable
	uint32_t m_nMinDist; // 0x780	
	// MNetworkEnable
	uint32_t m_nMaxDist; // 0x784	
	// MNetworkEnable
	uint32_t m_nOuterMaxDist; // 0x788	
	// MNetworkEnable
	// MNetworkBitCount "6"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "64"
	// MNetworkEncodeFlags
	float m_flGlowProxySize; // 0x78c	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "100"
	float m_flHDRColorScale; // 0x790	
};

// Alignment: 3
// Size: 0x528
class CLogicAchievement : public CLogicalEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	CUtlSymbolLarge m_iszAchievementEventID; // 0x4f8	
	CEntityIOOutput m_OnFired; // 0x500	
};

// Alignment: 5
// Size: 0x540
class CLogicGameEventListener : public CLogicalEntity
{
public:
	CEntityIOOutput m_OnEventFired; // 0x500	
	CUtlSymbolLarge m_iszGameEventName; // 0x528	
	CUtlSymbolLarge m_iszGameEventItem; // 0x530	
	// MNetworkEnable
	bool m_bEnabled; // 0x538	
	bool m_bStartDisabled; // 0x539	
};

// Alignment: 9
// Size: 0x520
class CLogicMeasureMovement : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_strMeasureTarget; // 0x4f0	
	CUtlSymbolLarge m_strMeasureReference; // 0x4f8	
	CUtlSymbolLarge m_strTargetReference; // 0x500	
	CHandle< CBaseEntity > m_hMeasureTarget; // 0x508	
	CHandle< CBaseEntity > m_hMeasureReference; // 0x50c	
	CHandle< CBaseEntity > m_hTarget; // 0x510	
	CHandle< CBaseEntity > m_hTargetReference; // 0x514	
	float m_flScale; // 0x518	
	int32_t m_nMeasureType; // 0x51c	
};

// Alignment: 2
// Size: 0x500
class CLogicNavigation : public CLogicalEntity
{
public:
	bool m_isOn; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04f9[0x3]; 	// 0x4f9
public:
	navproperties_t m_navProperty; // 0x4fc	
};

// Alignment: 48
// Size: 0x830
class CLogicNPCCounter : public CBaseEntity
{
public:
	CEntityIOOutput m_OnMinCountAll; // 0x4f0	
	CEntityIOOutput m_OnMaxCountAll; // 0x518	
	CEntityOutputTemplate< float32 > m_OnFactorAll; // 0x540	
	CEntityOutputTemplate< float32 > m_OnMinPlayerDistAll; // 0x568	
	CEntityIOOutput m_OnMinCount_1; // 0x590	
	CEntityIOOutput m_OnMaxCount_1; // 0x5b8	
	CEntityOutputTemplate< float32 > m_OnFactor_1; // 0x5e0	
	CEntityOutputTemplate< float32 > m_OnMinPlayerDist_1; // 0x608	
	CEntityIOOutput m_OnMinCount_2; // 0x630	
	CEntityIOOutput m_OnMaxCount_2; // 0x658	
	CEntityOutputTemplate< float32 > m_OnFactor_2; // 0x680	
	CEntityOutputTemplate< float32 > m_OnMinPlayerDist_2; // 0x6a8	
	CEntityIOOutput m_OnMinCount_3; // 0x6d0	
	CEntityIOOutput m_OnMaxCount_3; // 0x6f8	
	CEntityOutputTemplate< float32 > m_OnFactor_3; // 0x720	
	CEntityOutputTemplate< float32 > m_OnMinPlayerDist_3; // 0x748	
	CEntityHandle m_hSource; // 0x770	
private:
	[[maybe_unused]] uint8_t __pad0774[0x4]; 	// 0x774
public:
	CUtlSymbolLarge m_iszSourceEntityName; // 0x778	
	float m_flDistanceMax; // 0x780	
	bool m_bDisabled; // 0x784	
private:
	[[maybe_unused]] uint8_t __pad0785[0x3]; 	// 0x785
public:
	int32_t m_nMinCountAll; // 0x788	
	int32_t m_nMaxCountAll; // 0x78c	
	int32_t m_nMinFactorAll; // 0x790	
	int32_t m_nMaxFactorAll; // 0x794	
private:
	[[maybe_unused]] uint8_t __pad0798[0x8]; 	// 0x798
public:
	CUtlSymbolLarge m_iszNPCClassname_1; // 0x7a0	
	int32_t m_nNPCState_1; // 0x7a8	
	bool m_bInvertState_1; // 0x7ac	
private:
	[[maybe_unused]] uint8_t __pad07ad[0x3]; 	// 0x7ad
public:
	int32_t m_nMinCount_1; // 0x7b0	
	int32_t m_nMaxCount_1; // 0x7b4	
	int32_t m_nMinFactor_1; // 0x7b8	
	int32_t m_nMaxFactor_1; // 0x7bc	
private:
	[[maybe_unused]] uint8_t __pad07c0[0x4]; 	// 0x7c0
public:
	float m_flDefaultDist_1; // 0x7c4	
	CUtlSymbolLarge m_iszNPCClassname_2; // 0x7c8	
	int32_t m_nNPCState_2; // 0x7d0	
	bool m_bInvertState_2; // 0x7d4	
private:
	[[maybe_unused]] uint8_t __pad07d5[0x3]; 	// 0x7d5
public:
	int32_t m_nMinCount_2; // 0x7d8	
	int32_t m_nMaxCount_2; // 0x7dc	
	int32_t m_nMinFactor_2; // 0x7e0	
	int32_t m_nMaxFactor_2; // 0x7e4	
private:
	[[maybe_unused]] uint8_t __pad07e8[0x4]; 	// 0x7e8
public:
	float m_flDefaultDist_2; // 0x7ec	
	CUtlSymbolLarge m_iszNPCClassname_3; // 0x7f0	
	int32_t m_nNPCState_3; // 0x7f8	
	bool m_bInvertState_3; // 0x7fc	
private:
	[[maybe_unused]] uint8_t __pad07fd[0x3]; 	// 0x7fd
public:
	int32_t m_nMinCount_3; // 0x800	
	int32_t m_nMaxCount_3; // 0x804	
	int32_t m_nMinFactor_3; // 0x808	
	int32_t m_nMaxFactor_3; // 0x80c	
private:
	[[maybe_unused]] uint8_t __pad0810[0x4]; 	// 0x810
public:
	float m_flDefaultDist_3; // 0x814	
};

// Alignment: 4
// Size: 0x860
class CLogicNPCCounterAABB : public CLogicNPCCounter
{
public:
	Vector m_vDistanceOuterMins; // 0x830	
	Vector m_vDistanceOuterMaxs; // 0x83c	
	Vector m_vOuterMins; // 0x848	
	Vector m_vOuterMaxs; // 0x854	
};

// Alignment: 0
// Size: 0x860
class CLogicNPCCounterOBB : public CLogicNPCCounterAABB
{
public:
	// @note: no members available
};

// Alignment: 5
// Size: 0x598
class CLogicPlayerProxy : public CLogicalEntity
{
public:
	CHandle< CBaseEntity > m_hPlayer; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CEntityIOOutput m_PlayerHasAmmo; // 0x4f8	
	CEntityIOOutput m_PlayerHasNoAmmo; // 0x520	
	CEntityIOOutput m_PlayerDied; // 0x548	
	CEntityOutputTemplate< int32 > m_RequestedPlayerHealth; // 0x570	
};

// Alignment: 11
// Size: 0x688
class CLogicAuto : public CBaseEntity
{
public:
	CEntityIOOutput m_OnMapSpawn; // 0x4f0	
	CEntityIOOutput m_OnDemoMapSpawn; // 0x518	
	CEntityIOOutput m_OnNewGame; // 0x540	
	CEntityIOOutput m_OnLoadGame; // 0x568	
	CEntityIOOutput m_OnMapTransition; // 0x590	
	CEntityIOOutput m_OnBackgroundMap; // 0x5b8	
	CEntityIOOutput m_OnMultiNewMap; // 0x5e0	
	CEntityIOOutput m_OnMultiNewRound; // 0x608	
	CEntityIOOutput m_OnVREnabled; // 0x630	
	CEntityIOOutput m_OnVRNotEnabled; // 0x658	
	CUtlSymbolLarge m_globalstate; // 0x680	
};

// Alignment: 0
// Size: 0x4f0
class CLogicScript : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 12
// Size: 0x590
class CTimerEntity : public CLogicalEntity
{
public:
	CEntityIOOutput m_OnTimer; // 0x4f0	
	CEntityIOOutput m_OnTimerHigh; // 0x518	
	CEntityIOOutput m_OnTimerLow; // 0x540	
	int32_t m_iDisabled; // 0x568	
	float m_flInitialDelay; // 0x56c	
	float m_flRefireTime; // 0x570	
	bool m_bUpDownState; // 0x574	
private:
	[[maybe_unused]] uint8_t __pad0575[0x3]; 	// 0x575
public:
	int32_t m_iUseRandomTime; // 0x578	
	float m_flLowerRandomBound; // 0x57c	
	float m_flUpperRandomBound; // 0x580	
	float m_flRemainingTime; // 0x584	
	bool m_bPaused; // 0x588	
};

// Alignment: 4
// Size: 0x528
class CLogicLineToEntity : public CLogicalEntity
{
public:
	CEntityOutputTemplate< Vector > m_Line; // 0x4f0	
	CUtlSymbolLarge m_SourceName; // 0x518	
	CHandle< CBaseEntity > m_StartEntity; // 0x520	
	CHandle< CBaseEntity > m_EndEntity; // 0x524	
};

// Alignment: 11
// Size: 0x5d0
class CMathRemap : public CLogicalEntity
{
public:
	float m_flInMin; // 0x4f0	
	float m_flInMax; // 0x4f4	
	float m_flOut1; // 0x4f8	
	float m_flOut2; // 0x4fc	
	float m_flOldInValue; // 0x500	
	bool m_bEnabled; // 0x504	
private:
	[[maybe_unused]] uint8_t __pad0505[0x3]; 	// 0x505
public:
	CEntityOutputTemplate< float32 > m_OutValue; // 0x508	
	CEntityIOOutput m_OnRoseAboveMin; // 0x530	
	CEntityIOOutput m_OnRoseAboveMax; // 0x558	
	CEntityIOOutput m_OnFellBelowMin; // 0x580	
	CEntityIOOutput m_OnFellBelowMax; // 0x5a8	
};

// Alignment: 5
// Size: 0x528
class CMathColorBlend : public CLogicalEntity
{
public:
	float m_flInMin; // 0x4f0	
	float m_flInMax; // 0x4f4	
	Color m_OutColor1; // 0x4f8	
	Color m_OutColor2; // 0x4fc	
	CEntityOutputTemplate< Color > m_OutValue; // 0x500	
};

// Alignment: 5
// Size: 0x530
class CEnvGlobal : public CLogicalEntity
{
public:
	CEntityOutputTemplate< int32 > m_outCounter; // 0x4f0	
	CUtlSymbolLarge m_globalstate; // 0x518	
	int32_t m_triggermode; // 0x520	
	int32_t m_initialstate; // 0x524	
	int32_t m_counter; // 0x528	
};

// Alignment: 5
// Size: 0x628
class CMultiSource : public CLogicalEntity
{
public:
	CHandle< CBaseEntity > m_rgEntities[32]; // 0x4f0	
	int32_t m_rgTriggered[32]; // 0x570	
	CEntityIOOutput m_OnTrigger; // 0x5f0	
	int32_t m_iTotal; // 0x618	
private:
	[[maybe_unused]] uint8_t __pad061c[0x4]; 	// 0x61c
public:
	CUtlSymbolLarge m_globalstate; // 0x620	
};

// Alignment: 11
// Size: 0x5f0
class CMathCounter : public CLogicalEntity
{
public:
	float m_flMin; // 0x4f0	
	float m_flMax; // 0x4f4	
	bool m_bHitMin; // 0x4f8	
	bool m_bHitMax; // 0x4f9	
	bool m_bDisabled; // 0x4fa	
private:
	[[maybe_unused]] uint8_t __pad04fb[0x5]; 	// 0x4fb
public:
	CEntityOutputTemplate< float32 > m_OutValue; // 0x500	
	CEntityOutputTemplate< float32 > m_OnGetValue; // 0x528	
	CEntityIOOutput m_OnHitMin; // 0x550	
	CEntityIOOutput m_OnHitMax; // 0x578	
	CEntityIOOutput m_OnChangedFromMin; // 0x5a0	
	CEntityIOOutput m_OnChangedFromMax; // 0x5c8	
};

// Alignment: 6
// Size: 0xb40
class CLogicCase : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_nCase[32]; // 0x4f0	
	int32_t m_nShuffleCases; // 0x5f0	
	int32_t m_nLastShuffleCase; // 0x5f4	
	uint8_t m_uchShuffleCaseMap[32]; // 0x5f8	
	CEntityIOOutput m_OnCase[32]; // 0x618	
	CEntityOutputTemplate< CVariantBase< CVariantDefaultAllocator > > m_OnDefault; // 0xb18	
};

// Alignment: 6
// Size: 0x598
class CLogicCompare : public CLogicalEntity
{
public:
	float m_flInValue; // 0x4f0	
	float m_flCompareValue; // 0x4f4	
	CEntityOutputTemplate< float32 > m_OnLessThan; // 0x4f8	
	CEntityOutputTemplate< float32 > m_OnEqualTo; // 0x520	
	CEntityOutputTemplate< float32 > m_OnNotEqualTo; // 0x548	
	CEntityOutputTemplate< float32 > m_OnGreaterThan; // 0x570	
};

// Alignment: 3
// Size: 0x500
class CLogicAutosave : public CLogicalEntity
{
public:
	bool m_bForceNewLevelUnit; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	int32_t m_minHitPoints; // 0x4f4	
	int32_t m_minHitPointsToCommit; // 0x4f8	
};

// Alignment: 4
// Size: 0x510
class CLogicActiveAutosave : public CLogicAutosave
{
public:
	int32_t m_TriggerHitPoints; // 0x500	
	float m_flTimeToTrigger; // 0x504	
	float m_flStartTime; // 0x508	
	float m_flDangerousTime; // 0x50c	
};

// Alignment: 6
// Size: 0x508
class CLogicDistanceAutosave : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszTargetEntity; // 0x4f0	
	float m_flDistanceToPlayer; // 0x4f8	
	bool m_bForceNewLevelUnit; // 0x4fc	
	bool m_bCheckCough; // 0x4fd	
	bool m_bThinkDangerous; // 0x4fe	
private:
	[[maybe_unused]] uint8_t __pad04ff[0x1]; 	// 0x4ff
public:
	float m_flDangerousTime; // 0x500	
};

// Alignment: 4
// Size: 0x508
class CLogicCollisionPair : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_nameAttach1; // 0x4f0	
	CUtlSymbolLarge m_nameAttach2; // 0x4f8	
	bool m_disabled; // 0x500	
	bool m_succeeded; // 0x501	
};

// Alignment: 6
// Size: 0x608
class CLogicBranchList : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_nLogicBranchNames[16]; // 0x4f0	
	CUtlVector< CHandle< CBaseEntity > > m_LogicBranchList; // 0x570	
	CLogicBranchList::LogicBranchListenerLastState_t m_eLastState; // 0x588	
private:
	[[maybe_unused]] uint8_t __pad058c[0x4]; 	// 0x58c
public:
	CEntityIOOutput m_OnAllTrue; // 0x590	
	CEntityIOOutput m_OnAllFalse; // 0x5b8	
	CEntityIOOutput m_OnMixed; // 0x5e0	
};

// Alignment: 1
// Size: 0x4f8
class CLogicGameEvent : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszEventName; // 0x4f0	
};

// Alignment: 1
// Size: 0x780
class CRuleEntity : public CBaseModelEntity
{
public:
	CUtlSymbolLarge m_iszMaster; // 0x778	
};

// Alignment: 1
// Size: 0x788
class CRulePointEntity : public CRuleEntity
{
public:
	int32_t m_Score; // 0x780	
};

// Alignment: 0
// Size: 0x780
class CRuleBrushEntity : public CRuleEntity
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x7b8
class CGameText : public CRulePointEntity
{
public:
	CUtlSymbolLarge m_iszMessage; // 0x788	
	hudtextparms_t m_textParms; // 0x790	
};

// Alignment: 4
// Size: 0x820
class CGamePlayerZone : public CRuleBrushEntity
{
public:
	CEntityIOOutput m_OnPlayerInZone; // 0x780	
	CEntityIOOutput m_OnPlayerOutZone; // 0x7a8	
	CEntityOutputTemplate< int32 > m_PlayersInCount; // 0x7d0	
	CEntityOutputTemplate< int32 > m_PlayersOutCount; // 0x7f8	
};

// Alignment: 2
// Size: 0x908
class CGamePlayerEquip : public CRulePointEntity
{
public:
	CUtlSymbolLarge m_weaponNames[32]; // 0x788	
	int32_t m_weaponCount[32]; // 0x888	
};

// Alignment: 5
// Size: 0x508
class CMessageEntity : public CPointEntity
{
public:
	int32_t m_radius; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_messageText; // 0x4f8	
	bool m_drawText; // 0x500	
	bool m_bDeveloperOnly; // 0x501	
	bool m_bEnabled; // 0x502	
};

// Alignment: 5
// Size: 0x7f8
class CTriggerBrush : public CBaseModelEntity
{
public:
	CEntityIOOutput m_OnStartTouch; // 0x778	
	CEntityIOOutput m_OnEndTouch; // 0x7a0	
	CEntityIOOutput m_OnUse; // 0x7c8	
	int32_t m_iInputFilter; // 0x7f0	
	int32_t m_iDontMessageParent; // 0x7f4	
};

// Alignment: 8
// Size: 0x540
class CPathKeyFrame : public CLogicalEntity
{
public:
	Vector m_Origin; // 0x4f0	
	QAngle m_Angles; // 0x4fc	
	Quaternion m_qAngle; // 0x508	
	CUtlSymbolLarge m_iNextKey; // 0x518	
	float m_flNextTime; // 0x520	
private:
	[[maybe_unused]] uint8_t __pad0524[0x4]; 	// 0x524
public:
	CPathKeyFrame* m_pNextKey; // 0x528	
	CPathKeyFrame* m_pPrevKey; // 0x530	
	float m_flSpeed; // 0x538	
};

// Alignment: 11
// Size: 0x580
class CBaseMoveBehavior : public CPathKeyFrame
{
public:
	int32_t m_iPositionInterpolator; // 0x540	
	int32_t m_iRotationInterpolator; // 0x544	
	float m_flAnimStartTime; // 0x548	
	float m_flAnimEndTime; // 0x54c	
	float m_flAverageSpeedAcrossFrame; // 0x550	
private:
	[[maybe_unused]] uint8_t __pad0554[0x4]; 	// 0x554
public:
	CPathKeyFrame* m_pCurrentKeyFrame; // 0x558	
	CPathKeyFrame* m_pTargetKeyFrame; // 0x560	
	CPathKeyFrame* m_pPreKeyFrame; // 0x568	
	CPathKeyFrame* m_pPostKeyFrame; // 0x570	
	float m_flTimeIntoFrame; // 0x578	
	int32_t m_iDirection; // 0x57c	
};

// Alignment: 4
// Size: 0x528
class CPathCorner : public CPointEntity
{
public:
	float m_flWait; // 0x4f0	
	float m_flRadius; // 0x4f4	
	CEntityIOOutput m_OnPass; // 0x4f8	
	CUtlSymbolLarge m_MoveActivityName; // 0x520	
};

// Alignment: 6
// Size: 0x550
class CPhysForce : public CPointEntity
{
public:
	CUtlSymbolLarge m_nameAttach; // 0x4f8	
	float m_force; // 0x500	
	float m_forceTime; // 0x504	
	CHandle< CBaseEntity > m_attachedObject; // 0x508	
	bool m_wasRestored; // 0x50c	
private:
	[[maybe_unused]] uint8_t __pad050d[0x3]; 	// 0x50d
public:
	CConstantForceController m_integrator; // 0x510	
};

// Alignment: 1
// Size: 0x560
class CPhysThruster : public CPhysForce
{
public:
	Vector m_localOrigin; // 0x550	
};

// Alignment: 1
// Size: 0x560
class CPhysTorque : public CPhysForce
{
public:
	Vector m_axis; // 0x550	
};

// Alignment: 7
// Size: 0x540
class CPhysMotor : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_nameAttach; // 0x4f0	
	CHandle< CBaseEntity > m_hAttachedObject; // 0x4f8	
	float m_spinUp; // 0x4fc	
	float m_additionalAcceleration; // 0x500	
	float m_angularAcceleration; // 0x504	
	float m_lastTime; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad050c[0x14]; 	// 0x50c
public:
	CMotorController m_motor; // 0x520	
};

// Alignment: 7
// Size: 0x530
class CKeepUpright : public CPointEntity
{
public:
	Vector m_worldGoalAxis; // 0x4f8	
	Vector m_localTestAxis; // 0x504	
private:
	[[maybe_unused]] uint8_t __pad0510[0x8]; 	// 0x510
public:
	CUtlSymbolLarge m_nameAttach; // 0x518	
	CHandle< CBaseEntity > m_attachedObject; // 0x520	
	float m_angularLimit; // 0x524	
	bool m_bActive; // 0x528	
	bool m_bDampAllRotation; // 0x529	
};

// Alignment: 8
// Size: 0x548
class CPhysConstraint : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_nameAttach1; // 0x4f8	
	CUtlSymbolLarge m_nameAttach2; // 0x500	
	CUtlSymbolLarge m_breakSound; // 0x508	
	float m_forceLimit; // 0x510	
	float m_torqueLimit; // 0x514	
	uint32_t m_teleportTick; // 0x518	
	float m_minTeleportDistance; // 0x51c	
	CEntityIOOutput m_OnBreak; // 0x520	
};

// Alignment: 18
// Size: 0x6e8
class CPhysHinge : public CPhysConstraint
{
public:
	ConstraintSoundInfo m_soundInfo; // 0x550	
	CEntityIOOutput m_NotifyMinLimitReached; // 0x5d8	
	CEntityIOOutput m_NotifyMaxLimitReached; // 0x600	
	bool m_bAtMinLimit; // 0x628	
	bool m_bAtMaxLimit; // 0x629	
private:
	[[maybe_unused]] uint8_t __pad062a[0x2]; 	// 0x62a
public:
	constraint_hingeparams_t m_hinge; // 0x62c	
	float m_hingeFriction; // 0x66c	
	float m_systemLoadScale; // 0x670	
	bool m_bIsAxisLocal; // 0x674	
private:
	[[maybe_unused]] uint8_t __pad0675[0x3]; 	// 0x675
public:
	float m_flMinRotation; // 0x678	
	float m_flMaxRotation; // 0x67c	
	float m_flInitialRotation; // 0x680	
	float m_flMotorFrequency; // 0x684	
	float m_flMotorDampingRatio; // 0x688	
	float m_flAngleSpeed; // 0x68c	
	float m_flAngleSpeedThreshold; // 0x690	
private:
	[[maybe_unused]] uint8_t __pad0694[0x4]; 	// 0x694
public:
	CEntityIOOutput m_OnStartMoving; // 0x698	
	CEntityIOOutput m_OnStopMoving; // 0x6c0	
};

// Alignment: 0
// Size: 0x6e8
class CPhysHingeAlias_phys_hinge_local : public CPhysHinge
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x550
class CPhysBallSocket : public CPhysConstraint
{
public:
	float m_flFriction; // 0x548	
};

// Alignment: 10
// Size: 0x600
class CPhysSlideConstraint : public CPhysConstraint
{
public:
	Vector m_axisEnd; // 0x550	
	float m_slideFriction; // 0x55c	
	float m_systemLoadScale; // 0x560	
	float m_initialOffset; // 0x564	
	bool m_bEnableLinearConstraint; // 0x568	
	bool m_bEnableAngularConstraint; // 0x569	
private:
	[[maybe_unused]] uint8_t __pad056a[0x2]; 	// 0x56a
public:
	float m_flMotorFrequency; // 0x56c	
	float m_flMotorDampingRatio; // 0x570	
	bool m_bUseEntityPivot; // 0x574	
private:
	[[maybe_unused]] uint8_t __pad0575[0x3]; 	// 0x575
public:
	ConstraintSoundInfo m_soundInfo; // 0x578	
};

// Alignment: 6
// Size: 0x560
class CPhysFixed : public CPhysConstraint
{
public:
	float m_flLinearFrequency; // 0x548	
	float m_flLinearDampingRatio; // 0x54c	
	float m_flAngularFrequency; // 0x550	
	float m_flAngularDampingRatio; // 0x554	
	bool m_bEnableLinearConstraint; // 0x558	
	bool m_bEnableAngularConstraint; // 0x559	
};

// Alignment: 4
// Size: 0x578
class CPhysPulley : public CPhysConstraint
{
public:
	Vector m_position2; // 0x548	
	Vector m_offset[2]; // 0x554	
	float m_addLength; // 0x56c	
	float m_gearRatio; // 0x570	
};

// Alignment: 6
// Size: 0x580
class CPhysLength : public CPhysConstraint
{
public:
	Vector m_offset[2]; // 0x548	
	Vector m_vecAttach; // 0x560	
	float m_addLength; // 0x56c	
	float m_minLength; // 0x570	
	float m_totalLength; // 0x574	
	bool m_bEnableCollision; // 0x578	
};

// Alignment: 9
// Size: 0x570
class CRagdollConstraint : public CPhysConstraint
{
public:
	float m_xmin; // 0x548	
	float m_xmax; // 0x54c	
	float m_ymin; // 0x550	
	float m_ymax; // 0x554	
	float m_zmin; // 0x558	
	float m_zmax; // 0x55c	
	float m_xfriction; // 0x560	
	float m_yfriction; // 0x564	
	float m_zfriction; // 0x568	
};

// Alignment: 48
// Size: 0x678
class CGenericConstraint : public CPhysConstraint
{
public:
	JointMotion_t m_nLinearMotionX; // 0x550	
	JointMotion_t m_nLinearMotionY; // 0x554	
	JointMotion_t m_nLinearMotionZ; // 0x558	
	float m_flLinearFrequencyX; // 0x55c	
	float m_flLinearFrequencyY; // 0x560	
	float m_flLinearFrequencyZ; // 0x564	
	float m_flLinearDampingRatioX; // 0x568	
	float m_flLinearDampingRatioY; // 0x56c	
	float m_flLinearDampingRatioZ; // 0x570	
	float m_flMaxLinearImpulseX; // 0x574	
	float m_flMaxLinearImpulseY; // 0x578	
	float m_flMaxLinearImpulseZ; // 0x57c	
	float m_flBreakAfterTimeX; // 0x580	
	float m_flBreakAfterTimeY; // 0x584	
	float m_flBreakAfterTimeZ; // 0x588	
	float m_flBreakAfterTimeStartTimeX; // 0x58c	
	float m_flBreakAfterTimeStartTimeY; // 0x590	
	float m_flBreakAfterTimeStartTimeZ; // 0x594	
	float m_flBreakAfterTimeThresholdX; // 0x598	
	float m_flBreakAfterTimeThresholdY; // 0x59c	
	float m_flBreakAfterTimeThresholdZ; // 0x5a0	
	float m_flNotifyForceX; // 0x5a4	
	float m_flNotifyForceY; // 0x5a8	
	float m_flNotifyForceZ; // 0x5ac	
	float m_flNotifyForceMinTimeX; // 0x5b0	
	float m_flNotifyForceMinTimeY; // 0x5b4	
	float m_flNotifyForceMinTimeZ; // 0x5b8	
	float m_flNotifyForceLastTimeX; // 0x5bc	
	float m_flNotifyForceLastTimeY; // 0x5c0	
	float m_flNotifyForceLastTimeZ; // 0x5c4	
	bool m_bAxisNotifiedX; // 0x5c8	
	bool m_bAxisNotifiedY; // 0x5c9	
	bool m_bAxisNotifiedZ; // 0x5ca	
private:
	[[maybe_unused]] uint8_t __pad05cb[0x1]; 	// 0x5cb
public:
	JointMotion_t m_nAngularMotionX; // 0x5cc	
	JointMotion_t m_nAngularMotionY; // 0x5d0	
	JointMotion_t m_nAngularMotionZ; // 0x5d4	
	float m_flAngularFrequencyX; // 0x5d8	
	float m_flAngularFrequencyY; // 0x5dc	
	float m_flAngularFrequencyZ; // 0x5e0	
	float m_flAngularDampingRatioX; // 0x5e4	
	float m_flAngularDampingRatioY; // 0x5e8	
	float m_flAngularDampingRatioZ; // 0x5ec	
	float m_flMaxAngularImpulseX; // 0x5f0	
	float m_flMaxAngularImpulseY; // 0x5f4	
	float m_flMaxAngularImpulseZ; // 0x5f8	
private:
	[[maybe_unused]] uint8_t __pad05fc[0x4]; 	// 0x5fc
public:
	CEntityIOOutput m_NotifyForceReachedX; // 0x600	
	CEntityIOOutput m_NotifyForceReachedY; // 0x628	
	CEntityIOOutput m_NotifyForceReachedZ; // 0x650	
};

// Alignment: 0
// Size: 0x590
class CSplineConstraint : public CPhysConstraint
{
public:
	// @note: no members available
};

// Alignment: 6
// Size: 0x520
class CPhysicsNPCSolver : public CLogicalEntity
{
public:
	CPhysicsNPCSolver* m_pNext; // 0x4f8	
	CHandle< CAI_BaseNPC > m_hNPC; // 0x500	
	CHandle< CBaseEntity > m_hEntity; // 0x504	
private:
	[[maybe_unused]] uint8_t __pad0508[0x8]; 	// 0x508
public:
	float m_separationDuration; // 0x510	
	float m_cancelTime; // 0x514	
	bool m_allowIntersection; // 0x518	
};

// Alignment: 4
// Size: 0x508
class CPhysicsEntitySolver : public CLogicalEntity
{
public:
	CHandle< CBaseEntity > m_hMovingEntity; // 0x4f8	
	CHandle< CBaseEntity > m_hPhysicsBlocker; // 0x4fc	
	float m_separationDuration; // 0x500	
	float m_cancelTime; // 0x504	
};

// Alignment: 8
// Size: 0x538
class CPhysicsSpring : public CBaseEntity
{
public:
	float m_flFrequency; // 0x4f8	
	float m_flDampingRatio; // 0x4fc	
	float m_flRestLength; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_nameAttachStart; // 0x508	
	CUtlSymbolLarge m_nameAttachEnd; // 0x510	
	Vector m_start; // 0x518	
	Vector m_end; // 0x524	
	uint32_t m_teleportTick; // 0x530	
};

// Alignment: 0
// Size: 0x778
class CSimplePhysicsBrush : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x528
class CPhysConvert : public CLogicalEntity
{
public:
	CEntityIOOutput m_OnConvert; // 0x4f0	
	CUtlSymbolLarge m_swapModel; // 0x518	
	float m_flMassOverride; // 0x520	
};

// Alignment: 7
// Size: 0x518
class CPointPush : public CPointEntity
{
public:
	bool m_bEnabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_flMagnitude; // 0x4f4	
	float m_flRadius; // 0x4f8	
	float m_flInnerRadius; // 0x4fc	
	float m_flConeOfInfluence; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_iszFilterName; // 0x508	
	CHandle< CBaseFilter > m_hFilter; // 0x510	
};

// Alignment: 0
// Size: 0x4f0
class CSprayCan : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x4f8
class CInfoPlayerStart : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
};

// Alignment: 2
// Size: 0x508
class CPointBonusMapsAccessor : public CPointEntity
{
public:
	CUtlSymbolLarge m_String_tFileName; // 0x4f0	
	CUtlSymbolLarge m_String_tMapName; // 0x4f8	
};

// Alignment: 7
// Size: 0x540
class CPointEntityFinder : public CBaseEntity
{
public:
	CHandle< CBaseEntity > m_hEntity; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_iFilterName; // 0x4f8	
	CHandle< CBaseFilter > m_hFilter; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_iRefName; // 0x508	
	CHandle< CBaseEntity > m_hReference; // 0x510	
	EntFinderMethod_t m_FindMethod; // 0x514	
	CEntityIOOutput m_OnFoundEntity; // 0x518	
};

// Alignment: 3
// Size: 0x500
class CPointHMDAnchor : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	// MNetworkEnable
	float m_flEnableTime; // 0x4f4	
	// MNetworkEnable
	int32_t m_nPlayerIndex; // 0x4f8	
};

// Alignment: 0
// Size: 0x500
class CPointHMDAnchorOverride : public CPointHMDAnchor
{
public:
	// @note: no members available
};

// Alignment: 44
// Size: 0x6e8
class CPointValueRemapper : public CBaseEntity
{
public:
	// MNetworkEnable
	bool m_bDisabled; // 0x4f0	
	// MNetworkEnable
	bool m_bUpdateOnClient; // 0x4f1	
private:
	[[maybe_unused]] uint8_t __pad04f2[0x2]; 	// 0x4f2
public:
	// MNetworkEnable
	ValueRemapperInputType_t m_nInputType; // 0x4f4	
	CUtlSymbolLarge m_iszRemapLineStartName; // 0x4f8	
	CUtlSymbolLarge m_iszRemapLineEndName; // 0x500	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hRemapLineStart; // 0x508	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hRemapLineEnd; // 0x50c	
	// MNetworkEnable
	float m_flMaximumChangePerSecond; // 0x510	
	// MNetworkEnable
	float m_flDisengageDistance; // 0x514	
	// MNetworkEnable
	float m_flEngageDistance; // 0x518	
	// MNetworkEnable
	bool m_bRequiresUseKey; // 0x51c	
private:
	[[maybe_unused]] uint8_t __pad051d[0x3]; 	// 0x51d
public:
	// MNetworkEnable
	ValueRemapperOutputType_t m_nOutputType; // 0x520	
private:
	[[maybe_unused]] uint8_t __pad0524[0x4]; 	// 0x524
public:
	CUtlSymbolLarge m_iszOutputEntityName; // 0x528	
	CUtlSymbolLarge m_iszOutputEntity2Name; // 0x530	
	CUtlSymbolLarge m_iszOutputEntity3Name; // 0x538	
	CUtlSymbolLarge m_iszOutputEntity4Name; // 0x540	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseEntity > > m_hOutputEntities; // 0x548	
	// MNetworkEnable
	ValueRemapperHapticsType_t m_nHapticsType; // 0x560	
	// MNetworkEnable
	ValueRemapperMomentumType_t m_nMomentumType; // 0x564	
	// MNetworkEnable
	float m_flMomentumModifier; // 0x568	
	// MNetworkEnable
	float m_flSnapValue; // 0x56c	
	float m_flCurrentMomentum; // 0x570	
	// MNetworkEnable
	ValueRemapperRatchetType_t m_nRatchetType; // 0x574	
	float m_flRatchetOffset; // 0x578	
	// MNetworkEnable
	float m_flInputOffset; // 0x57c	
	bool m_bEngaged; // 0x580	
	bool m_bFirstUpdate; // 0x581	
private:
	[[maybe_unused]] uint8_t __pad0582[0x2]; 	// 0x582
public:
	float m_flPreviousValue; // 0x584	
	float m_flPreviousUpdateTickTime; // 0x588	
	Vector m_vecPreviousTestPoint; // 0x58c	
	CHandle< CBasePlayer > m_hUsingPlayer; // 0x598	
	float m_flCustomOutputValue; // 0x59c	
	CUtlSymbolLarge m_iszSoundEngage; // 0x5a0	
	CUtlSymbolLarge m_iszSoundDisengage; // 0x5a8	
	CUtlSymbolLarge m_iszSoundReachedValueZero; // 0x5b0	
	CUtlSymbolLarge m_iszSoundReachedValueOne; // 0x5b8	
	CUtlSymbolLarge m_iszSoundMovingLoop; // 0x5c0	
private:
	[[maybe_unused]] uint8_t __pad05c8[0x8]; 	// 0x5c8
public:
	CEntityOutputTemplate< float32 > m_Position; // 0x5d0	
	CEntityOutputTemplate< float32 > m_PositionDelta; // 0x5f8	
	CEntityIOOutput m_OnReachedValueZero; // 0x620	
	CEntityIOOutput m_OnReachedValueOne; // 0x648	
	CEntityIOOutput m_OnReachedValueCustom; // 0x670	
	CEntityIOOutput m_OnEngage; // 0x698	
	CEntityIOOutput m_OnDisengage; // 0x6c0	
};

// Alignment: 11
// Size: 0x9d8
class CPointWorldText : public CModelPointEntity
{
public:
	// MNetworkEnable
	char m_messageText[512]; // 0x778	
	// MNetworkEnable
	char m_FontName[64]; // 0x978	
	// MNetworkEnable
	bool m_bEnabled; // 0x9b8	
	// MNetworkEnable
	bool m_bFullbright; // 0x9b9	
private:
	[[maybe_unused]] uint8_t __pad09ba[0x2]; 	// 0x9ba
public:
	// MNetworkEnable
	float m_flWorldUnitsPerPx; // 0x9bc	
	// MNetworkEnable
	float m_flFontSize; // 0x9c0	
	// MNetworkEnable
	float m_flDepthOffset; // 0x9c4	
	// MNetworkEnable
	Color m_Color; // 0x9c8	
	// MNetworkEnable
	PointWorldTextJustifyHorizontal_t m_nJustifyHorizontal; // 0x9cc	
	// MNetworkEnable
	PointWorldTextJustifyVertical_t m_nJustifyVertical; // 0x9d0	
	// MNetworkEnable
	PointWorldTextReorientMode_t m_nReorientMode; // 0x9d4	
};

// Alignment: 12
// Size: 0x5b8
class CPointAngleSensor : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x7]; 	// 0x4f1
public:
	CUtlSymbolLarge m_nLookAtName; // 0x4f8	
	CHandle< CBaseEntity > m_hTargetEntity; // 0x500	
	CHandle< CBaseEntity > m_hLookAtEntity; // 0x504	
	float m_flDuration; // 0x508	
	float m_flDotTolerance; // 0x50c	
	float m_flFacingTime; // 0x510	
	bool m_bFired; // 0x514	
private:
	[[maybe_unused]] uint8_t __pad0515[0x3]; 	// 0x515
public:
	CEntityIOOutput m_OnFacingLookat; // 0x518	
	CEntityIOOutput m_OnNotFacingLookat; // 0x540	
	CEntityOutputTemplate< Vector > m_TargetDir; // 0x568	
	CEntityOutputTemplate< float32 > m_FacingPercentage; // 0x590	
};

// Alignment: 3
// Size: 0x520
class CPointProximitySensor : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	CHandle< CBaseEntity > m_hTargetEntity; // 0x4f4	
	CEntityOutputTemplate< float32 > m_Distance; // 0x4f8	
};

// Alignment: 16
// Size: 0x618
class CPointAngularVelocitySensor : public CPointEntity
{
public:
	CHandle< CBaseEntity > m_hTargetEntity; // 0x4f0	
	float m_flThreshold; // 0x4f4	
	int32_t m_nLastCompareResult; // 0x4f8	
	int32_t m_nLastFireResult; // 0x4fc	
	float m_flFireTime; // 0x500	
	float m_flFireInterval; // 0x504	
	float m_flLastAngVelocity; // 0x508	
	QAngle m_lastOrientation; // 0x50c	
	Vector m_vecAxis; // 0x518	
	bool m_bUseHelper; // 0x524	
private:
	[[maybe_unused]] uint8_t __pad0525[0x3]; 	// 0x525
public:
	CEntityOutputTemplate< float32 > m_AngularVelocity; // 0x528	
	CEntityIOOutput m_OnLessThan; // 0x550	
	CEntityIOOutput m_OnLessThanOrEqualTo; // 0x578	
	CEntityIOOutput m_OnGreaterThan; // 0x5a0	
	CEntityIOOutput m_OnGreaterThanOrEqualTo; // 0x5c8	
	CEntityIOOutput m_OnEqualTo; // 0x5f0	
};

// Alignment: 6
// Size: 0x538
class CPointVelocitySensor : public CPointEntity
{
public:
	CHandle< CBaseEntity > m_hTargetEntity; // 0x4f0	
	Vector m_vecAxis; // 0x4f4	
	bool m_bEnabled; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0501[0x3]; 	// 0x501
public:
	float m_fPrevVelocity; // 0x504	
	float m_flAvgInterval; // 0x508	
private:
	[[maybe_unused]] uint8_t __pad050c[0x4]; 	// 0x50c
public:
	CEntityOutputTemplate< float32 > m_Velocity; // 0x510	
};

// Alignment: 6
// Size: 0x510
class CPointHurt : public CPointEntity
{
public:
	int32_t m_nDamage; // 0x4f0	
	int32_t m_bitsDamageType; // 0x4f4	
	float m_flRadius; // 0x4f8	
	float m_flDelay; // 0x4fc	
	CUtlSymbolLarge m_strTarget; // 0x500	
	CHandle< CBaseEntity > m_pActivator; // 0x508	
};

// Alignment: 3
// Size: 0x510
class CPointTeleport : public CBaseEntity
{
public:
	Vector m_vSaveOrigin; // 0x4f0	
	QAngle m_vSaveAngles; // 0x4fc	
	bool m_bTeleportParentedEntities; // 0x508	
};

// Alignment: 0
// Size: 0x4f0
class CEnableMotionFixup : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CFuncPropRespawnZone : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x500
class CRagdollManager : public CBaseEntity
{
public:
	// MNetworkEnable
	int8_t m_iCurrentMaxRagdollCount; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	int32_t m_iMaxRagdollCount; // 0x4f4	
	bool m_bSaveImportant; // 0x4f8	
};

// Alignment: 3
// Size: 0x788
class CRevertSaved : public CModelPointEntity
{
public:
	float m_loadTime; // 0x778	
	float m_Duration; // 0x77c	
	float m_HoldTime; // 0x780	
};

// Alignment: 3
// Size: 0x5c8
class CSceneListManager : public CLogicalEntity
{
public:
	CUtlVector< CHandle< CSceneListManager > > m_hListManagers; // 0x4f0	
	CUtlSymbolLarge m_iszScenes[16]; // 0x508	
	CHandle< CBaseEntity > m_hScenes[16]; // 0x588	
};

// Alignment: 80
// Size: 0x990
class CSceneEntity : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszSceneFile; // 0x4f8	
	CUtlSymbolLarge m_iszResumeSceneFile; // 0x500	
	CUtlSymbolLarge m_iszTarget1; // 0x508	
	CUtlSymbolLarge m_iszTarget2; // 0x510	
	CUtlSymbolLarge m_iszTarget3; // 0x518	
	CUtlSymbolLarge m_iszTarget4; // 0x520	
	CUtlSymbolLarge m_iszTarget5; // 0x528	
	CUtlSymbolLarge m_iszTarget6; // 0x530	
	CUtlSymbolLarge m_iszTarget7; // 0x538	
	CUtlSymbolLarge m_iszTarget8; // 0x540	
	CHandle< CBaseEntity > m_hTarget1; // 0x548	
	CHandle< CBaseEntity > m_hTarget2; // 0x54c	
	CHandle< CBaseEntity > m_hTarget3; // 0x550	
	CHandle< CBaseEntity > m_hTarget4; // 0x554	
	CHandle< CBaseEntity > m_hTarget5; // 0x558	
	CHandle< CBaseEntity > m_hTarget6; // 0x55c	
	CHandle< CBaseEntity > m_hTarget7; // 0x560	
	CHandle< CBaseEntity > m_hTarget8; // 0x564	
	// MNetworkEnable
	bool m_bIsPlayingBack; // 0x568	
	// MNetworkEnable
	bool m_bPaused; // 0x569	
	// MNetworkEnable
	bool m_bMultiplayer; // 0x56a	
	// MNetworkEnable
	bool m_bAutogenerated; // 0x56b	
	// MNetworkEnable
	float m_flForceClientTime; // 0x56c	
	float m_flCurrentTime; // 0x570	
	float m_flFrameTime; // 0x574	
	bool m_bCancelAtNextInterrupt; // 0x578	
private:
	[[maybe_unused]] uint8_t __pad0579[0x3]; 	// 0x579
public:
	float m_fPitch; // 0x57c	
	bool m_bAutomated; // 0x580	
private:
	[[maybe_unused]] uint8_t __pad0581[0x3]; 	// 0x581
public:
	int32_t m_nAutomatedAction; // 0x584	
	float m_flAutomationDelay; // 0x588	
	float m_flAutomationTime; // 0x58c	
	CHandle< CBaseEntity > m_hWaitingForThisResumeScene; // 0x590	
	bool m_bWaitingForResumeScene; // 0x594	
	bool m_bPausedViaInput; // 0x595	
	bool m_bPauseAtNextInterrupt; // 0x596	
	bool m_bWaitingForActor; // 0x597	
	bool m_bWaitingForInterrupt; // 0x598	
	bool m_bInterruptedActorsScenes; // 0x599	
	bool m_bBreakOnNonIdle; // 0x59a	
private:
	[[maybe_unused]] uint8_t __pad059b[0x5]; 	// 0x59b
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseFlex > > m_hActorList; // 0x5a0	
	CUtlVector< CHandle< CBaseEntity > > m_hRemoveActorList; // 0x5b8	
private:
	[[maybe_unused]] uint8_t __pad05d0[0x8]; 	// 0x5d0
public:
	int32_t m_nSceneFlushCounter; // 0x5d8	
	// MNetworkEnable
	uint16_t m_nSceneStringIndex; // 0x5dc	
private:
	[[maybe_unused]] uint8_t __pad05de[0x2]; 	// 0x5de
public:
	CEntityIOOutput m_OnStart; // 0x5e0	
	CEntityIOOutput m_OnCompletion; // 0x608	
	CEntityIOOutput m_OnCanceled; // 0x630	
	CEntityIOOutput m_OnPaused; // 0x658	
	CEntityIOOutput m_OnResumed; // 0x680	
	CEntityIOOutput m_OnTrigger1; // 0x6a8	
	CEntityIOOutput m_OnTrigger2; // 0x6d0	
	CEntityIOOutput m_OnTrigger3; // 0x6f8	
	CEntityIOOutput m_OnTrigger4; // 0x720	
	CEntityIOOutput m_OnTrigger5; // 0x748	
	CEntityIOOutput m_OnTrigger6; // 0x770	
	CEntityIOOutput m_OnTrigger7; // 0x798	
	CEntityIOOutput m_OnTrigger8; // 0x7c0	
	CEntityIOOutput m_OnTrigger9; // 0x7e8	
	CEntityIOOutput m_OnTrigger10; // 0x810	
	CEntityIOOutput m_OnTrigger11; // 0x838	
	CEntityIOOutput m_OnTrigger12; // 0x860	
	CEntityIOOutput m_OnTrigger13; // 0x888	
	CEntityIOOutput m_OnTrigger14; // 0x8b0	
	CEntityIOOutput m_OnTrigger15; // 0x8d8	
	CEntityIOOutput m_OnTrigger16; // 0x900	
	CHandle< CSceneEntity > m_hInterruptScene; // 0x928	
	int32_t m_nInterruptCount; // 0x92c	
	bool m_bSceneMissing; // 0x930	
	bool m_bInterrupted; // 0x931	
	bool m_bCompletedEarly; // 0x932	
	bool m_bInterruptSceneFinished; // 0x933	
	bool m_bRestoring; // 0x934	
	bool m_bGenerated; // 0x935	
private:
	[[maybe_unused]] uint8_t __pad0936[0x2]; 	// 0x936
public:
	CUtlVector< CHandle< CSceneEntity > > m_hNotifySceneCompletion; // 0x938	
	CUtlVector< CHandle< CSceneListManager > > m_hListManagers; // 0x950	
	CUtlSymbolLarge m_iszSoundName; // 0x968	
	CHandle< CBaseFlex > m_hActor; // 0x970	
	CHandle< CBaseEntity > m_hActivator; // 0x974	
	CHandle< CBaseEntity > m_hCamera; // 0x978	
	int32_t m_BusyActor; // 0x97c	
	SceneOnPlayerDeath_t m_iPlayerDeathBehavior; // 0x980	
	static int32_t &Get_s_nSceneFlushCounter(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CSceneEntity")->m_static_fields[0]->m_instance);};
};

// Alignment: 59
// Size: 0x820
class CScriptedSequence : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszEntry; // 0x4f0	
	CUtlSymbolLarge m_iszPreIdle; // 0x4f8	
	CUtlSymbolLarge m_iszPlay; // 0x500	
	CUtlSymbolLarge m_iszPostIdle; // 0x508	
	CUtlSymbolLarge m_iszCustomMove; // 0x510	
	CUtlSymbolLarge m_iszModifierToAddOnPlay; // 0x518	
	CUtlSymbolLarge m_iszNextScript; // 0x520	
	CUtlSymbolLarge m_iszEntity; // 0x528	
	CUtlSymbolLarge m_iszSyncGroup; // 0x530	
	int32_t m_nGroundIKPreference; // 0x538	
	int32_t m_fMoveTo; // 0x53c	
	bool m_bIsPlayingEntry; // 0x540	
	bool m_bLoopActionSequence; // 0x541	
	bool m_bAllowCameraMovement; // 0x542	
	bool m_bSynchPostIdles; // 0x543	
	bool m_bIgnoreGravity; // 0x544	
	bool m_bDisableNPCCollisions; // 0x545	
	bool m_bKeepAnimgraphLockedPost; // 0x546	
private:
	[[maybe_unused]] uint8_t __pad0547[0x1]; 	// 0x547
public:
	float m_flRadius; // 0x548	
	float m_flRepeat; // 0x54c	
	float m_flPlayAnimFadeInTime; // 0x550	
	float m_flMoveInterpTime; // 0x554	
	int32_t m_iDelay; // 0x558	
	bool m_bDelayed; // 0x55c	
private:
	[[maybe_unused]] uint8_t __pad055d[0x3]; 	// 0x55d
public:
	float m_startTime; // 0x560	
	bool m_bWaitForBeginSequence; // 0x564	
private:
	[[maybe_unused]] uint8_t __pad0565[0x3]; 	// 0x565
public:
	int32_t m_saved_effects; // 0x568	
	int32_t m_savedFlags; // 0x56c	
	int32_t m_savedCollisionGroup; // 0x570	
	bool m_interruptable; // 0x574	
	bool m_sequenceStarted; // 0x575	
	bool m_bPrevAnimatedEveryTick; // 0x576	
	bool m_bForcedAnimatedEveryTick; // 0x577	
	CHandle< CBaseEntity > m_hTargetEnt; // 0x578	
	CHandle< CScriptedSequence > m_hNextCine; // 0x57c	
	bool m_bThinking; // 0x580	
	bool m_bInitiatedSelfDelete; // 0x581	
	bool m_bIsTeleportingDueToMoveTo; // 0x582	
	bool m_bAllowCustomInterruptConditions; // 0x583	
	CHandle< CBaseEntity > m_hLastFoundEntity; // 0x584	
	CHandle< CBaseEntity > m_hForcedTarget; // 0x588	
	bool m_bDontCancelOtherSequences; // 0x58c	
	bool m_bForceSynch; // 0x58d	
	bool m_bTargetWasAsleep; // 0x58e	
	bool m_bPreventUpdateYawOnFinish; // 0x58f	
	bool m_bEnsureOnNavmeshOnFinish; // 0x590	
private:
	[[maybe_unused]] uint8_t __pad0591[0x3]; 	// 0x591
public:
	ScriptedOnDeath_t m_onDeathBehavior; // 0x594	
	ScriptedConflictResponse_t m_ConflictResponse; // 0x598	
private:
	[[maybe_unused]] uint8_t __pad059c[0x4]; 	// 0x59c
public:
	CEntityIOOutput m_OnBeginSequence; // 0x5a0	
	CEntityIOOutput m_OnActionStartOrLoop; // 0x5c8	
	CEntityIOOutput m_OnEndSequence; // 0x5f0	
	CEntityIOOutput m_OnPostIdleEndSequence; // 0x618	
	CEntityIOOutput m_OnCancelSequence; // 0x640	
	CEntityIOOutput m_OnCancelFailedSequence; // 0x668	
	CEntityIOOutput m_OnScriptEvent[8]; // 0x690	
	VMatrix m_matInteractionPosition; // 0x7d0	
	CHandle< CBaseEntity > m_hInteractionRelativeEntity; // 0x810	
	int32_t m_iPlayerDeathBehavior; // 0x814	
	float m_flOldIKMasterBlendAmount; // 0x818	
};

// Alignment: 8
// Size: 0x538
class CSoundOpvarSetEntity : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszStackName; // 0x4f8	
	CUtlSymbolLarge m_iszOperatorName; // 0x500	
	CUtlSymbolLarge m_iszOpvarName; // 0x508	
	int32_t m_nOpvarType; // 0x510	
	int32_t m_nOpvarIndex; // 0x514	
	float m_flOpvarValue; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad051c[0x4]; 	// 0x51c
public:
	CUtlSymbolLarge m_OpvarValueString; // 0x520	
	bool m_bSetOnSpawn; // 0x528	
};

// Alignment: 6
// Size: 0x510
class CAISound : public CPointEntity
{
public:
	int32_t m_iSoundType; // 0x4f0	
	int32_t m_iSoundContext; // 0x4f4	
	int32_t m_iVolume; // 0x4f8	
	int32_t m_iSoundIndex; // 0x4fc	
	float m_flDuration; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_iszProxyEntityName; // 0x508	
};

// Alignment: 1
// Size: 0x4f8
class CSoundStackSave : public CLogicalEntity
{
public:
	CUtlSymbolLarge m_iszStackName; // 0x4f0	
};

// Alignment: 12
// Size: 0x598
class CSoundEventEntity : public CBaseEntity
{
public:
	bool m_bStartOnSpawn; // 0x4f0	
	bool m_bToLocalPlayer; // 0x4f1	
	bool m_bStopOnNew; // 0x4f2	
	bool m_bSaveRestore; // 0x4f3	
	bool m_bSavedIsPlaying; // 0x4f4	
private:
	[[maybe_unused]] uint8_t __pad04f5[0x3]; 	// 0x4f5
public:
	float m_flSavedElapsedTime; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	CUtlSymbolLarge m_iszSourceEntityName; // 0x500	
	CUtlSymbolLarge m_iszAttachmentName; // 0x508	
	CEntityOutputTemplate< uint64 > m_onGUIDChanged; // 0x510	
	CEntityIOOutput m_onSoundFinished; // 0x538	
private:
	[[maybe_unused]] uint8_t __pad0560[0x20]; 	// 0x560
public:
	CUtlSymbolLarge m_iszSoundName; // 0x580	
private:
	[[maybe_unused]] uint8_t __pad0588[0x8]; 	// 0x588
public:
	CEntityHandle m_hSource; // 0x590	
};

// Alignment: 0
// Size: 0x598
class CSoundEventEntityAlias_snd_event_point : public CSoundEventEntity
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x5b0
class CSoundEventAABBEntity : public CSoundEventEntity
{
public:
	Vector m_vMins; // 0x598	
	Vector m_vMaxs; // 0x5a4	
};

// Alignment: 6
// Size: 0x5d8
class CSoundEventPathCornerEntity : public CSoundEventEntity
{
public:
	CUtlSymbolLarge m_iszPathCorner; // 0x598	
	int32_t m_iCountMax; // 0x5a0	
	float m_flDistanceMax; // 0x5a4	
	float m_flDistMaxSqr; // 0x5a8	
	float m_flDotProductMax; // 0x5ac	
	bool bPlaying; // 0x5b0	
};

// Alignment: 2
// Size: 0x508
class CSoundEventParameter : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszParamName; // 0x4f8	
	float m_flFloatValue; // 0x500	
};

// Alignment: 0
// Size: 0x580
class CEnvSoundscapeProxyAlias_snd_soundscape_proxy : public CEnvSoundscapeProxy
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x578
class CEnvSoundscapeAlias_snd_soundscape : public CEnvSoundscape
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x578
class CEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable : public CEnvSoundscapeTriggerable
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CNullEntity : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x4f8
class CBaseDMStart : public CPointEntity
{
public:
	CUtlSymbolLarge m_Master; // 0x4f0	
};

// Alignment: 0
// Size: 0x4f0
class CInfoLandmark : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 14
// Size: 0x7c0
class CSun : public CBaseModelEntity
{
public:
	// MNetworkEnable
	Vector m_vDirection; // 0x778	
	// MNetworkEnable
	Color m_clrOverlay; // 0x784	
	// MNetworkEnable
	CUtlSymbolLarge m_iszEffectName; // 0x788	
	// MNetworkEnable
	CUtlSymbolLarge m_iszSSEffectName; // 0x790	
	// MNetworkEnable
	bool m_bOn; // 0x798	
	// MNetworkEnable
	bool m_bmaxColor; // 0x799	
private:
	[[maybe_unused]] uint8_t __pad079a[0x2]; 	// 0x79a
public:
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "100"
	float m_flSize; // 0x79c	
	// MNetworkEnable
	// MNetworkMinValue "-360"
	// MNetworkMaxValue "360"
	float m_flRotation; // 0x7a0	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "100"
	float m_flHazeScale; // 0x7a4	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "2"
	float m_flAlphaHaze; // 0x7a8	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "2"
	float m_flAlphaHdr; // 0x7ac	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "2"
	float m_flAlphaScale; // 0x7b0	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "100"
	float m_flHDRColorScale; // 0x7b4	
	// MNetworkEnable
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	float m_flFarZScale; // 0x7b8	
};

// Alignment: 2
// Size: 0x508
class CTankTargetChange : public CPointEntity
{
public:
	CVariantBase< CVariantDefaultAllocator > m_newTarget; // 0x4f0	
	CUtlSymbolLarge m_newTargetName; // 0x500	
};

// Alignment: 7
// Size: 0x530
class CTankTrainAI : public CPointEntity
{
public:
	CHandle< CFuncTrackTrain > m_hTrain; // 0x4f0	
	CHandle< CBaseEntity > m_hTargetEntity; // 0x4f4	
	int32_t m_soundPlaying; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x14]; 	// 0x4fc
public:
	CUtlSymbolLarge m_startSoundName; // 0x510	
	CUtlSymbolLarge m_engineSoundName; // 0x518	
	CUtlSymbolLarge m_movementSoundName; // 0x520	
	CUtlSymbolLarge m_targetEntityName; // 0x528	
};

// Alignment: 2
// Size: 0x4f8
class CHandleTest : public CBaseEntity
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_Handle; // 0x4f0	
	// MNetworkEnable
	bool m_bSendHandle; // 0x4f4	
};

// Alignment: 0
// Size: 0x4f0
class CHandleDummy : public CBaseEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x778
class CFuncTrainControls : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x788
class CTriggerVolume : public CBaseModelEntity
{
public:
	CUtlSymbolLarge m_iFilterName; // 0x778	
	CHandle< CBaseFilter > m_hFilter; // 0x780	
};

// Alignment: 0
// Size: 0x4f0
class CInfoTeleportDestination : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x4f8
class CAI_ChangeTarget : public CBaseEntity
{
public:
	CUtlSymbolLarge m_iszNewTarget; // 0x4f0	
};

// Alignment: 4
// Size: 0x510
class CAI_ChangeHintGroup : public CBaseEntity
{
public:
	int32_t m_iSearchType; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_strSearchName; // 0x4f8	
	CUtlSymbolLarge m_strNewHintGroup; // 0x500	
	float m_flRadius; // 0x508	
};

// Alignment: 0
// Size: 0x4f0
class CLogicProximity : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x4f0
class CInfoSpawnGroupLandmark : public CPointEntity
{
public:
	// @note: no members available
};

// Alignment: 11
// Size: 0x5f0
class CInfoSpawnGroupLoadUnload : public CLogicalEntity
{
public:
	CEntityIOOutput m_OnSpawnGroupLoadStarted; // 0x4f0	
	CEntityIOOutput m_OnSpawnGroupLoadFinished; // 0x518	
	CEntityIOOutput m_OnSpawnGroupUnloadStarted; // 0x540	
	CEntityIOOutput m_OnSpawnGroupUnloadFinished; // 0x568	
	CUtlSymbolLarge m_iszSpawnGroupName; // 0x590	
	CUtlSymbolLarge m_iszSpawnGroupFilterName; // 0x598	
	CUtlSymbolLarge m_iszLandmarkName; // 0x5a0	
	CUtlString m_sFixedSpawnGroupName; // 0x5a8	
	float m_flTimeoutInterval; // 0x5b0	
	bool m_bStreamingStarted; // 0x5b4	
	bool m_bUnloadingStarted; // 0x5b5	
};

// Alignment: 1
// Size: 0x788
class CFuncNavObstruction : public CBaseModelEntity
{
public:
	bool m_bDisabled; // 0x780	
};

// Alignment: 10
// Size: 0x588
class CAmbientGeneric : public CPointEntity
{
public:
	float m_radius; // 0x4f0	
	float m_flMaxRadius; // 0x4f4	
	soundlevel_t m_iSoundLevel; // 0x4f8	
	dynpitchvol_t m_dpv; // 0x4fc	
	bool m_fActive; // 0x560	
	bool m_fLooping; // 0x561	
private:
	[[maybe_unused]] uint8_t __pad0562[0x6]; 	// 0x562
public:
	CUtlSymbolLarge m_iszSound; // 0x568	
	CUtlSymbolLarge m_sSourceEntName; // 0x570	
	CHandle< CBaseEntity > m_hSoundSource; // 0x578	
	CEntityIndex m_nSoundSourceEntIndex; // 0x57c	
};

// Alignment: 16
// Size: 0x7f8
class CBaseToggle : public CBaseModelEntity
{
public:
	TOGGLE_STATE m_toggle_state; // 0x778	
	float m_flMoveDistance; // 0x77c	
	float m_flWait; // 0x780	
	float m_flLip; // 0x784	
	bool m_bAlwaysFireBlockedOutputs; // 0x788	
private:
	[[maybe_unused]] uint8_t __pad0789[0x3]; 	// 0x789
public:
	Vector m_vecPosition1; // 0x78c	
	Vector m_vecPosition2; // 0x798	
	QAngle m_vecMoveAng; // 0x7a4	
	QAngle m_vecAngle1; // 0x7b0	
	QAngle m_vecAngle2; // 0x7bc	
	float m_flHeight; // 0x7c8	
	CHandle< CBaseEntity > m_hActivator; // 0x7cc	
	Vector m_vecFinalDest; // 0x7d0	
	QAngle m_vecFinalAngle; // 0x7dc	
	int32_t m_movementType; // 0x7e8	
private:
	[[maybe_unused]] uint8_t __pad07ec[0x4]; 	// 0x7ec
public:
	CUtlSymbolLarge m_sMaster; // 0x7f0	
};

// Alignment: 22
// Size: 0x940
class CBaseButton : public CBaseToggle
{
public:
	QAngle m_angMoveEntitySpace; // 0x7f8	
	bool m_fStayPushed; // 0x804	
	bool m_fRotating; // 0x805	
private:
	[[maybe_unused]] uint8_t __pad0806[0x2]; 	// 0x806
public:
	locksound_t m_ls; // 0x808	
	CUtlSymbolLarge m_sUseSound; // 0x828	
	CUtlSymbolLarge m_sLockedSound; // 0x830	
	CUtlSymbolLarge m_sUnlockedSound; // 0x838	
	bool m_bLocked; // 0x840	
private:
	[[maybe_unused]] uint8_t __pad0841[0x3]; 	// 0x841
public:
	float m_flUseLockedTime; // 0x844	
	bool m_bSolidBsp; // 0x848	
private:
	[[maybe_unused]] uint8_t __pad0849[0x7]; 	// 0x849
public:
	CEntityIOOutput m_OnDamaged; // 0x850	
	CEntityIOOutput m_OnPressed; // 0x878	
	CEntityIOOutput m_OnUseLocked; // 0x8a0	
	CEntityIOOutput m_OnIn; // 0x8c8	
	CEntityIOOutput m_OnOut; // 0x8f0	
	int32_t m_nState; // 0x918	
	CEntityHandle m_hConstraint; // 0x91c	
	CEntityHandle m_hConstraintParent; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0924[0x4]; 	// 0x924
public:
	CUtlSymbolLarge m_sGlowEntity; // 0x928	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_glowEntity; // 0x930	
	// MNetworkEnable
	bool m_usable; // 0x934	
private:
	[[maybe_unused]] uint8_t __pad0935[0x3]; 	// 0x935
public:
	// MNetworkEnable
	CUtlSymbolLarge m_szDisplayText; // 0x938	
};

// Alignment: 0
// Size: 0x940
class CPhysicalButton : public CBaseButton
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x940
class CRotButton : public CBaseButton
{
public:
	// @note: no members available
};

// Alignment: 15
// Size: 0xa48
class CMomentaryRotButton : public CRotButton
{
public:
	bool m_bDisabled; // 0x940	
private:
	[[maybe_unused]] uint8_t __pad0941[0x7]; 	// 0x941
public:
	CEntityOutputTemplate< float32 > m_Position; // 0x948	
	CEntityIOOutput m_OnUnpressed; // 0x970	
	CEntityIOOutput m_OnFullyOpen; // 0x998	
	CEntityIOOutput m_OnFullyClosed; // 0x9c0	
	CEntityIOOutput m_OnReachedPosition; // 0x9e8	
	int32_t m_lastUsed; // 0xa10	
	QAngle m_start; // 0xa14	
	QAngle m_end; // 0xa20	
	float m_IdealYaw; // 0xa2c	
	CUtlSymbolLarge m_sNoise; // 0xa30	
	bool m_bUpdateTarget; // 0xa38	
private:
	[[maybe_unused]] uint8_t __pad0a39[0x3]; 	// 0xa39
public:
	int32_t m_direction; // 0xa3c	
	float m_returnSpeed; // 0xa40	
	float m_flStartPosition; // 0xa44	
};

// Alignment: 4
// Size: 0x508
class CRagdollMagnet : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_radius; // 0x4f4	
	float m_force; // 0x4f8	
	Vector m_axis; // 0x4fc	
};

// Alignment: 26
// Size: 0x9f0
class CBaseDoor : public CBaseToggle
{
public:
	QAngle m_angMoveEntitySpace; // 0x808	
	Vector m_vecMoveDirParentSpace; // 0x814	
	locksound_t m_ls; // 0x820	
	bool m_bForceClosed; // 0x840	
	bool m_bDoorGroup; // 0x841	
	bool m_bLocked; // 0x842	
	bool m_bIgnoreDebris; // 0x843	
	FuncDoorSpawnPos_t m_eSpawnPosition; // 0x844	
	float m_flBlockDamage; // 0x848	
private:
	[[maybe_unused]] uint8_t __pad084c[0x4]; 	// 0x84c
public:
	CUtlSymbolLarge m_NoiseMoving; // 0x850	
	CUtlSymbolLarge m_NoiseArrived; // 0x858	
	CUtlSymbolLarge m_NoiseMovingClosed; // 0x860	
	CUtlSymbolLarge m_NoiseArrivedClosed; // 0x868	
	CUtlSymbolLarge m_ChainTarget; // 0x870	
	CEntityIOOutput m_OnBlockedClosing; // 0x878	
	CEntityIOOutput m_OnBlockedOpening; // 0x8a0	
	CEntityIOOutput m_OnUnblockedClosing; // 0x8c8	
	CEntityIOOutput m_OnUnblockedOpening; // 0x8f0	
	CEntityIOOutput m_OnFullyClosed; // 0x918	
	CEntityIOOutput m_OnFullyOpen; // 0x940	
	CEntityIOOutput m_OnClose; // 0x968	
	CEntityIOOutput m_OnOpen; // 0x990	
	CEntityIOOutput m_OnLockedUse; // 0x9b8	
	bool m_bLoopMoveSound; // 0x9e0	
private:
	[[maybe_unused]] uint8_t __pad09e1[0xb]; 	// 0x9e1
public:
	bool m_isChaining; // 0x9ec	
	// MNetworkEnable
	bool m_bIsUsable; // 0x9ed	
};

// Alignment: 0
// Size: 0x778
class CEntityBlocker : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 10
// Size: 0x7a8
class CEntityDissolve : public CBaseModelEntity
{
public:
	// MNetworkEnable
	float m_flStartTime; // 0x778	
	// MNetworkEnable
	float m_flFadeInStart; // 0x77c	
	// MNetworkEnable
	float m_flFadeInLength; // 0x780	
	// MNetworkEnable
	float m_flFadeOutModelStart; // 0x784	
	// MNetworkEnable
	float m_flFadeOutModelLength; // 0x788	
	// MNetworkEnable
	float m_flFadeOutStart; // 0x78c	
	// MNetworkEnable
	float m_flFadeOutLength; // 0x790	
	// MNetworkEnable
	EntityDisolveType_t m_nDissolveType; // 0x794	
	// MNetworkEnable
	Vector m_vDissolverOrigin; // 0x798	
	// MNetworkEnable
	uint32_t m_nMagnitude; // 0x7a4	
};

// Alignment: 30
// Size: 0x9e0
class CEnvProjectedTexture : public CModelPointEntity
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hTargetEntity; // 0x778	
	// MNetworkEnable
	bool m_bState; // 0x77c	
	// MNetworkEnable
	bool m_bAlwaysUpdate; // 0x77d	
private:
	[[maybe_unused]] uint8_t __pad077e[0x2]; 	// 0x77e
public:
	// MNetworkEnable
	float m_flLightFOV; // 0x780	
	// MNetworkEnable
	bool m_bEnableShadows; // 0x784	
	// MNetworkEnable
	bool m_bSimpleProjection; // 0x785	
	// MNetworkEnable
	bool m_bLightOnlyTarget; // 0x786	
	// MNetworkEnable
	bool m_bLightWorld; // 0x787	
	// MNetworkEnable
	bool m_bCameraSpace; // 0x788	
private:
	[[maybe_unused]] uint8_t __pad0789[0x3]; 	// 0x789
public:
	// MNetworkEnable
	float m_flBrightnessScale; // 0x78c	
	// MNetworkEnable
	Color m_LightColor; // 0x790	
	// MNetworkEnable
	float m_flIntensity; // 0x794	
	// MNetworkEnable
	float m_flLinearAttenuation; // 0x798	
	// MNetworkEnable
	float m_flQuadraticAttenuation; // 0x79c	
	// MNetworkEnable
	bool m_bVolumetric; // 0x7a0	
private:
	[[maybe_unused]] uint8_t __pad07a1[0x3]; 	// 0x7a1
public:
	// MNetworkEnable
	float m_flNoiseStrength; // 0x7a4	
	// MNetworkEnable
	float m_flFlashlightTime; // 0x7a8	
	// MNetworkEnable
	uint32_t m_nNumPlanes; // 0x7ac	
	// MNetworkEnable
	float m_flPlaneOffset; // 0x7b0	
	// MNetworkEnable
	float m_flVolumetricIntensity; // 0x7b4	
	// MNetworkEnable
	float m_flColorTransitionTime; // 0x7b8	
	// MNetworkEnable
	float m_flAmbient; // 0x7bc	
	// MNetworkEnable
	char m_SpotlightTextureName[512]; // 0x7c0	
	// MNetworkEnable
	int32_t m_nSpotlightTextureFrame; // 0x9c0	
	// MNetworkEnable
	uint32_t m_nShadowQuality; // 0x9c4	
	// MNetworkEnable
	// MNetworkBitCount "16"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "500"
	// MNetworkEncodeFlags
	float m_flNearZ; // 0x9c8	
	// MNetworkEnable
	// MNetworkBitCount "18"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1500"
	// MNetworkEncodeFlags
	float m_flFarZ; // 0x9cc	
	// MNetworkEnable
	float m_flProjectionSize; // 0x9d0	
	// MNetworkEnable
	float m_flRotation; // 0x9d4	
	// MNetworkEnable
	bool m_bFlipHorizontal; // 0x9d8	
};

// Alignment: 6
// Size: 0x538
class CMessage : public CPointEntity
{
public:
	CUtlSymbolLarge m_iszMessage; // 0x4f0	
	float m_MessageVolume; // 0x4f8	
	int32_t m_MessageAttenuation; // 0x4fc	
	float m_Radius; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CUtlSymbolLarge m_sNoise; // 0x508	
	CEntityIOOutput m_OnShowMessage; // 0x510	
};

// Alignment: 17
// Size: 0x6b0
class CEnvMicrophone : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	CHandle< CBaseEntity > m_hMeasureTarget; // 0x4f4	
	int32_t m_nSoundMask; // 0x4f8	
	float m_flSensitivity; // 0x4fc	
	float m_flSmoothFactor; // 0x500	
	float m_flMaxRange; // 0x504	
	CUtlSymbolLarge m_iszSpeakerName; // 0x508	
	CHandle< CBaseEntity > m_hSpeaker; // 0x510	
	bool m_bAvoidFeedback; // 0x514	
private:
	[[maybe_unused]] uint8_t __pad0515[0x3]; 	// 0x515
public:
	int32_t m_iSpeakerDSPPreset; // 0x518	
private:
	[[maybe_unused]] uint8_t __pad051c[0x4]; 	// 0x51c
public:
	CUtlSymbolLarge m_iszListenFilter; // 0x520	
	CHandle< CBaseFilter > m_hListenFilter; // 0x528	
private:
	[[maybe_unused]] uint8_t __pad052c[0x4]; 	// 0x52c
public:
	CEntityOutputTemplate< float32 > m_SoundLevel; // 0x530	
	CEntityIOOutput m_OnRoutedSound; // 0x558	
	CEntityIOOutput m_OnHeardSound; // 0x580	
	char m_szLastSound[256]; // 0x5a8	
	int32_t m_iLastRoutedFrame; // 0x6a8	
};

// Alignment: 20
// Size: 0x838
class CBreakable : public CBaseModelEntity
{
public:
	Materials m_Material; // 0x788	
	CHandle< CBaseEntity > m_hBreaker; // 0x78c	
	Explosions m_Explosion; // 0x790	
private:
	[[maybe_unused]] uint8_t __pad0794[0x4]; 	// 0x794
public:
	CUtlSymbolLarge m_iszSpawnObject; // 0x798	
	float m_flPressureDelay; // 0x7a0	
	int32_t m_iMinHealthDmg; // 0x7a4	
	CUtlSymbolLarge m_iszPropData; // 0x7a8	
	float m_impactEnergyScale; // 0x7b0	
private:
	[[maybe_unused]] uint8_t __pad07b4[0x4]; 	// 0x7b4
public:
	CEntityIOOutput m_OnBreak; // 0x7b8	
	CEntityOutputTemplate< float32 > m_OnHealthChanged; // 0x7e0	
	float m_flDmgModBullet; // 0x808	
	float m_flDmgModClub; // 0x80c	
	float m_flDmgModExplosive; // 0x810	
	float m_flDmgModFire; // 0x814	
	CUtlSymbolLarge m_iszPhysicsDamageTableName; // 0x818	
	CUtlSymbolLarge m_iszBasePropData; // 0x820	
	int32_t m_iInteractions; // 0x828	
	PerformanceMode_t m_PerformanceMode; // 0x82c	
	CHandle< CBasePlayer > m_hPhysicsAttacker; // 0x830	
	float m_flLastPhysicsInfluenceTime; // 0x834	
};

// Alignment: 11
// Size: 0x8a0
class CFuncMoveLinear : public CBaseToggle
{
public:
	QAngle m_angMoveEntitySpace; // 0x7f8	
	Vector m_vecMoveDirParentSpace; // 0x804	
	CUtlSymbolLarge m_soundStart; // 0x810	
	CUtlSymbolLarge m_soundStop; // 0x818	
	CUtlSymbolLarge m_currentSound; // 0x820	
	float m_flBlockDamage; // 0x828	
	float m_flStartPosition; // 0x82c	
	float m_flMoveDistance; // 0x830	
private:
	[[maybe_unused]] uint8_t __pad0834[0xc]; 	// 0x834
public:
	CEntityIOOutput m_OnFullyOpen; // 0x840	
	CEntityIOOutput m_OnFullyClosed; // 0x868	
	bool m_bCreateNavObstacle; // 0x890	
};

// Alignment: 13
// Size: 0x7e0
class CFuncRotating : public CBaseModelEntity
{
public:
	QAngle m_vecMoveAng; // 0x778	
	float m_flFanFriction; // 0x784	
	float m_flAttenuation; // 0x788	
	float m_flVolume; // 0x78c	
	float m_flTargetSpeed; // 0x790	
	float m_flMaxSpeed; // 0x794	
	float m_flBlockDamage; // 0x798	
private:
	[[maybe_unused]] uint8_t __pad079c[0x4]; 	// 0x79c
public:
	CUtlSymbolLarge m_NoiseRunning; // 0x7a0	
	bool m_bReversed; // 0x7a8	
private:
	[[maybe_unused]] uint8_t __pad07a9[0xb]; 	// 0x7a9
public:
	QAngle m_angStart; // 0x7b4	
	bool m_bStopAtStartPos; // 0x7c0	
private:
	[[maybe_unused]] uint8_t __pad07c1[0x3]; 	// 0x7c1
public:
	Vector m_vecClientOrigin; // 0x7c4	
	QAngle m_vecClientAngles; // 0x7d0	
};

// Alignment: 1
// Size: 0x780
class CItemGenericTriggerHelper : public CBaseModelEntity
{
public:
	CHandle< CItemGeneric > m_hParentItem; // 0x778	
};

// Alignment: 1
// Size: 0x780
class CMarkupVolume : public CBaseModelEntity
{
public:
	bool m_bEnabled; // 0x778	
};

// Alignment: 5
// Size: 0x7b8
class CMarkupVolumeTagged : public CMarkupVolume
{
public:
	bool m_bIsGroup; // 0x7b0	
	bool m_bGroupByPrefab; // 0x7b1	
	bool m_bGroupByVolume; // 0x7b2	
	bool m_bGroupOtherGroups; // 0x7b3	
	bool m_bIsInGroup; // 0x7b4	
};

// Alignment: 3
// Size: 0x7d0
class CMarkupVolumeWithRef : public CMarkupVolumeTagged
{
public:
	bool m_bUseRef; // 0x7b8	
private:
	[[maybe_unused]] uint8_t __pad07b9[0x3]; 	// 0x7b9
public:
	Vector m_vRefPos; // 0x7bc	
	float m_flRefDot; // 0x7c8	
};

// Alignment: 6
// Size: 0x798
class CFuncBrush : public CBaseModelEntity
{
public:
	BrushSolidities_e m_iSolidity; // 0x778	
	int32_t m_iDisabled; // 0x77c	
	bool m_bSolidBsp; // 0x780	
private:
	[[maybe_unused]] uint8_t __pad0781[0x7]; 	// 0x781
public:
	CUtlSymbolLarge m_iszExcludedClass; // 0x788	
	bool m_bInvertExclusion; // 0x790	
	bool m_bScriptedMovement; // 0x791	
};

// Alignment: 9
// Size: 0x548
class CPathTrack : public CPointEntity
{
public:
	CPathTrack* m_pnext; // 0x4f0	
	CPathTrack* m_pprevious; // 0x4f8	
	CPathTrack* m_paltpath; // 0x500	
	float m_flRadius; // 0x508	
	float m_length; // 0x50c	
	CUtlSymbolLarge m_altName; // 0x510	
	int32_t m_nIterVal; // 0x518	
	TrackOrientationType_t m_eOrientationType; // 0x51c	
	CEntityIOOutput m_OnPass; // 0x520	
	static int32_t &Get_s_nCurrIterVal(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CPathTrack")->m_static_fields[0]->m_instance);};
	static bool &Get_s_bIsIterating(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CPathTrack")->m_static_fields[1]->m_instance);};
};

// Alignment: 14
// Size: 0x948
class CPhysBox : public CBreakable
{
public:
	int32_t m_damageType; // 0x838	
	float m_massScale; // 0x83c	
	int32_t m_damageToEnableMotion; // 0x840	
	float m_flForceToEnableMotion; // 0x844	
	QAngle m_angPreferredCarryAngles; // 0x848	
	bool m_bNotSolidToWorld; // 0x854	
private:
	[[maybe_unused]] uint8_t __pad0855[0x3]; 	// 0x855
public:
	int32_t m_iExploitableByPlayer; // 0x858	
	float m_flTouchOutputPerEntityDelay; // 0x85c	
	CEntityIOOutput m_OnDamaged; // 0x860	
	CEntityIOOutput m_OnAwakened; // 0x888	
	CEntityIOOutput m_OnMotionEnabled; // 0x8b0	
	CEntityIOOutput m_OnPlayerUse; // 0x8d8	
	CEntityIOOutput m_OnStartTouch; // 0x900	
	CHandle< CBasePlayer > m_hCarryingPlayer; // 0x928	
};

// Alignment: 9
// Size: 0x540
class CPhysExplosion : public CPointEntity
{
public:
	bool m_bExplodeOnSpawn; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_flMagnitude; // 0x4f4	
	float m_flDamage; // 0x4f8	
	float m_radius; // 0x4fc	
	CUtlSymbolLarge m_targetEntityName; // 0x500	
	float m_flInnerRadius; // 0x508	
	float m_flPushScale; // 0x50c	
	bool m_bConvertToDebrisWhenPossible; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0511[0x7]; 	// 0x511
public:
	CEntityIOOutput m_OnPushedPlayer; // 0x518	
};

// Alignment: 3
// Size: 0x500
class CPhysImpact : public CPointEntity
{
public:
	float m_damage; // 0x4f0	
	float m_distance; // 0x4f4	
	CUtlSymbolLarge m_directionEntityName; // 0x4f8	
};

// Alignment: 21
// Size: 0x7d0
class CRopeKeyframe : public CBaseModelEntity
{
public:
	// MNetworkEnable
	uint16_t m_RopeFlags; // 0x780	
private:
	[[maybe_unused]] uint8_t __pad0782[0x6]; 	// 0x782
public:
	CUtlSymbolLarge m_iNextLinkName; // 0x788	
	// MNetworkEnable
	int16_t m_Slack; // 0x790	
private:
	[[maybe_unused]] uint8_t __pad0792[0x2]; 	// 0x792
public:
	// MNetworkEnable
	float m_Width; // 0x794	
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0.1"
	// MNetworkMaxValue "10"
	float m_TextureScale; // 0x798	
	// MNetworkEnable
	uint8_t m_nSegments; // 0x79c	
	// MNetworkEnable
	bool m_bConstrainBetweenEndpoints; // 0x79d	
private:
	[[maybe_unused]] uint8_t __pad079e[0x2]; 	// 0x79e
public:
	CUtlSymbolLarge m_strRopeMaterialModel; // 0x7a0	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_iRopeMaterialModelIndex; // 0x7a8	
	// MNetworkEnable
	uint8_t m_Subdiv; // 0x7b0	
	// MNetworkEnable
	uint8_t m_nChangeCount; // 0x7b1	
	// MNetworkEnable
	int16_t m_RopeLength; // 0x7b2	
	// MNetworkEnable
	uint8_t m_fLockedPoints; // 0x7b4	
	bool m_bCreatedFromMapFile; // 0x7b5	
private:
	[[maybe_unused]] uint8_t __pad07b6[0x2]; 	// 0x7b6
public:
	// MNetworkEnable
	float m_flScrollSpeed; // 0x7b8	
	bool m_bStartPointValid; // 0x7bc	
	bool m_bEndPointValid; // 0x7bd	
private:
	[[maybe_unused]] uint8_t __pad07be[0x2]; 	// 0x7be
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hStartPoint; // 0x7c0	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hEndPoint; // 0x7c4	
	// MNetworkEnable
	AttachmentHandle_t m_iStartAttachment; // 0x7c8	
	// MNetworkEnable
	AttachmentHandle_t m_iEndAttachment; // 0x7c9	
};

// Alignment: 4
// Size: 0x1f00
class CSoundEnt : public CPointEntity
{
public:
	int32_t m_iFreeSound; // 0x4f0	
	int32_t m_iActiveSound; // 0x4f4	
	int32_t m_cLastActiveSounds; // 0x4f8	
	CSound m_SoundPool[128]; // 0x4fc	
};

// Alignment: 4
// Size: 0x798
class CSpotlightEnd : public CBaseModelEntity
{
public:
	// MNetworkEnable
	float m_flLightScale; // 0x778	
	// MNetworkEnable
	float m_Radius; // 0x77c	
	Vector m_vSpotlightDir; // 0x780	
	Vector m_vSpotlightOrg; // 0x78c	
};

// Alignment: 35
// Size: 0x8b0
class CFuncTrackTrain : public CBaseModelEntity
{
public:
	CHandle< CPathTrack > m_ppath; // 0x778	
	float m_length; // 0x77c	
	Vector m_controlMins; // 0x780	
	Vector m_controlMaxs; // 0x78c	
	Vector m_lastBlockPos; // 0x798	
	int32_t m_lastBlockTick; // 0x7a4	
	float m_flVolume; // 0x7a8	
	float m_flBank; // 0x7ac	
	float m_oldSpeed; // 0x7b0	
	float m_flBlockDamage; // 0x7b4	
	float m_height; // 0x7b8	
	float m_maxSpeed; // 0x7bc	
	float m_dir; // 0x7c0	
private:
	[[maybe_unused]] uint8_t __pad07c4[0x4]; 	// 0x7c4
public:
	CUtlSymbolLarge m_iszSoundMove; // 0x7c8	
	CUtlSymbolLarge m_iszSoundMovePing; // 0x7d0	
	CUtlSymbolLarge m_iszSoundStart; // 0x7d8	
	CUtlSymbolLarge m_iszSoundStop; // 0x7e0	
	CUtlSymbolLarge m_strPathTarget; // 0x7e8	
	float m_flMoveSoundMinDuration; // 0x7f0	
	float m_flMoveSoundMaxDuration; // 0x7f4	
	float m_flNextMoveSoundTime; // 0x7f8	
	float m_flMoveSoundMinPitch; // 0x7fc	
	float m_flMoveSoundMaxPitch; // 0x800	
	TrainOrientationType_t m_eOrientationType; // 0x804	
	TrainVelocityType_t m_eVelocityType; // 0x808	
private:
	[[maybe_unused]] uint8_t __pad080c[0xc]; 	// 0x80c
public:
	CEntityIOOutput m_OnStart; // 0x818	
	CEntityIOOutput m_OnNext; // 0x840	
	CEntityIOOutput m_OnArrivedAtDestinationNode; // 0x868	
	bool m_bManualSpeedChanges; // 0x890	
private:
	[[maybe_unused]] uint8_t __pad0891[0x3]; 	// 0x891
public:
	float m_flDesiredSpeed; // 0x894	
	float m_flSpeedChangeTime; // 0x898	
	float m_flAccelSpeed; // 0x89c	
	float m_flDecelSpeed; // 0x8a0	
	bool m_bAccelToSpeed; // 0x8a4	
private:
	[[maybe_unused]] uint8_t __pad08a5[0x3]; 	// 0x8a5
public:
	float m_flNextMPSoundTime; // 0x8a8	
};

// Alignment: 11
// Size: 0x920
class CBaseTrigger : public CBaseToggle
{
public:
	// MNetworkEnable
	bool m_bDisabled; // 0x7f8	
private:
	[[maybe_unused]] uint8_t __pad07f9[0x7]; 	// 0x7f9
public:
	CUtlSymbolLarge m_iFilterName; // 0x800	
	CHandle< CBaseFilter > m_hFilter; // 0x808	
private:
	[[maybe_unused]] uint8_t __pad080c[0x4]; 	// 0x80c
public:
	CEntityIOOutput m_OnStartTouch; // 0x810	
	CEntityIOOutput m_OnStartTouchAll; // 0x838	
	CEntityIOOutput m_OnEndTouch; // 0x860	
	CEntityIOOutput m_OnEndTouchAll; // 0x888	
	CEntityIOOutput m_OnTouching; // 0x8b0	
	CEntityIOOutput m_OnNotTouching; // 0x8d8	
	CUtlVector< CHandle< CBaseEntity > > m_hTouchingEntities; // 0x900	
	// MNetworkEnable
	bool m_bClientSidePredicted; // 0x918	
};

// Alignment: 1
// Size: 0x948
class CTriggerMultiple : public CBaseTrigger
{
public:
	CEntityIOOutput m_OnTrigger; // 0x920	
};

// Alignment: 15
// Size: 0xc88
class CTriggerSndSosOpvar : public CBaseTrigger
{
public:
	CUtlVector< CHandle< CBaseEntity > > m_hTouchingPlayers; // 0x920	
	Vector m_flPosition; // 0x938	
	float m_flCenterSize; // 0x944	
	float m_flMinVal; // 0x948	
	float m_flMaxVal; // 0x94c	
	float m_flWait; // 0x950	
private:
	[[maybe_unused]] uint8_t __pad0954[0x4]; 	// 0x954
public:
	CUtlSymbolLarge m_opvarName; // 0x958	
	CUtlSymbolLarge m_stackName; // 0x960	
	CUtlSymbolLarge m_operatorName; // 0x968	
	bool m_bVolIs2D; // 0x970	
	char m_opvarNameChar[256]; // 0x971	
	char m_stackNameChar[256]; // 0xa71	
	char m_operatorNameChar[256]; // 0xb71	
private:
	[[maybe_unused]] uint8_t __pad0c71[0x3]; 	// 0xc71
public:
	Vector m_VecNormPos; // 0xc74	
	float m_flNormCenterSize; // 0xc80	
};

// Alignment: 14
// Size: 0x9c0
class CTriggerHurt : public CBaseTrigger
{
public:
	float m_flOriginalDamage; // 0x920	
	float m_flDamage; // 0x924	
	float m_flDamageCap; // 0x928	
	float m_flLastDmgTime; // 0x92c	
	float m_flForgivenessDelay; // 0x930	
	int32_t m_bitsDamageInflict; // 0x934	
	int32_t m_damageModel; // 0x938	
	bool m_bNoDmgForce; // 0x93c	
private:
	[[maybe_unused]] uint8_t __pad093d[0x3]; 	// 0x93d
public:
	Vector m_vDamageForce; // 0x940	
	bool m_thinkAlways; // 0x94c	
private:
	[[maybe_unused]] uint8_t __pad094d[0x3]; 	// 0x94d
public:
	float m_hurtThinkPeriod; // 0x950	
private:
	[[maybe_unused]] uint8_t __pad0954[0x4]; 	// 0x954
public:
	CEntityIOOutput m_OnHurt; // 0x958	
	CEntityIOOutput m_OnHurtPlayer; // 0x980	
	CUtlVector< CHandle< CBaseEntity > > m_hurtEntities; // 0x9a8	
};

// Alignment: 0
// Size: 0x9c0
class CTriggerHurtGhost : public CTriggerHurt
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x928
class CTriggerCallback : public CBaseTrigger
{
public:
	// @note: no members available
};

// Alignment: 12
// Size: 0x9c0
class CTriggerLerpObject : public CBaseTrigger
{
public:
	CUtlSymbolLarge m_iszLerpTarget; // 0x920	
	CHandle< CBaseEntity > m_hLerpTarget; // 0x928	
private:
	[[maybe_unused]] uint8_t __pad092c[0x4]; 	// 0x92c
public:
	CUtlSymbolLarge m_iszLerpTargetAttachment; // 0x930	
	AttachmentHandle_t m_hLerpTargetAttachment; // 0x938	
private:
	[[maybe_unused]] uint8_t __pad0939[0x3]; 	// 0x939
public:
	float m_flLerpDuration; // 0x93c	
	bool m_bLerpRestoreMoveType; // 0x940	
	bool m_bSingleLerpObject; // 0x941	
private:
	[[maybe_unused]] uint8_t __pad0942[0x6]; 	// 0x942
public:
	CUtlVector< lerpdata_t > m_vecLerpingObjects; // 0x948	
	CUtlSymbolLarge m_iszLerpEffect; // 0x960	
	CUtlSymbolLarge m_iszLerpSound; // 0x968	
	CEntityIOOutput m_OnLerpStarted; // 0x970	
	CEntityIOOutput m_OnLerpFinished; // 0x998	
};

// Alignment: 7
// Size: 0x960
class CChangeLevel : public CBaseTrigger
{
public:
	CUtlString m_sMapName; // 0x920	
	CUtlString m_sLandmarkName; // 0x928	
	CEntityIOOutput m_OnChangeLevel; // 0x930	
	bool m_bTouched; // 0x958	
	bool m_bNoTouch; // 0x959	
	bool m_bNewChapter; // 0x95a	
	bool m_bOnChangeLevelFired; // 0x95b	
};

// Alignment: 3
// Size: 0x930
class CTriggerTeleport : public CBaseTrigger
{
public:
	CUtlSymbolLarge m_iLandmark; // 0x920	
	bool m_bUseLandmarkAngles; // 0x928	
	bool m_bMirrorPlayer; // 0x929	
};

// Alignment: 3
// Size: 0x930
class CTriggerAddModifier : public CBaseTrigger
{
public:
	CUtlSymbolLarge m_strModifier; // 0x920	
	float m_flDuration; // 0x928	
	bool m_bMomentary; // 0x92c	
};

// Alignment: 1
// Size: 0x928
class CTriggerRemoveModifier : public CBaseTrigger
{
public:
	CUtlSymbolLarge m_strModifier; // 0x920	
};

// Alignment: 6
// Size: 0x958
class CTriggerFan : public CBaseTrigger
{
public:
	Vector m_vFanOrigin; // 0x920	
	Vector m_vFanEnd; // 0x92c	
	float m_flForce; // 0x938	
	float m_flRampTime; // 0x93c	
	bool m_bFalloff; // 0x940	
private:
	[[maybe_unused]] uint8_t __pad0941[0x7]; 	// 0x941
public:
	CountdownTimer m_RampTimer; // 0x948	
};

// Alignment: 2
// Size: 0x948
class CTriggerBuoyancy : public CBaseTrigger
{
public:
	CBuoyancyHelper m_BuoyancyHelper; // 0x920	
	// MNetworkEnable
	float m_flFluidDensity; // 0x940	
};

// Alignment: 1
// Size: 0x2d0
class CFourWheelServerVehicle : public CBaseServerVehicle
{
public:
	ViewSmoothingData_t m_ViewSmoothing; // 0x250	
};

// Alignment: 2
// Size: 0x788
class CFuncNavBlocker : public CBaseModelEntity
{
public:
	bool m_bDisabled; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0779[0x3]; 	// 0x779
public:
	int32_t m_nBlockedTeamNumber; // 0x77c	
};

// Alignment: 10
// Size: 0x5a0
class CNavLinkEntity : public CPointEntity
{
public:
	CUtlSymbolLarge m_typeName; // 0x4f0	
	CUtlSymbolLarge m_typeNameReverse; // 0x4f8	
	int32_t m_nNavLinkId; // 0x500	
	int32_t m_nNavLinkIdReverse; // 0x504	
	bool m_bUseEntityOrientation; // 0x508	
	bool m_bEnabled; // 0x509	
private:
	[[maybe_unused]] uint8_t __pad050a[0x6]; 	// 0x50a
public:
	CUtlVectorFixedGrowable< CHandle< CAI_BaseNPC > > m_vecNpcUsers; // 0x510	
	Vector m_vEndpointLocal; // 0x540	
private:
	[[maybe_unused]] uint8_t __pad054c[0x4]; 	// 0x54c
public:
	CEntityIOOutput m_OnNavLinkStart; // 0x550	
	CEntityIOOutput m_OnNavLinkFinish; // 0x578	
};

// Alignment: 24
// Size: 0x818
class CBeam : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "-25"
	// MNetworkMaxValue "25"
	// MNetworkEncodeFlags
	float m_flFrameRate; // 0x778	
	// MNetworkEnable
	float m_flHDRColorScale; // 0x77c	
	float m_flFireTime; // 0x780	
	float m_flDamage; // 0x784	
	// MNetworkEnable
	uint8_t m_nNumBeamEnts; // 0x788	
private:
	[[maybe_unused]] uint8_t __pad0789[0x7]; 	// 0x789
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hBaseMaterial; // 0x790	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_nHaloIndex; // 0x798	
	// MNetworkEnable
	BeamType_t m_nBeamType; // 0x7a0	
	// MNetworkEnable
	uint32_t m_nBeamFlags; // 0x7a4	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hAttachEntity[10]; // 0x7a8	
	// MNetworkEnable
	AttachmentHandle_t m_nAttachIndex[10]; // 0x7d0	
private:
	[[maybe_unused]] uint8_t __pad07da[0x2]; 	// 0x7da
public:
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "102.3"
	// MNetworkEncodeFlags
	float m_fWidth; // 0x7dc	
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "102.3"
	// MNetworkEncodeFlags
	float m_fEndWidth; // 0x7e0	
	// MNetworkEnable
	float m_fFadeLength; // 0x7e4	
	// MNetworkEnable
	float m_fHaloScale; // 0x7e8	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "64"
	// MNetworkEncodeFlags
	float m_fAmplitude; // 0x7ec	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "256"
	// MNetworkEncodeFlags
	float m_fStartFrame; // 0x7f0	
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "100"
	float m_fSpeed; // 0x7f4	
	// MNetworkEnable
	// MNetworkBitCount "20"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "256"
	// MNetworkEncodeFlags
	// MNetworkPriority "32"
	float m_flFrame; // 0x7f8	
	// MNetworkEnable
	BeamClipStyle_t m_nClipStyle; // 0x7fc	
	// MNetworkEnable
	bool m_bTurnedOff; // 0x800	
private:
	[[maybe_unused]] uint8_t __pad0801[0x3]; 	// 0x801
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecEndPos; // 0x804	
	CHandle< CBaseEntity > m_hEndEntity; // 0x810	
	int32_t m_nDissolveType; // 0x814	
};

// Alignment: 12
// Size: 0x828
class CFuncLadder : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecLadderDir; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0784[0x4]; 	// 0x784
public:
	CUtlVector< CHandle< CInfoLadderDismount > > m_Dismounts; // 0x788	
	Vector m_vecLocalTop; // 0x7a0	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecPlayerMountPositionTop; // 0x7ac	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecPlayerMountPositionBottom; // 0x7b8	
	// MNetworkEnable
	float m_flAutoRideSpeed; // 0x7c4	
	bool m_bDisabled; // 0x7c8	
	// MNetworkEnable
	bool m_bFakeLadder; // 0x7c9	
	bool m_bHasSlack; // 0x7ca	
private:
	[[maybe_unused]] uint8_t __pad07cb[0x5]; 	// 0x7cb
public:
	CUtlSymbolLarge m_surfacePropName; // 0x7d0	
	CEntityIOOutput m_OnPlayerGotOnLadder; // 0x7d8	
	CEntityIOOutput m_OnPlayerGotOffLadder; // 0x800	
	static CUtlVector< CFuncLadder* > &Get_s_Ladders(){return *reinterpret_cast<CUtlVector< CFuncLadder* >*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CFuncLadder")->m_static_fields[0]->m_instance);};
};

// Alignment: 32
// Size: 0x8d0
class CFuncShatterglass : public CBaseModelEntity
{
public:
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hGlassMaterialDamaged; // 0x778	
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hGlassMaterialUndamaged; // 0x780	
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hConcreteMaterialEdgeFace; // 0x788	
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hConcreteMaterialEdgeCaps; // 0x790	
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hConcreteMaterialEdgeFins; // 0x798	
	matrix3x4_t m_matPanelTransform; // 0x7a0	
	matrix3x4_t m_matPanelTransformWsTemp; // 0x7d0	
	CUtlVector< uint32 > m_vecShatterGlassShards; // 0x800	
	Vector2D m_PanelSize; // 0x818	
	Vector m_vecPanelNormalWs; // 0x820	
	int32_t m_nNumShardsEverCreated; // 0x82c	
	float m_flLastShatterSoundEmitTime; // 0x830	
	float m_flLastCleanupTime; // 0x834	
	float m_flInitAtTime; // 0x838	
	float m_flGlassThickness; // 0x83c	
	float m_flSpawnInvulnerability; // 0x840	
	bool m_bBreakSilent; // 0x844	
	bool m_bBreakShardless; // 0x845	
	bool m_bBroken; // 0x846	
	bool m_bHasRateLimitedShards; // 0x847	
	bool m_bGlassNavIgnore; // 0x848	
	bool m_bGlassInFrame; // 0x849	
	bool m_bStartBroken; // 0x84a	
	uint8_t m_iInitialDamageType; // 0x84b	
private:
	[[maybe_unused]] uint8_t __pad084c[0x4]; 	// 0x84c
public:
	CUtlSymbolLarge m_szDamagePositioningEntityName01; // 0x850	
	CUtlSymbolLarge m_szDamagePositioningEntityName02; // 0x858	
	CUtlSymbolLarge m_szDamagePositioningEntityName03; // 0x860	
	CUtlSymbolLarge m_szDamagePositioningEntityName04; // 0x868	
	CUtlVector< Vector > m_vInitialDamagePositions; // 0x870	
	CUtlVector< Vector > m_vExtraDamagePositions; // 0x888	
	CEntityIOOutput m_OnBroken; // 0x8a0	
private:
	[[maybe_unused]] uint8_t __pad08c8[0x1]; 	// 0x8c8
public:
	uint8_t m_iSurfaceType; // 0x8c9	
};

// Alignment: 23
// Size: 0x7e8
class CSprite : public CBaseModelEntity
{
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hSpriteMaterial; // 0x778	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hAttachedToEntity; // 0x780	
	// MNetworkEnable
	AttachmentHandle_t m_nAttachment; // 0x784	
private:
	[[maybe_unused]] uint8_t __pad0785[0x3]; 	// 0x785
public:
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "60"
	// MNetworkEncodeFlags
	float m_flSpriteFramerate; // 0x788	
	// MNetworkEnable
	// MNetworkBitCount "20"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "256"
	// MNetworkEncodeFlags
	float m_flFrame; // 0x78c	
	float m_flDieTime; // 0x790	
private:
	[[maybe_unused]] uint8_t __pad0794[0xc]; 	// 0x794
public:
	// MNetworkEnable
	uint32_t m_nBrightness; // 0x7a0	
	// MNetworkEnable
	float m_flBrightnessDuration; // 0x7a4	
	// MNetworkEnable
	// MNetworkChangeCallback "OnSpriteScaleChanged"
	float m_flSpriteScale; // 0x7a8	
	// MNetworkEnable
	float m_flScaleDuration; // 0x7ac	
	// MNetworkEnable
	bool m_bWorldSpaceScale; // 0x7b0	
private:
	[[maybe_unused]] uint8_t __pad07b1[0x3]; 	// 0x7b1
public:
	// MNetworkEnable
	// MNetworkBitCount "6"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "64"
	// MNetworkEncodeFlags
	float m_flGlowProxySize; // 0x7b4	
	// MNetworkEnable
	float m_flHDRColorScale; // 0x7b8	
	float m_flLastTime; // 0x7bc	
	float m_flMaxFrame; // 0x7c0	
	float m_flStartScale; // 0x7c4	
	float m_flDestScale; // 0x7c8	
	float m_flScaleTimeStart; // 0x7cc	
	int32_t m_nStartBrightness; // 0x7d0	
	int32_t m_nDestBrightness; // 0x7d4	
	float m_flBrightnessTimeStart; // 0x7d8	
	int32_t m_nSpriteWidth; // 0x7dc	
	int32_t m_nSpriteHeight; // 0x7e0	
};

// Alignment: 0
// Size: 0x7e8
class CSpriteOriented : public CSprite
{
public:
	// @note: no members available
};

// Alignment: 14
// Size: 0x928
class CBaseClientUIEntity : public CBaseModelEntity
{
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0779[0x7]; 	// 0x779
public:
	// MNetworkEnable
	CUtlSymbolLarge m_DialogXMLName; // 0x780	
	// MNetworkEnable
	CUtlSymbolLarge m_PanelClassName; // 0x788	
	// MNetworkEnable
	CUtlSymbolLarge m_PanelID; // 0x790	
	CEntityIOOutput m_CustomOutput0; // 0x798	
	CEntityIOOutput m_CustomOutput1; // 0x7c0	
	CEntityIOOutput m_CustomOutput2; // 0x7e8	
	CEntityIOOutput m_CustomOutput3; // 0x810	
	CEntityIOOutput m_CustomOutput4; // 0x838	
	CEntityIOOutput m_CustomOutput5; // 0x860	
	CEntityIOOutput m_CustomOutput6; // 0x888	
	CEntityIOOutput m_CustomOutput7; // 0x8b0	
	CEntityIOOutput m_CustomOutput8; // 0x8d8	
	CEntityIOOutput m_CustomOutput9; // 0x900	
};

// Alignment: 2
// Size: 0x930
class CPointClientUIDialog : public CBaseClientUIEntity
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnDialogActivatorChanged"
	CHandle< CBaseEntity > m_hActivator; // 0x928	
	bool m_bStartEnabled; // 0x92c	
};

// Alignment: 23
// Size: 0x980
class CPointClientUIWorldPanel : public CBaseClientUIEntity
{
public:
	// MNetworkEnable
	bool m_bIgnoreInput; // 0x928	
	// MNetworkEnable
	bool m_bLit; // 0x929	
	// MNetworkEnable
	bool m_bFollowPlayerAcrossTeleport; // 0x92a	
private:
	[[maybe_unused]] uint8_t __pad092b[0x1]; 	// 0x92b
public:
	// MNetworkEnable
	float m_flWidth; // 0x92c	
	// MNetworkEnable
	float m_flHeight; // 0x930	
	// MNetworkEnable
	float m_flDPI; // 0x934	
	// MNetworkEnable
	float m_flInteractDistance; // 0x938	
	// MNetworkEnable
	float m_flDepthOffset; // 0x93c	
	// MNetworkEnable
	uint32_t m_unOwnerContext; // 0x940	
	// MNetworkEnable
	uint32_t m_unHorizontalAlign; // 0x944	
	// MNetworkEnable
	uint32_t m_unVerticalAlign; // 0x948	
	// MNetworkEnable
	uint32_t m_unOrientation; // 0x94c	
	// MNetworkEnable
	bool m_bAllowInteractionFromAllSceneWorlds; // 0x950	
private:
	[[maybe_unused]] uint8_t __pad0951[0x7]; 	// 0x951
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CUtlSymbolLarge > m_vecCSSClasses; // 0x958	
	// MNetworkEnable
	bool m_bOpaque; // 0x970	
	// MNetworkEnable
	bool m_bNoDepth; // 0x971	
	// MNetworkEnable
	bool m_bRenderBackface; // 0x972	
	// MNetworkEnable
	bool m_bUseOffScreenIndicator; // 0x973	
	// MNetworkEnable
	bool m_bExcludeFromSaveGames; // 0x974	
	// MNetworkEnable
	bool m_bGrabbable; // 0x975	
	// MNetworkEnable
	bool m_bOnlyRenderToTexture; // 0x976	
	// MNetworkEnable
	bool m_bDisableMipGen; // 0x977	
	// MNetworkEnable
	int32_t m_nExplicitImageLayout; // 0x978	
};

// Alignment: 1
// Size: 0xb80
class CPointClientUIWorldTextPanel : public CPointClientUIWorldPanel
{
public:
	// MNetworkEnable
	char m_messageText[512]; // 0x980	
};

// Alignment: 0
// Size: 0x988
class CPointHintUi : public CPointClientUIWorldPanel
{
public:
	// @note: no members available
};

// Alignment: 10
// Size: 0x568
class CInfoOffscreenPanoramaTexture : public CPointEntity
{
public:
	// MNetworkEnable
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	// MNetworkEnable
	int32_t m_nResolutionX; // 0x4f4	
	// MNetworkEnable
	int32_t m_nResolutionY; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04fc[0x4]; 	// 0x4fc
public:
	// MNetworkEnable
	CUtlSymbolLarge m_szLayoutFileName; // 0x500	
	// MNetworkEnable
	CUtlSymbolLarge m_RenderAttrName; // 0x508	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseModelEntity > > m_TargetEntities; // 0x510	
	// MNetworkEnable
	int32_t m_nTargetChangeCount; // 0x528	
private:
	[[maybe_unused]] uint8_t __pad052c[0x4]; 	// 0x52c
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CUtlSymbolLarge > m_vecCSSClasses; // 0x530	
	CUtlSymbolLarge m_szTargetsName; // 0x548	
	CUtlVector< CHandle< CBaseModelEntity > > m_AdditionalTargetEntities; // 0x550	
};

// Alignment: 0
// Size: 0x548
class CNodeEnt_InfoHint : public CNodeEnt
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x548
class CNodeEnt_InfoNodeHint : public CNodeEnt
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x548
class CNodeEnt_InfoNodeAir : public CNodeEnt
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x548
class CNodeEnt_InfoNodeAirHint : public CNodeEnt
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x548
class CNodeEnt_InfoNodeClimb : public CNodeEnt
{
public:
	// @note: no members available
};

// Alignment: 5
// Size: 0x508
class CAI_LookTarget : public CPointEntity
{
public:
	int32_t m_iContext; // 0x4f0	
	int32_t m_iPriority; // 0x4f4	
	bool m_bDisabled; // 0x4f8	
private:
	[[maybe_unused]] uint8_t __pad04f9[0x3]; 	// 0x4f9
public:
	float m_flTimeNextAvailable; // 0x4fc	
	float m_flMaxDist; // 0x500	
};

// Alignment: 0
// Size: 0x4f0
class CAI_NetworkManager : public CPointEntity
{
public:
	static CUtlVector< uint32 > &Get_m_SpawnGroupsContributingToNodeList(){return *reinterpret_cast<CUtlVector< uint32 >*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_NetworkManager")->m_static_fields[0]->m_instance);};
	static CUtlVector< CNodeEnt* > &Get_m_SpawningNodes(){return *reinterpret_cast<CUtlVector< CNodeEnt* >*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_NetworkManager")->m_static_fields[1]->m_instance);};
	// @note: no members available
};

// Alignment: 1
// Size: 0x980
class CNpcFootSweep : public CBaseTrigger
{
public:
	bool m_bUseCenterPusher; // 0x920	
};

// Alignment: 2
// Size: 0x500
class CInfoRemarkable : public CPointEntity
{
public:
	int32_t m_iTimesRemarkedUpon; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_szRemarkContext; // 0x4f8	
};

// Alignment: 4
// Size: 0x530
class CNPCSpawnDestination : public CPointEntity
{
public:
	float m_ReuseDelay; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f4[0x4]; 	// 0x4f4
public:
	CUtlSymbolLarge m_RenameNPC; // 0x4f8	
	float m_TimeNextAvailable; // 0x500	
private:
	[[maybe_unused]] uint8_t __pad0504[0x4]; 	// 0x504
public:
	CEntityIOOutput m_OnSpawnNPC; // 0x508	
};

// Alignment: 11
// Size: 0x548
class CRallyPoint : public CPointEntity
{
public:
	CUtlSymbolLarge m_AssaultPointName; // 0x4f0	
	CUtlSymbolLarge m_RallySequenceName; // 0x4f8	
	float m_flAssaultDelay; // 0x500	
	int32_t m_iPriority; // 0x504	
	int32_t m_iStrictness; // 0x508	
	bool m_bForceCrouch; // 0x50c	
	bool m_bIsUrgent; // 0x50d	
	int16_t m_sExclusivity; // 0x50e	
	bool m_bShouldLock; // 0x510	
private:
	[[maybe_unused]] uint8_t __pad0511[0x7]; 	// 0x511
public:
	CEntityIOOutput m_OnArrival; // 0x518	
	CHandle< CBaseEntity > m_hLockedBy; // 0x540	
};

// Alignment: 15
// Size: 0x570
class CAssaultPoint : public CPointEntity
{
public:
	CUtlSymbolLarge m_AssaultHintGroup; // 0x4f0	
	CUtlSymbolLarge m_NextAssaultPointName; // 0x4f8	
	CEntityIOOutput m_OnAssaultClear; // 0x500	
	float m_flAssaultTimeout; // 0x528	
	bool m_bClearOnContact; // 0x52c	
	bool m_bAllowDiversion; // 0x52d	
private:
	[[maybe_unused]] uint8_t __pad052e[0x2]; 	// 0x52e
public:
	float m_flAllowDiversionRadius; // 0x530	
	bool m_bNeverTimeout; // 0x534	
private:
	[[maybe_unused]] uint8_t __pad0535[0x3]; 	// 0x535
public:
	int32_t m_iStrictness; // 0x538	
	bool m_bForceCrouch; // 0x53c	
	bool m_bIsUrgent; // 0x53d	
	bool m_bInputForcedClear; // 0x53e	
private:
	[[maybe_unused]] uint8_t __pad053f[0x1]; 	// 0x53f
public:
	float m_flAssaultPointTolerance; // 0x540	
	float m_flTimeLastUsed; // 0x544	
	CEntityIOOutput m_OnArrival; // 0x548	
};

// Alignment: 34
// Size: 0x588
class COffscreenParticleTexture : public CPointEntity
{
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	// MNetworkEnable
	float m_flRawInputA; // 0x4f4	
	// MNetworkEnable
	float m_flRawInputB; // 0x4f8	
	// MNetworkEnable
	float m_flRawInputC; // 0x4fc	
	// MNetworkEnable
	float m_flRawInputD; // 0x500	
	// MNetworkEnable
	float m_flCPValueA; // 0x504	
	// MNetworkEnable
	float m_flCPValueB; // 0x508	
	// MNetworkEnable
	float m_flCPValueC; // 0x50c	
	// MNetworkEnable
	float m_flCPValueD; // 0x510	
	// MNetworkEnable
	int32_t m_nRemapFuncA; // 0x514	
	// MNetworkEnable
	float m_flRemapAParamS; // 0x518	
	// MNetworkEnable
	float m_flRemapAParamT; // 0x51c	
	// MNetworkEnable
	int32_t m_nRemapFuncB; // 0x520	
	// MNetworkEnable
	float m_flRemapBParamS; // 0x524	
	// MNetworkEnable
	float m_flRemapBParamT; // 0x528	
	// MNetworkEnable
	int32_t m_nRemapFuncC; // 0x52c	
	// MNetworkEnable
	float m_flRemapCParamS; // 0x530	
	// MNetworkEnable
	float m_flRemapCParamT; // 0x534	
	// MNetworkEnable
	int32_t m_nRemapFuncD; // 0x538	
	// MNetworkEnable
	float m_flRemapDParamS; // 0x53c	
	// MNetworkEnable
	float m_flRemapDParamT; // 0x540	
	// MNetworkEnable
	int32_t m_nControlPointA; // 0x544	
	// MNetworkEnable
	int32_t m_nControlPointB; // 0x548	
	// MNetworkEnable
	int32_t m_nControlPointC; // 0x54c	
	// MNetworkEnable
	int32_t m_nControlPointD; // 0x550	
	// MNetworkEnable
	int32_t m_nResolution; // 0x554	
	// MNetworkEnable
	Color m_clearColor; // 0x558	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hTargetEntity; // 0x55c	
	// MNetworkEnable
	CUtlSymbolLarge m_szEffectName; // 0x560	
	// MNetworkEnable
	CUtlSymbolLarge m_szMaterialParameterName; // 0x568	
	float m_flVisibleRangeCheck; // 0x570	
	bool m_bStartDisabled; // 0x574	
private:
	[[maybe_unused]] uint8_t __pad0575[0x3]; 	// 0x575
public:
	CUtlSymbolLarge m_szTargetEntityName; // 0x578	
	// MNetworkEnable
	bool m_bPlayerInRange; // 0x580	
};

// Alignment: 49
// Size: 0x980
class CBarnLight : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	bool m_bEnabled; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0779[0x3]; 	// 0x779
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nColorMode; // 0x77c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	Color m_Color; // 0x780	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flColorTemperature; // 0x784	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flBrightness; // 0x788	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flBrightnessScale; // 0x78c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nDirectLight; // 0x790	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nBakedShadowIndex; // 0x794	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nLuminaireShape; // 0x798	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flLuminaireSize; // 0x79c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flLuminaireAnisotropy; // 0x7a0	
private:
	[[maybe_unused]] uint8_t __pad07a4[0x4]; 	// 0x7a4
public:
	// MNetworkEnable
	// MNetworkChangeCallback "StyleChanged"
	CUtlString m_LightStyleString; // 0x7a8	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flLightStyleStartTime; // 0x7b0	
private:
	[[maybe_unused]] uint8_t __pad07b4[0x4]; 	// 0x7b4
public:
	// MNetworkEnable
	CNetworkUtlVectorBase< CUtlString > m_QueuedLightStyleStrings; // 0x7b8	
	// MNetworkEnable
	CNetworkUtlVectorBase< CHandle< CBaseModelEntity > > m_LightStyleTargets; // 0x7d0	
	CEntityIOOutput m_StyleEvent[4]; // 0x7e8	
	CUtlString m_StyleRadianceVar; // 0x888	
	CUtlString m_StyleVar; // 0x890	
private:
	[[maybe_unused]] uint8_t __pad0898[0x20]; 	// 0x898
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hLightCookie; // 0x8b8	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flShape; // 0x8c0	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flSoftX; // 0x8c4	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flSoftY; // 0x8c8	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flSkirt; // 0x8cc	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flSkirtNear; // 0x8d0	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	// MNetworkBitCount "32"
	Vector m_vSizeParams; // 0x8d4	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	// MNetworkBitCount "32"
	float m_flRange; // 0x8e0	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	// MNetworkBitCount "32"
	Vector m_vShear; // 0x8e4	
	// MNetworkEnable
	int32_t m_nBakeSpecularToCubemaps; // 0x8f0	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	// MNetworkBitCount "32"
	Vector m_vBakeSpecularToCubemapsSize; // 0x8f4	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nCastShadows; // 0x900	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nShadowMapSize; // 0x904	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nShadowPriority; // 0x908	
	// MNetworkEnable
	int32_t m_nBounceLight; // 0x90c	
	// MNetworkEnable
	float m_flBounceScale; // 0x910	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nFog; // 0x914	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flFogStrength; // 0x918	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	int32_t m_nFogShadows; // 0x91c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flFogScale; // 0x920	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flFadeSizeStart; // 0x924	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flFadeSizeEnd; // 0x928	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flShadowFadeSizeStart; // 0x92c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flShadowFadeSizeEnd; // 0x930	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	bool m_bPrecomputedFieldsValid; // 0x934	
private:
	[[maybe_unused]] uint8_t __pad0935[0x3]; 	// 0x935
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	Vector m_vPrecomputedBoundsMins; // 0x938	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	Vector m_vPrecomputedBoundsMaxs; // 0x944	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	Vector m_vPrecomputedOBBOrigin; // 0x950	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	QAngle m_vPrecomputedOBBAngles; // 0x95c	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	Vector m_vPrecomputedOBBExtent; // 0x968	
	bool m_bPvsModifyEntity; // 0x974	
};

// Alignment: 1
// Size: 0x988
class CRectLight : public CBarnLight
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	bool m_bShowLight; // 0x980	
};

// Alignment: 3
// Size: 0x990
class COmniLight : public CBarnLight
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flInnerAngle; // 0x980	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	float m_flOuterAngle; // 0x984	
	// MNetworkEnable
	// MNetworkChangeCallback "RenderingChanged"
	bool m_bShowLight; // 0x988	
};

// Alignment: 12
// Size: 0x5e0
class CSteamPalConveyorPathNode : public CPointEntity
{
public:
	float m_flNodeT; // 0x514	
	float m_flPathSegmentLength; // 0x518	
	float m_flPathLengthUpToNode; // 0x51c	
	bool m_bStartNewConveyorSection; // 0x520	
	bool m_bSendPassOutputs; // 0x521	
private:
	[[maybe_unused]] uint8_t __pad0522[0x6]; 	// 0x522
public:
	CEntityOutputTemplate< int32 > m_OnPass; // 0x528	
	CEntityOutputTemplate< int32 > m_OnPassForward; // 0x550	
	CEntityOutputTemplate< int32 > m_OnPassBackward; // 0x578	
private:
	[[maybe_unused]] uint8_t __pad05a0[0x18]; 	// 0x5a0
public:
	CUtlSymbolLarge m_szParentPathUniqueID; // 0x5b8	
	int32_t m_nPathIndex; // 0x5c0	
	Vector m_vInTangentLocal; // 0x5c4	
	Vector m_vOutTangentLocal; // 0x5d0	
};

// Alignment: 1
// Size: 0x780
class CSteamPal_PictureCard : public CBaseModelEntity
{
public:
	// MNetworkEnable
	bool m_bShouldSetPicture; // 0x778	
};

// Alignment: 1
// Size: 0x928
class CSteamPal_PaintPowerTrigger : public CBaseTrigger
{
public:
	SteamPalPaintType m_PaintType; // 0x920	
};

// Alignment: 1
// Size: 0x928
class CSteamPal_PropPaintTrigger : public CBaseTrigger
{
public:
	SteamPalPaintType m_PaintType; // 0x920	
};

// Alignment: 5
// Size: 0x970
class CInfoOffscreenMovieTexture : public CInfoOffscreenPanoramaTexture
{
public:
	// MNetworkEnable
	char m_MovieName[512]; // 0x568	
	// MNetworkEnable
	char m_OverrideSoundEvent[512]; // 0x768	
	// MNetworkEnable
	bool m_bRepeat; // 0x968	
	// MNetworkEnable
	bool m_bPlaying; // 0x969	
private:
	[[maybe_unused]] uint8_t __pad096a[0x2]; 	// 0x96a
public:
	// MNetworkEnable
	float m_flVisibleRangeCheck; // 0x96c	
};

// Alignment: 5
// Size: 0x7a0
class CFogVolume : public CServerOnlyModelEntity
{
public:
	CUtlSymbolLarge m_fogName; // 0x778	
	CUtlSymbolLarge m_postProcessName; // 0x780	
	CUtlSymbolLarge m_colorCorrectionName; // 0x788	
private:
	[[maybe_unused]] uint8_t __pad0790[0x8]; 	// 0x790
public:
	bool m_bDisabled; // 0x798	
	bool m_bInFogVolumesList; // 0x799	
};

// Alignment: 5
// Size: 0x508
class CInfoDynamicShadowHint : public CPointEntity
{
public:
	bool m_bDisabled; // 0x4f0	
private:
	[[maybe_unused]] uint8_t __pad04f1[0x3]; 	// 0x4f1
public:
	float m_flRange; // 0x4f4	
	int32_t m_nImportance; // 0x4f8	
	int32_t m_nLightChoice; // 0x4fc	
	CHandle< CBaseEntity > m_hLight; // 0x500	
	static CUtlVector< CInfoDynamicShadowHint* > &Get_m_AllHints(){return *reinterpret_cast<CUtlVector< CInfoDynamicShadowHint* >*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CInfoDynamicShadowHint")->m_static_fields[0]->m_instance);};
};

// Alignment: 2
// Size: 0x520
class CInfoDynamicShadowHintBox : public CInfoDynamicShadowHint
{
public:
	Vector m_vBoxMins; // 0x508	
	Vector m_vBoxMaxs; // 0x514	
};

// Alignment: 9
// Size: 0x7c0
class CEnvSky : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_hSkyMaterial; // 0x778	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	bool m_bStartDisabled; // 0x780	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	Color m_vTintColor; // 0x781	
private:
	[[maybe_unused]] uint8_t __pad0785[0x3]; 	// 0x785
public:
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	int32_t m_nFogType; // 0x788	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	float m_flFogMinStart; // 0x78c	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	float m_flFogMinEnd; // 0x790	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	float m_flFogMaxStart; // 0x794	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	float m_flFogMaxEnd; // 0x798	
	// MNetworkEnable
	// MNetworkChangeCallback "SkyStateChanged"
	bool m_bEnabled; // 0x79c	
};

// Alignment: 0
// Size: 0x518
class CTonemapController2Alias_env_tonemap_controller2 : public CTonemapController2
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x930
class CTonemapTrigger : public CBaseTrigger
{
public:
	CUtlSymbolLarge m_tonemapControllerName; // 0x920	
	CEntityHandle m_hTonemapController; // 0x928	
};

// Alignment: 1
// Size: 0x988
class CFogTrigger : public CBaseTrigger
{
public:
	fogparams_t m_fog; // 0x920	
};

// Alignment: 1
// Size: 0x780
class CLightEntity : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "CLightComponent"
	// MNetworkAlias "CLightComponent"
	// MNetworkTypeAlias "CLightComponent"
	CLightComponent* m_CLightComponent; // 0x778	
};

// Alignment: 0
// Size: 0x780
class CLightSpotEntity : public CLightEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x780
class CLightOrthoEntity : public CLightEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x780
class CLightDirectionalEntity : public CLightEntity
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x780
class CLightEnvironmentEntity : public CLightDirectionalEntity
{
public:
	// @note: no members available
};

// Alignment: 12
// Size: 0x960
class CPostProcessingVolume : public CBaseTrigger
{
public:
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCPostProcessingResource > m_hPostSettings; // 0x930	
	// MNetworkEnable
	float m_flFadeDuration; // 0x938	
	// MNetworkEnable
	float m_flMinLogExposure; // 0x93c	
	// MNetworkEnable
	float m_flMaxLogExposure; // 0x940	
	// MNetworkEnable
	float m_flMinExposure; // 0x944	
	// MNetworkEnable
	float m_flMaxExposure; // 0x948	
	// MNetworkEnable
	float m_flExposureCompensation; // 0x94c	
	// MNetworkEnable
	float m_flExposureFadeSpeedUp; // 0x950	
	// MNetworkEnable
	float m_flExposureFadeSpeedDown; // 0x954	
	// MNetworkEnable
	float m_flTonemapEVSmoothingRange; // 0x958	
	// MNetworkEnable
	bool m_bMaster; // 0x95c	
	// MNetworkEnable
	bool m_bExposureControl; // 0x95d	
};

// Alignment: 5
// Size: 0xcf0
class CEnvParticleGlow : public CParticleSystem
{
public:
	// MNetworkEnable
	float m_flAlphaScale; // 0xcd8	
	// MNetworkEnable
	float m_flRadiusScale; // 0xcdc	
	// MNetworkEnable
	float m_flSelfIllumScale; // 0xce0	
	// MNetworkEnable
	Color m_ColorTint; // 0xce4	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hTextureOverride; // 0xce8	
};

// Alignment: 8
// Size: 0x7b0
class CTextureBasedAnimatable : public CBaseModelEntity
{
public:
	// MNetworkEnable
	bool m_bLoop; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0779[0x3]; 	// 0x779
public:
	// MNetworkEnable
	float m_flFPS; // 0x77c	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hPositionKeys; // 0x780	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCTextureBase > m_hRotationKeys; // 0x788	
	// MNetworkEnable
	Vector m_vAnimationBoundsMin; // 0x790	
	// MNetworkEnable
	Vector m_vAnimationBoundsMax; // 0x79c	
	// MNetworkEnable
	float m_flStartTime; // 0x7a8	
	// MNetworkEnable
	float m_flStartFrame; // 0x7ac	
};

// Alignment: 0
// Size: 0x778
class CWorld : public CBaseModelEntity
{
public:
	// @note: no members available
};

// Alignment: 14
// Size: 0x958
class CBaseAnimating : public CBaseModelEntity
{
public:
	// MNetworkEnable
	// MNetworkUserGroup "CHitboxComponent"
	// MNetworkAlias "CHitboxComponent"
	// MNetworkTypeAlias "CHitboxComponent"
	CHitboxComponent m_CHitboxComponent; // 0x778	
private:
	[[maybe_unused]] uint8_t __pad0798[0x8]; 	// 0x798
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnRagdollPoseChanged"
	PhysicsRagdollPose_t* m_pRagdollPose; // 0x7a0	
	// MNetworkEnable
	Vector m_vecForce; // 0x7a8	
	// MNetworkEnable
	int32_t m_nForceBone; // 0x7b4	
	// MNetworkEnable
	bool m_bShouldAnimateDuringGameplayPause; // 0x7b8	
	// MNetworkEnable
	bool m_bAnimGraphUpdateEnabled; // 0x7b9	
private:
	[[maybe_unused]] uint8_t __pad07ba[0x2]; 	// 0x7ba
public:
	float m_flMaxSlopeDistance; // 0x7bc	
	Vector m_vLastSlopeCheckPos; // 0x7c0	
private:
	[[maybe_unused]] uint8_t __pad07cc[0x4]; 	// 0x7cc
public:
	IChoreoServices* m_pChoreoServices; // 0x7d0	
	bool m_bAnimGraphDirty; // 0x7d8	
private:
	[[maybe_unused]] uint8_t __pad07d9[0x3]; 	// 0x7d9
public:
	float m_flDissolveStartTime; // 0x7dc	
	CEntityIOOutput m_OnIgnite; // 0x7e0	
	CUtlVector< CUtlString >* m_pSuppressedAnimEventTags; // 0x808	
private:
	[[maybe_unused]] uint8_t __pad0810[0x110]; 	// 0x810
public:
	// MNetworkEnable
	CBaseAnimatingEasings_t m_Easings; // 0x920	
};

// Alignment: 0
// Size: 0x958
class CBaseAnimatingOverlay : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x998
class CBaseProp : public CBaseAnimating
{
public:
	bool m_bModelOverrodeBlockLOS; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	int32_t m_iShapeType; // 0x95c	
	bool m_bConformToCollisionBounds; // 0x960	
private:
	[[maybe_unused]] uint8_t __pad0961[0x3]; 	// 0x961
public:
	matrix3x4_t m_mPreferredCatchTransform; // 0x964	
};

// Alignment: 40
// Size: 0xb90
class CBreakableProp : public CBaseProp
{
public:
	CEntityIOOutput m_OnBreak; // 0x9a8	
	CEntityOutputTemplate< float32 > m_OnHealthChanged; // 0x9d0	
	CEntityIOOutput m_OnTakeDamage; // 0x9f8	
	float m_impactEnergyScale; // 0xa20	
	int32_t m_iMinHealthDmg; // 0xa24	
	QAngle m_preferredCarryAngles; // 0xa28	
	float m_flPressureDelay; // 0xa34	
	CHandle< CBaseEntity > m_hBreaker; // 0xa38	
	PerformanceMode_t m_PerformanceMode; // 0xa3c	
	float m_flDmgModBullet; // 0xa40	
	float m_flDmgModClub; // 0xa44	
	float m_flDmgModExplosive; // 0xa48	
	float m_flDmgModFire; // 0xa4c	
	CUtlSymbolLarge m_iszPhysicsDamageTableName; // 0xa50	
	CUtlSymbolLarge m_iszBasePropData; // 0xa58	
	int32_t m_iInteractions; // 0xa60	
	float m_flPreventDamageBeforeTime; // 0xa64	
	bool m_bHasBreakPiecesOrCommands; // 0xa68	
private:
	[[maybe_unused]] uint8_t __pad0a69[0x3]; 	// 0xa69
public:
	float m_explodeDamage; // 0xa6c	
	float m_explodeRadius; // 0xa70	
private:
	[[maybe_unused]] uint8_t __pad0a74[0x4]; 	// 0xa74
public:
	float m_explosionDelay; // 0xa78	
private:
	[[maybe_unused]] uint8_t __pad0a7c[0x4]; 	// 0xa7c
public:
	CUtlSymbolLarge m_explosionBuildupSound; // 0xa80	
	CUtlSymbolLarge m_explosionCustomEffect; // 0xa88	
	CUtlSymbolLarge m_explosionCustomSound; // 0xa90	
	CHandle< CBasePlayer > m_hPhysicsAttacker; // 0xa98	
	float m_flLastPhysicsInfluenceTime; // 0xa9c	
	bool m_bOriginalBlockLOS; // 0xaa0	
	char m_nPhysgunState; // 0xaa1	
private:
	[[maybe_unused]] uint8_t __pad0aa2[0x6]; 	// 0xaa2
public:
	CEntityIOOutput m_OnPhysCannonDetach; // 0xaa8	
	CEntityIOOutput m_OnPhysCannonAnimatePreStarted; // 0xad0	
	CEntityIOOutput m_OnPhysCannonAnimatePullStarted; // 0xaf8	
	CEntityIOOutput m_OnPhysCannonAnimatePostStarted; // 0xb20	
	CEntityIOOutput m_OnPhysCannonPullAnimFinished; // 0xb48	
	float m_flDefaultFadeScale; // 0xb70	
	CHandle< CBaseEntity > m_hLastAttacker; // 0xb74	
	CHandle< CBaseEntity > m_hFlareEnt; // 0xb78	
	bool m_bUsePuntSound; // 0xb7c	
private:
	[[maybe_unused]] uint8_t __pad0b7d[0x3]; 	// 0xb7d
public:
	CUtlSymbolLarge m_iszPuntSound; // 0xb80	
	// MNetworkEnable
	bool m_noGhostCollision; // 0xb88	
private:
	[[maybe_unused]] uint8_t __pad0b89[0x3]; 	// 0xb89
public:
	// MNetworkEnable
	float m_flClothScale; // 0xb8c	
};

// Alignment: 32
// Size: 0xcb0
class CDynamicProp : public CBreakableProp
{
public:
	CEntityIOOutput m_pOutputAnimBegun; // 0xb90	
	CEntityIOOutput m_pOutputAnimOver; // 0xbb8	
	CEntityIOOutput m_pOutputAnimLoopCycleOver; // 0xbe0	
	CEntityIOOutput m_OnAnimReachedStart; // 0xc08	
	CEntityIOOutput m_OnAnimReachedEnd; // 0xc30	
	CUtlSymbolLarge m_iszDefaultAnim; // 0xc58	
	CUtlSymbolLarge m_iszInitialAnim; // 0xc60	
	HSequence m_hGoalSequence; // 0xc68	
	int32_t m_iTransitionDirection; // 0xc6c	
	bool m_bAnimateOnServer; // 0xc70	
	bool m_bRandomizeCycle; // 0xc71	
	bool m_bHoldAnimation; // 0xc72	
	bool m_bIsHoldingAnimation; // 0xc73	
	bool m_bRandomAnimator; // 0xc74	
private:
	[[maybe_unused]] uint8_t __pad0c75[0x3]; 	// 0xc75
public:
	float m_flNextRandAnim; // 0xc78	
	float m_flMinRandAnimDuration; // 0xc7c	
	float m_flMaxRandAnimDuration; // 0xc80	
	HSequence m_hPendingSequence; // 0xc84	
	bool m_bStartDisabled; // 0xc88	
	bool m_bUpdateAttachedChildren; // 0xc89	
	bool m_bScriptedMovement; // 0xc8a	
	bool m_bFiredStartEndOutput; // 0xc8b	
	// MNetworkEnable
	bool m_bUseHitboxesForRenderBox; // 0xc8c	
	// MNetworkEnable
	bool m_bUseAnimGraph; // 0xc8d	
private:
	[[maybe_unused]] uint8_t __pad0c8e[0xa]; 	// 0xc8e
public:
	bool m_bCreateNavObstacle; // 0xc98	
	bool m_bForceNpcExclude; // 0xc99	
	bool m_bCreateNonSolid; // 0xc9a	
	bool m_bIsOverrideProp; // 0xc9b	
	int32_t m_iInitialGlowState; // 0xc9c	
	int32_t m_nGlowRange; // 0xca0	
	int32_t m_nGlowRangeMin; // 0xca4	
	Color m_glowColor; // 0xca8	
};

// Alignment: 0
// Size: 0xcb0
class CDynamicPropAlias_dynamic_prop : public CDynamicProp
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0xcb0
class CDynamicPropAlias_prop_dynamic_override : public CDynamicProp
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0xcb0
class CDynamicPropAlias_cable_dynamic : public CDynamicProp
{
public:
	// @note: no members available
};

// Alignment: 10
// Size: 0xb48
class CColorCorrectionVolume : public CBaseTrigger
{
public:
	// MNetworkEnable
	bool m_bEnabled; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0921[0x3]; 	// 0x921
public:
	// MNetworkEnable
	float m_MaxWeight; // 0x924	
	// MNetworkEnable
	float m_FadeDuration; // 0x928	
	bool m_bStartDisabled; // 0x92c	
private:
	[[maybe_unused]] uint8_t __pad092d[0x3]; 	// 0x92d
public:
	// MNetworkEnable
	float m_Weight; // 0x930	
	// MNetworkEnable
	char m_lookupFilename[512]; // 0x934	
	float m_LastEnterWeight; // 0xb34	
	float m_LastEnterTime; // 0xb38	
	float m_LastExitWeight; // 0xb3c	
	float m_LastExitTime; // 0xb40	
};

// Alignment: 30
// Size: 0xa50
class CPointCommentaryNode : public CBaseAnimating
{
public:
	CUtlSymbolLarge m_iszPreCommands; // 0x958	
	CUtlSymbolLarge m_iszPostCommands; // 0x960	
	// MNetworkEnable
	CUtlSymbolLarge m_iszCommentaryFile; // 0x968	
	CUtlSymbolLarge m_iszViewTarget; // 0x970	
	CHandle< CBaseEntity > m_hViewTarget; // 0x978	
	CHandle< CBaseEntity > m_hViewTargetAngles; // 0x97c	
	CUtlSymbolLarge m_iszViewPosition; // 0x980	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hViewPosition; // 0x988	
	CHandle< CBaseEntity > m_hViewPositionMover; // 0x98c	
	bool m_bPreventMovement; // 0x990	
	bool m_bUnderCrosshair; // 0x991	
	bool m_bUnstoppable; // 0x992	
private:
	[[maybe_unused]] uint8_t __pad0993[0x1]; 	// 0x993
public:
	float m_flFinishedTime; // 0x994	
	Vector m_vecFinishOrigin; // 0x998	
	QAngle m_vecOriginalAngles; // 0x9a4	
	QAngle m_vecFinishAngles; // 0x9b0	
	bool m_bPreventChangesWhileMoving; // 0x9bc	
	bool m_bDisabled; // 0x9bd	
private:
	[[maybe_unused]] uint8_t __pad09be[0x2]; 	// 0x9be
public:
	Vector m_vecTeleportOrigin; // 0x9c0	
	float m_flAbortedPlaybackAt; // 0x9cc	
	CEntityIOOutput m_pOnCommentaryStarted; // 0x9d0	
	CEntityIOOutput m_pOnCommentaryStopped; // 0x9f8	
	// MNetworkEnable
	bool m_bActive; // 0xa20	
private:
	[[maybe_unused]] uint8_t __pad0a21[0x3]; 	// 0xa21
public:
	// MNetworkEnable
	float m_flStartTime; // 0xa24	
	// MNetworkEnable
	float m_flStartTimeInCommentary; // 0xa28	
private:
	[[maybe_unused]] uint8_t __pad0a2c[0x4]; 	// 0xa2c
public:
	// MNetworkEnable
	CUtlSymbolLarge m_iszTitle; // 0xa30	
	// MNetworkEnable
	CUtlSymbolLarge m_iszSpeakers; // 0xa38	
	// MNetworkEnable
	int32_t m_iNodeNumber; // 0xa40	
	// MNetworkEnable
	int32_t m_iNodeNumberMax; // 0xa44	
	// MNetworkEnable
	bool m_bListenedTo; // 0xa48	
};

// Alignment: 0
// Size: 0x7e8
class CCommentaryViewPosition : public CSprite
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x9f0
class CFuncWater : public CBaseDoor
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x9f8
class CRotDoor : public CBaseDoor
{
public:
	bool m_bSolidBsp; // 0x9f0	
};

// Alignment: 0
// Size: 0x958
class CItemSoda : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x920
class CPrecipitation : public CBaseTrigger
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x968
class CEnvAirStrikeIndoorEffect : public CBaseAnimating
{
public:
	int32_t m_nMode; // 0x958	
	float m_flHeight; // 0x95c	
	float m_flNextStateTime; // 0x960	
	int32_t m_nUserSpecifiedHeight; // 0x964	
};

// Alignment: 5
// Size: 0x980
class CEnvAirStrikeOutdoorEffect : public CBaseAnimating
{
public:
	float m_flNextStateTime; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad095c[0x4]; 	// 0x95c
public:
	CUtlSymbolLarge m_strModelGroup; // 0x960	
	CUtlSymbolLarge m_strSequenceName1; // 0x968	
	CUtlSymbolLarge m_strSequenceName2; // 0x970	
	int32_t m_nMode; // 0x978	
};

// Alignment: 19
// Size: 0x8c0
class CEnvBeam : public CBeam
{
public:
	int32_t m_active; // 0x818	
private:
	[[maybe_unused]] uint8_t __pad081c[0x4]; 	// 0x81c
public:
	CStrongHandle< InfoForResourceTypeIMaterial2 > m_spriteTexture; // 0x820	
	CUtlSymbolLarge m_iszStartEntity; // 0x828	
	CUtlSymbolLarge m_iszEndEntity; // 0x830	
	float m_life; // 0x838	
	float m_boltWidth; // 0x83c	
	float m_noiseAmplitude; // 0x840	
	int32_t m_speed; // 0x844	
	float m_restrike; // 0x848	
private:
	[[maybe_unused]] uint8_t __pad084c[0x4]; 	// 0x84c
public:
	CUtlSymbolLarge m_iszSpriteName; // 0x850	
	int32_t m_frameStart; // 0x858	
	Vector m_vEndPointWorld; // 0x85c	
	Vector m_vEndPointRelative; // 0x868	
	float m_radius; // 0x874	
	Touch_t m_TouchType; // 0x878	
private:
	[[maybe_unused]] uint8_t __pad087c[0x4]; 	// 0x87c
public:
	CUtlSymbolLarge m_iFilterName; // 0x880	
	CHandle< CBaseEntity > m_hFilter; // 0x888	
private:
	[[maybe_unused]] uint8_t __pad088c[0x4]; 	// 0x88c
public:
	CUtlSymbolLarge m_iszDecal; // 0x890	
	CEntityIOOutput m_OnTouchedByEntity; // 0x898	
};

// Alignment: 0
// Size: 0x838
class CPushable : public CBreakable
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x828
class CFuncLadderAlias_func_useableladder : public CFuncLadder
{
public:
	// @note: no members available
};

// Alignment: 9
// Size: 0x7b8
class CFuncMonitor : public CFuncBrush
{
public:
	// MNetworkEnable
	CUtlString m_targetCamera; // 0x798	
	// MNetworkEnable
	int32_t m_nResolutionEnum; // 0x7a0	
	// MNetworkEnable
	bool m_bRenderShadows; // 0x7a4	
	// MNetworkEnable
	bool m_bUseUniqueColorTarget; // 0x7a5	
private:
	[[maybe_unused]] uint8_t __pad07a6[0x2]; 	// 0x7a6
public:
	// MNetworkEnable
	CUtlString m_brushModelName; // 0x7a8	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hTargetCamera; // 0x7b0	
	// MNetworkEnable
	bool m_bEnabled; // 0x7b4	
	// MNetworkEnable
	bool m_bDraw3DSkybox; // 0x7b5	
	bool m_bStartEnabled; // 0x7b6	
};

// Alignment: 0
// Size: 0x8a0
class CFuncMoveLinearAlias_momentary_door : public CFuncMoveLinear
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x8a0
class CFuncWaterAnalog : public CFuncMoveLinear
{
public:
	// @note: no members available
};

// Alignment: 3
// Size: 0x828
class CGunTarget : public CBaseToggle
{
public:
	bool m_on; // 0x7f8	
private:
	[[maybe_unused]] uint8_t __pad07f9[0x3]; 	// 0x7f9
public:
	CHandle< CBaseEntity > m_hTargetEnt; // 0x7fc	
	CEntityIOOutput m_OnDeath; // 0x800	
};

// Alignment: 0
// Size: 0x7b8
class CSimpleMarkupVolumeTagged : public CMarkupVolumeTagged
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x7b8
class CMarkupVolumeTagged_Nav : public CMarkupVolumeTagged
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x7d0
class CMarkupVolumeTagged_NavGame : public CMarkupVolumeWithRef
{
public:
	// @note: no members available
};

// Alignment: 4
// Size: 0x7d0
class CFuncElectrifiedVolume : public CFuncBrush
{
public:
	// MNetworkEnable
	CUtlSymbolLarge m_EffectName; // 0x798	
	CUtlSymbolLarge m_EffectInterpenetrateName; // 0x7a0	
	CUtlSymbolLarge m_EffectZapName; // 0x7a8	
	CUtlSymbolLarge m_iszEffectSource; // 0x7b0	
};

// Alignment: 0
// Size: 0x528
class CPathCornerCrash : public CPathCorner
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x960
class CConstraintAnchor : public CBaseAnimating
{
public:
	float m_massScale; // 0x958	
};

// Alignment: 0
// Size: 0x998
class CSimplePhysicsProp : public CBaseProp
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0xcb8
class COrnamentProp : public CDynamicProp
{
public:
	CUtlSymbolLarge m_initialOwner; // 0xcb0	
};

// Alignment: 0
// Size: 0x7d0
class CRopeKeyframeAlias_move_rope : public CRopeKeyframe
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x990
class CSceneEntityAlias_logic_choreographed_scene : public CSceneEntity
{
public:
	// @note: no members available
};

// Alignment: 6
// Size: 0xaa8
class CInstancedSceneEntity : public CSceneEntity
{
public:
	CHandle< CBaseEntity > m_hOwner; // 0x990	
	bool m_bHadOwner; // 0x994	
private:
	[[maybe_unused]] uint8_t __pad0995[0x3]; 	// 0x995
public:
	float m_flPostSpeakDelay; // 0x998	
	float m_flPreDelay; // 0x99c	
	char m_szInstanceFilename[260]; // 0x9a0	
	bool m_bIsBackground; // 0xaa4	
};

// Alignment: 3
// Size: 0x948
class CTriggerSoundscape : public CBaseTrigger
{
public:
	CHandle< CEnvSoundscapeTriggerable > m_hSoundscape; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0924[0x4]; 	// 0x924
public:
	CUtlSymbolLarge m_SoundscapeName; // 0x928	
	CUtlVector< CHandle< CBasePlayer > > m_spectators; // 0x930	
};

// Alignment: 0
// Size: 0x7e8
class CSpriteAlias_env_glow : public CSprite
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x8d8
class CFuncTankTrain : public CFuncTrackTrain
{
public:
	CEntityIOOutput m_OnDeath; // 0x8b0	
};

// Alignment: 5
// Size: 0x820
class CBasePlatTrain : public CBaseToggle
{
public:
	CUtlSymbolLarge m_NoiseMoving; // 0x7f8	
	CUtlSymbolLarge m_NoiseArrived; // 0x800	
private:
	[[maybe_unused]] uint8_t __pad0808[0x8]; 	// 0x808
public:
	float m_volume; // 0x810	
	float m_flTWidth; // 0x814	
	float m_flTLength; // 0x818	
};

// Alignment: 1
// Size: 0x828
class CFuncPlat : public CBasePlatTrain
{
public:
	CUtlSymbolLarge m_sNoise; // 0x820	
};

// Alignment: 2
// Size: 0x840
class CFuncPlatRot : public CFuncPlat
{
public:
	QAngle m_end; // 0x828	
	QAngle m_start; // 0x834	
};

// Alignment: 6
// Size: 0x840
class CFuncTrain : public CBasePlatTrain
{
public:
	CHandle< CBaseEntity > m_hCurrentTarget; // 0x820	
	bool m_activated; // 0x824	
private:
	[[maybe_unused]] uint8_t __pad0825[0x3]; 	// 0x825
public:
	CHandle< CBaseEntity > m_hEnemy; // 0x828	
	float m_flBlockDamage; // 0x82c	
	float m_flNextBlockTime; // 0x830	
private:
	[[maybe_unused]] uint8_t __pad0834[0x4]; 	// 0x834
public:
	CUtlSymbolLarge m_iszLastTarget; // 0x838	
};

// Alignment: 9
// Size: 0x880
class CFuncTrackChange : public CFuncPlatRot
{
public:
	CPathTrack* m_trackTop; // 0x840	
	CPathTrack* m_trackBottom; // 0x848	
	CFuncTrackTrain* m_train; // 0x850	
	CUtlSymbolLarge m_trackTopName; // 0x858	
	CUtlSymbolLarge m_trackBottomName; // 0x860	
	CUtlSymbolLarge m_trainName; // 0x868	
	TRAIN_CODE m_code; // 0x870	
	int32_t m_targetState; // 0x874	
	int32_t m_use; // 0x878	
};

// Alignment: 0
// Size: 0x880
class CFuncTrackAuto : public CFuncTrackChange
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x948
class CTriggerRemove : public CBaseTrigger
{
public:
	CEntityIOOutput m_OnRemove; // 0x920	
};

// Alignment: 1
// Size: 0x9d0
class CScriptTriggerHurt : public CTriggerHurt
{
public:
	Vector m_vExtent; // 0x9c0	
};

// Alignment: 1
// Size: 0x958
class CScriptTriggerMultiple : public CTriggerMultiple
{
public:
	Vector m_vExtent; // 0x948	
};

// Alignment: 0
// Size: 0x948
class CTriggerOnce : public CTriggerMultiple
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x958
class CScriptTriggerOnce : public CTriggerOnce
{
public:
	Vector m_vExtent; // 0x948	
};

// Alignment: 15
// Size: 0x9e8
class CTriggerLook : public CTriggerOnce
{
public:
	CHandle< CBaseEntity > m_hLookTarget; // 0x948	
	float m_flFieldOfView; // 0x94c	
	float m_flLookTime; // 0x950	
	float m_flLookTimeTotal; // 0x954	
	float m_flLookTimeLast; // 0x958	
	float m_flTimeoutDuration; // 0x95c	
	bool m_bTimeoutFired; // 0x960	
	bool m_bIsLooking; // 0x961	
	bool m_b2DFOV; // 0x962	
	bool m_bUseVelocity; // 0x963	
	CHandle< CBaseEntity > m_hActivator; // 0x964	
	// MNetworkEnable
	bool m_bTestOcclusion; // 0x968	
private:
	[[maybe_unused]] uint8_t __pad0969[0x7]; 	// 0x969
public:
	CEntityIOOutput m_OnTimeout; // 0x970	
	CEntityIOOutput m_OnStartLook; // 0x998	
	CEntityIOOutput m_OnEndLook; // 0x9c0	
};

// Alignment: 5
// Size: 0x948
class CTriggerPush : public CBaseTrigger
{
public:
	QAngle m_angPushEntitySpace; // 0x920	
	Vector m_vecPushDirEntitySpace; // 0x92c	
	bool m_bTriggerOnStartTouch; // 0x938	
private:
	[[maybe_unused]] uint8_t __pad0939[0x3]; 	// 0x939
public:
	float m_flAlternateTicksFix; // 0x93c	
	float m_flPushSpeed; // 0x940	
};

// Alignment: 1
// Size: 0x958
class CScriptTriggerPush : public CTriggerPush
{
public:
	Vector m_vExtent; // 0x948	
};

// Alignment: 1
// Size: 0x928
class CTriggerToggleSave : public CBaseTrigger
{
public:
	bool m_bDisabled; // 0x920	
};

// Alignment: 3
// Size: 0x930
class CTriggerSave : public CBaseTrigger
{
public:
	bool m_bForceNewLevelUnit; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0921[0x3]; 	// 0x921
public:
	float m_fDangerousTimer; // 0x924	
	int32_t m_minHitPoints; // 0x928	
};

// Alignment: 0
// Size: 0x920
class CTriggerGravity : public CBaseTrigger
{
public:
	// @note: no members available
};

// Alignment: 5
// Size: 0x960
class CTriggerProximity : public CBaseTrigger
{
public:
	CHandle< CBaseEntity > m_hMeasureTarget; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0924[0x4]; 	// 0x924
public:
	CUtlSymbolLarge m_iszMeasureTarget; // 0x928	
	float m_fRadius; // 0x930	
	int32_t m_nTouchers; // 0x934	
	CEntityOutputTemplate< float32 > m_NearestEntityDistance; // 0x938	
};

// Alignment: 4
// Size: 0x980
class CTriggerImpact : public CTriggerMultiple
{
public:
	float m_flMagnitude; // 0x948	
	float m_flNoise; // 0x94c	
	float m_flViewkick; // 0x950	
private:
	[[maybe_unused]] uint8_t __pad0954[0x4]; 	// 0x954
public:
	CEntityOutputTemplate< Vector > m_pOutputForce; // 0x958	
};

// Alignment: 0
// Size: 0x920
class CTriggerPlayerMovement : public CBaseTrigger
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x920
class CServerRagdollTrigger : public CBaseTrigger
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0x950
class CTriggerActiveWeaponDetect : public CBaseTrigger
{
public:
	CEntityIOOutput m_OnTouchedActiveWeapon; // 0x920	
	CUtlSymbolLarge m_iszWeaponClassName; // 0x948	
};

// Alignment: 13
// Size: 0x980
class CTriggerPhysics : public CBaseTrigger
{
public:
	float m_gravityScale; // 0x930	
	float m_linearLimit; // 0x934	
	float m_linearDamping; // 0x938	
	float m_angularLimit; // 0x93c	
	float m_angularDamping; // 0x940	
	float m_linearForce; // 0x944	
	float m_flFrequency; // 0x948	
	float m_flDampingRatio; // 0x94c	
	Vector m_vecLinearForcePointAt; // 0x950	
	bool m_bCollapseToForcePoint; // 0x95c	
private:
	[[maybe_unused]] uint8_t __pad095d[0x3]; 	// 0x95d
public:
	Vector m_vecLinearForcePointAtWorld; // 0x960	
	Vector m_vecLinearForceDirection; // 0x96c	
	bool m_bConvertToDebrisWhenPossible; // 0x978	
};

// Alignment: 2
// Size: 0x950
class CTriggerDetectBulletFire : public CBaseTrigger
{
public:
	bool m_bPlayerFireOnly; // 0x920	
private:
	[[maybe_unused]] uint8_t __pad0921[0x7]; 	// 0x921
public:
	CEntityIOOutput m_OnDetectedBulletFire; // 0x928	
};

// Alignment: 1
// Size: 0x980
class CTriggerDetectExplosion : public CBaseTrigger
{
public:
	CEntityIOOutput m_OnDetectedExplosion; // 0x958	
};

// Alignment: 1
// Size: 0x798
class CScriptNavBlocker : public CFuncNavBlocker
{
public:
	Vector m_vExtent; // 0x788	
};

// Alignment: 7
// Size: 0x9e8
class CBaseFlex : public CBaseAnimatingOverlay
{
public:
	// MNetworkEnable
	// MNetworkBitCount "12"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkEncodeFlags
	CNetworkUtlVectorBase< float32 > m_flexWeight; // 0x958	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vLookTargetPosition; // 0x970	
	// MNetworkEnable
	bool m_blinktoggle; // 0x97c	
private:
	[[maybe_unused]] uint8_t __pad097d[0x53]; 	// 0x97d
public:
	float m_flAllowResponsesEndTime; // 0x9d0	
	float m_flLastFlexAnimationTime; // 0x9d4	
	uint32_t m_nNextSceneEventId; // 0x9d8	
	bool m_bUpdateLayerPriorities; // 0x9dc	
};

// Alignment: 38
// Size: 0xf40
class CBasePropDoor : public CDynamicProp
{
public:
	float m_flAutoReturnDelay; // 0xcc0	
private:
	[[maybe_unused]] uint8_t __pad0cc4[0x4]; 	// 0xcc4
public:
	CUtlVector< CHandle< CBasePropDoor > > m_hDoorList; // 0xcc8	
	int32_t m_nHardwareType; // 0xce0	
	bool m_bNeedsHardware; // 0xce4	
private:
	[[maybe_unused]] uint8_t __pad0ce5[0x3]; 	// 0xce5
public:
	// MNetworkEnable
	DoorState_t m_eDoorState; // 0xce8	
	// MNetworkEnable
	bool m_bLocked; // 0xcec	
private:
	[[maybe_unused]] uint8_t __pad0ced[0x3]; 	// 0xced
public:
	// MNetworkEnable
	Vector m_closedPosition; // 0xcf0	
	// MNetworkEnable
	QAngle m_closedAngles; // 0xcfc	
	CHandle< CBaseEntity > m_hBlocker; // 0xd08	
	bool m_bFirstBlocked; // 0xd0c	
private:
	[[maybe_unused]] uint8_t __pad0d0d[0x3]; 	// 0xd0d
public:
	locksound_t m_ls; // 0xd10	
	bool m_bForceClosed; // 0xd30	
private:
	[[maybe_unused]] uint8_t __pad0d31[0x3]; 	// 0xd31
public:
	Vector m_vecLatchWorldPosition; // 0xd34	
	CHandle< CBaseEntity > m_hActivator; // 0xd40	
private:
	[[maybe_unused]] uint8_t __pad0d44[0x8]; 	// 0xd44
public:
	uint32_t m_sndParamAngularSpeed; // 0xd4c	
	CUtlSymbolLarge m_SoundMoving; // 0xd50	
	CUtlSymbolLarge m_SoundOpen; // 0xd58	
	CUtlSymbolLarge m_SoundClose; // 0xd60	
	CUtlSymbolLarge m_SoundLock; // 0xd68	
	CUtlSymbolLarge m_SoundUnlock; // 0xd70	
	CUtlSymbolLarge m_SoundLatch; // 0xd78	
	CUtlSymbolLarge m_SoundPound; // 0xd80	
	CUtlSymbolLarge m_SoundJiggle; // 0xd88	
	CUtlSymbolLarge m_SoundLockedAnim; // 0xd90	
	int32_t m_numCloseAttempts; // 0xd98	
	CUtlStringToken m_nPhysicsMaterial; // 0xd9c	
	CUtlSymbolLarge m_SlaveName; // 0xda0	
	// MNetworkEnable
	CHandle< CBasePropDoor > m_hMaster; // 0xda8	
private:
	[[maybe_unused]] uint8_t __pad0dac[0x4]; 	// 0xdac
public:
	CEntityIOOutput m_OnBlockedClosing; // 0xdb0	
	CEntityIOOutput m_OnBlockedOpening; // 0xdd8	
	CEntityIOOutput m_OnUnblockedClosing; // 0xe00	
	CEntityIOOutput m_OnUnblockedOpening; // 0xe28	
	CEntityIOOutput m_OnFullyClosed; // 0xe50	
	CEntityIOOutput m_OnFullyOpen; // 0xe78	
	CEntityIOOutput m_OnClose; // 0xea0	
	CEntityIOOutput m_OnOpen; // 0xec8	
	CEntityIOOutput m_OnLockedUse; // 0xef0	
	CEntityIOOutput m_OnAjarOpen; // 0xf18	
};

// Alignment: 5
// Size: 0x840
class CEnvLaser : public CBeam
{
public:
	CUtlSymbolLarge m_iszLaserTarget; // 0x818	
	CSprite* m_pSprite; // 0x820	
	CUtlSymbolLarge m_iszSpriteName; // 0x828	
	Vector m_firePosition; // 0x830	
	float m_flStartFrame; // 0x83c	
};

// Alignment: 24
// Size: 0xa30
class CFish : public CBaseAnimating
{
public:
	CHandle< CFishPool > m_pool; // 0x958	
	uint32_t m_id; // 0x95c	
	// MNetworkEnable
	// MNetworkSerializer "fish_pos_x"
	float m_x; // 0x960	
	// MNetworkEnable
	// MNetworkSerializer "fish_pos_y"
	float m_y; // 0x964	
	// MNetworkEnable
	// MNetworkSerializer "fish_pos_z"
	float m_z; // 0x968	
	// MNetworkEnable
	// MNetworkSerializer "angle_normalize_positive"
	// MNetworkBitCount "7"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "360"
	// MNetworkEncodeFlags
	float m_angle; // 0x96c	
	float m_angleChange; // 0x970	
	Vector m_forward; // 0x974	
	Vector m_perp; // 0x980	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_poolOrigin; // 0x98c	
	// MNetworkEnable
	float m_waterLevel; // 0x998	
	float m_speed; // 0x99c	
	float m_desiredSpeed; // 0x9a0	
	float m_calmSpeed; // 0x9a4	
	float m_panicSpeed; // 0x9a8	
	float m_avoidRange; // 0x9ac	
	CountdownTimer m_turnTimer; // 0x9b0	
	bool m_turnClockwise; // 0x9c0	
private:
	[[maybe_unused]] uint8_t __pad09c1[0x7]; 	// 0x9c1
public:
	CountdownTimer m_goTimer; // 0x9c8	
	CountdownTimer m_moveTimer; // 0x9d8	
	CountdownTimer m_panicTimer; // 0x9e8	
	CountdownTimer m_disperseTimer; // 0x9f8	
	CountdownTimer m_proximityTimer; // 0xa08	
	CUtlVector< CFish* > m_visible; // 0xa18	
};

// Alignment: 9
// Size: 0x2a18
class CFlexCycler : public CBaseFlex
{
public:
	float m_flextime; // 0x9e8	
private:
	[[maybe_unused]] uint8_t __pad09ec[0x4]; 	// 0x9ec
public:
	float m_flextarget[2048]; // 0x9f0	
	float m_blinktime; // 0x29f0	
	float m_looktime; // 0x29f4	
	Vector m_lookTarget; // 0x29f8	
	float m_speaktime; // 0x2a04	
	int32_t m_istalking; // 0x2a08	
	int32_t m_phoneme; // 0x2a0c	
	HSequence m_hCurrLayerSequence; // 0x2a10	
};

// Alignment: 9
// Size: 0x2a60
class CGenericFlexCycler : public CFlexCycler
{
public:
	// MNetworkEnable
	int32_t m_nTestMode; // 0x2a20	
	int32_t m_nTestIndex; // 0x2a24	
	CUtlSymbolLarge m_poseParameterName; // 0x2a28	
	bool m_bDoClientSideAnimation; // 0x2a30	
private:
	[[maybe_unused]] uint8_t __pad2a31[0x7]; 	// 0x2a31
public:
	CUtlSymbolLarge m_layerSequence[2]; // 0x2a38	
	int32_t m_nLayerIndex[2]; // 0x2a48	
	HSequence m_hBaseSequence[2]; // 0x2a50	
	int32_t m_nBoneOverrideIndex; // 0x2a58	
	float m_flLastSimTime; // 0x2a5c	
};

// Alignment: 8
// Size: 0xa30
class CItem : public CBaseAnimating
{
public:
	CEntityIOOutput m_OnPlayerTouch; // 0x960	
	bool m_bActivateWhenAtRest; // 0x988	
private:
	[[maybe_unused]] uint8_t __pad0989[0x7]; 	// 0x989
public:
	CEntityIOOutput m_OnCacheInteraction; // 0x990	
	CEntityIOOutput m_OnPlayerPickup; // 0x9b8	
	CEntityIOOutput m_OnGlovePulled; // 0x9e0	
	Vector m_vOriginalSpawnOrigin; // 0xa08	
	QAngle m_vOriginalSpawnAngles; // 0xa14	
	bool m_bPhysStartAsleep; // 0xa20	
};

// Alignment: 14
// Size: 0xab8
class CPhysicsCannister : public CBaseFlex
{
public:
	Vector m_thrustOrigin; // 0x9f0	
private:
	[[maybe_unused]] uint8_t __pad09fc[0x4]; 	// 0x9fc
public:
	CThrustController m_thruster; // 0xa00	
private:
	[[maybe_unused]] uint8_t __pad0a28[0x8]; 	// 0xa28
public:
	bool m_active; // 0xa30	
private:
	[[maybe_unused]] uint8_t __pad0a31[0x3]; 	// 0xa31
public:
	float m_thrustDuration; // 0xa34	
	float m_damage; // 0xa38	
	float m_damageRadius; // 0xa3c	
	float m_activateTime; // 0xa40	
private:
	[[maybe_unused]] uint8_t __pad0a44[0x4]; 	// 0xa44
public:
	CUtlSymbolLarge m_gasSound; // 0xa48	
	bool m_bFired; // 0xa50	
private:
	[[maybe_unused]] uint8_t __pad0a51[0x7]; 	// 0xa51
public:
	CEntityIOOutput m_onActivate; // 0xa58	
	CEntityIOOutput m_OnAwakened; // 0xa80	
	CHandle< CBasePlayer > m_hPhysicsAttacker; // 0xaa8	
	float m_flLastPhysicsInfluenceTime; // 0xaac	
	CHandle< CBaseEntity > m_hLauncher; // 0xab0	
};

// Alignment: 28
// Size: 0xaf8
class CRagdollProp : public CBaseAnimating
{
public:
	ragdoll_t m_ragdoll; // 0x960	
	bool m_bStartDisabled; // 0x998	
private:
	[[maybe_unused]] uint8_t __pad0999[0x7]; 	// 0x999
public:
	// MNetworkEnable
	// MNetworkEncoder
	CNetworkUtlVectorBase< Vector > m_ragPos; // 0x9a0	
	// MNetworkEnable
	// MNetworkEncoder
	// MNetworkBitCount "13"
	CNetworkUtlVectorBase< QAngle > m_ragAngles; // 0x9b8	
	// MNetworkEnable
	CHandle< CBaseEntity > m_hRagdollSource; // 0x9d0	
	uint32_t m_lastUpdateTickCount; // 0x9d4	
	bool m_allAsleep; // 0x9d8	
	bool m_bFirstCollisionAfterLaunch; // 0x9d9	
private:
	[[maybe_unused]] uint8_t __pad09da[0x2]; 	// 0x9da
public:
	CHandle< CBaseEntity > m_hDamageEntity; // 0x9dc	
	CHandle< CBaseEntity > m_hKiller; // 0x9e0	
	CHandle< CBasePlayer > m_hPhysicsAttacker; // 0x9e4	
	float m_flLastPhysicsInfluenceTime; // 0x9e8	
	float m_flFadeOutStartTime; // 0x9ec	
	float m_flFadeTime; // 0x9f0	
	// MNetworkDisable
	Vector m_vecLastOrigin; // 0x9f4	
	float m_flAwakeTime; // 0xa00	
	float m_flLastOriginChangeTime; // 0xa04	
	int32_t m_nBloodColor; // 0xa08	
private:
	[[maybe_unused]] uint8_t __pad0a0c[0x4]; 	// 0xa0c
public:
	CUtlSymbolLarge m_strSourceClassName; // 0xa10	
	bool m_bHasBeenPhysgunned; // 0xa18	
	bool m_bShouldTeleportPhysics; // 0xa19	
private:
	[[maybe_unused]] uint8_t __pad0a1a[0x2]; 	// 0xa1a
public:
	// MNetworkEnable
	// MNetworkBitCount "8"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1"
	// MNetworkEncodeFlags
	float m_flBlendWeight; // 0xa1c	
	bool m_bDiscoverable; // 0xa20	
private:
	[[maybe_unused]] uint8_t __pad0a21[0x3]; 	// 0xa21
public:
	float m_flDefaultFadeScale; // 0xa24	
	CUtlVector< Vector > m_ragdollMins; // 0xa28	
	CUtlVector< Vector > m_ragdollMaxs; // 0xa40	
	bool m_bShouldDeleteActivationRecord; // 0xa58	
private:
	[[maybe_unused]] uint8_t __pad0a59[0x5f]; 	// 0xa59
public:
	bool m_bValidatePoweredRagdollPose; // 0xab8	
};

// Alignment: 12
// Size: 0x9e8
class CPhysMagnet : public CBaseAnimating
{
public:
	CEntityIOOutput m_OnMagnetAttach; // 0x958	
	CEntityIOOutput m_OnMagnetDetach; // 0x980	
	float m_massScale; // 0x9a8	
	float m_forceLimit; // 0x9ac	
	float m_torqueLimit; // 0x9b0	
private:
	[[maybe_unused]] uint8_t __pad09b4[0x4]; 	// 0x9b4
public:
	CUtlVector< magnetted_objects_t > m_MagnettedEntities; // 0x9b8	
	bool m_bActive; // 0x9d0	
	bool m_bHasHitSomething; // 0x9d1	
private:
	[[maybe_unused]] uint8_t __pad09d2[0x2]; 	// 0x9d2
public:
	float m_flTotalMass; // 0x9d4	
	float m_flRadius; // 0x9d8	
	float m_flNextSuckTime; // 0x9dc	
	int32_t m_iMaxObjectsAttached; // 0x9e0	
};

// Alignment: 31
// Size: 0xcf8
class CPhysicsProp : public CBreakableProp
{
public:
	CEntityIOOutput m_MotionEnabled; // 0xb98	
	CEntityIOOutput m_OnAwakened; // 0xbc0	
	CEntityIOOutput m_OnAwake; // 0xbe8	
	CEntityIOOutput m_OnAsleep; // 0xc10	
	CEntityIOOutput m_OnPlayerUse; // 0xc38	
	CEntityIOOutput m_OnPlayerPickup; // 0xc60	
	CEntityIOOutput m_OnOutOfWorld; // 0xc88	
	float m_massScale; // 0xcb0	
	float m_inertiaScale; // 0xcb4	
	int32_t m_damageType; // 0xcb8	
	int32_t m_damageToEnableMotion; // 0xcbc	
	float m_flForceToEnableMotion; // 0xcc0	
	bool m_bThrownByPlayer; // 0xcc4	
	bool m_bDroppedByPlayer; // 0xcc5	
	bool m_bTouchedByPlayer; // 0xcc6	
	bool m_bFirstCollisionAfterLaunch; // 0xcc7	
	int32_t m_iExploitableByPlayer; // 0xcc8	
	bool m_bHasBeenAwakened; // 0xccc	
	bool m_bIsOverrideProp; // 0xccd	
private:
	[[maybe_unused]] uint8_t __pad0cce[0x2]; 	// 0xcce
public:
	float m_fNextCheckDisableMotionContactsTime; // 0xcd0	
	int32_t m_iInitialGlowState; // 0xcd4	
	int32_t m_nGlowRange; // 0xcd8	
	int32_t m_nGlowRangeMin; // 0xcdc	
	Color m_glowColor; // 0xce0	
	bool m_bForceNavIgnore; // 0xce4	
	bool m_bForceNpcExclude; // 0xce5	
	bool m_bShouldAutoConvertBackFromDebris; // 0xce6	
	bool m_bMuteImpactEffects; // 0xce7	
private:
	[[maybe_unused]] uint8_t __pad0ce8[0x4]; 	// 0xce8
public:
	bool m_bAcceptDamageFromHeldObjects; // 0xcec	
	// MNetworkEnable
	bool m_bAwake; // 0xced	
private:
	[[maybe_unused]] uint8_t __pad0cee[0x2]; 	// 0xcee
public:
	int32_t m_nCollisionGroupOverride; // 0xcf0	
};

// Alignment: 0
// Size: 0xcf8
class CPhysicsPropOverride : public CPhysicsProp
{
public:
	// @note: no members available
};

// Alignment: 5
// Size: 0xd30
class CPhysicsPropRespawnable : public CPhysicsProp
{
public:
	Vector m_vOriginalSpawnOrigin; // 0xcf8	
	QAngle m_vOriginalSpawnAngles; // 0xd04	
	Vector m_vOriginalMins; // 0xd10	
	Vector m_vOriginalMaxs; // 0xd1c	
	float m_flRespawnDuration; // 0xd28	
};

// Alignment: 6
// Size: 0xb20
class CPropVehicle : public CBaseProp
{
public:
	CFourWheelVehiclePhysics m_VehiclePhysics; // 0x9a0	
	uint32_t m_nVehicleType; // 0xaf8	
private:
	[[maybe_unused]] uint8_t __pad0afc[0x4]; 	// 0xafc
public:
	CUtlSymbolLarge m_vehicleScript; // 0xb00	
	Vector m_vecSmoothedVelocity; // 0xb08	
	CHandle< CBasePlayer > m_hPhysicsAttacker; // 0xb14	
	float m_flLastPhysicsInfluenceTime; // 0xb18	
};

// Alignment: 27
// Size: 0xc78
class CPropVehicleDriveable : public CPropVehicle
{
public:
	CFourWheelServerVehicle* m_pServerVehicle; // 0xb30	
	CEntityIOOutput m_playerOn; // 0xb38	
	CEntityIOOutput m_playerOff; // 0xb60	
	CEntityIOOutput m_pressedAttack; // 0xb88	
	CEntityIOOutput m_pressedAttack2; // 0xbb0	
	CEntityOutputTemplate< float32 > m_attackaxis; // 0xbd8	
	CEntityOutputTemplate< float32 > m_attack2axis; // 0xc00	
	// MNetworkEnable
	CHandle< CBasePlayer > m_hPlayer; // 0xc28	
	// MNetworkEnable
	int32_t m_nSpeed; // 0xc2c	
	// MNetworkEnable
	int16_t m_nRPM; // 0xc30	
private:
	[[maybe_unused]] uint8_t __pad0c32[0x2]; 	// 0xc32
public:
	// MNetworkEnable
	float m_flThrottle; // 0xc34	
	// MNetworkEnable
	int32_t m_nBoostTimeLeft; // 0xc38	
	// MNetworkEnable
	bool m_bHasBoost; // 0xc3c	
private:
	[[maybe_unused]] uint8_t __pad0c3d[0x3]; 	// 0xc3d
public:
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecEyeExitEndpoint; // 0xc40	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_vecGunCrosshair; // 0xc4c	
	// MNetworkEnable
	bool m_bUnableToFire; // 0xc58	
	// MNetworkEnable
	bool m_bHasGun; // 0xc59	
	// MNetworkEnable
	bool m_nScannerDisabledWeapons; // 0xc5a	
	// MNetworkEnable
	bool m_nScannerDisabledVehicle; // 0xc5b	
private:
	[[maybe_unused]] uint8_t __pad0c5c[0x4]; 	// 0xc5c
public:
	CHandle< CBaseEntity > m_hKeepUpright; // 0xc60	
	bool m_bEngineLocked; // 0xc64	
	bool m_bLocked; // 0xc65	
private:
	[[maybe_unused]] uint8_t __pad0c66[0x2]; 	// 0xc66
public:
	float m_flMinimumSpeedToEnterExit; // 0xc68	
	// MNetworkEnable
	bool m_bEnterAnimOn; // 0xc6c	
	// MNetworkEnable
	bool m_bExitAnimOn; // 0xc6d	
private:
	[[maybe_unused]] uint8_t __pad0c6e[0x2]; 	// 0xc6e
public:
	float m_flTurnOffKeepUpright; // 0xc70	
	float m_flNoImpactDamageTime; // 0xc74	
};

// Alignment: 0
// Size: 0x958
class CWaterBullet : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 14
// Size: 0xa90
class CBaseGrenade : public CBaseFlex
{
public:
	CEntityIOOutput m_OnPlayerPickup; // 0x9f0	
	CEntityIOOutput m_OnExplode; // 0xa18	
	bool m_bHasWarnedAI; // 0xa40	
	bool m_bIsSmokeGrenade; // 0xa41	
	// MNetworkEnable
	bool m_bIsLive; // 0xa42	
private:
	[[maybe_unused]] uint8_t __pad0a43[0x1]; 	// 0xa43
public:
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "1024"
	// MNetworkEncodeFlags
	float m_DmgRadius; // 0xa44	
	// MNetworkEnable
	float m_flDetonateTime; // 0xa48	
	float m_flWarnAITime; // 0xa4c	
	// MNetworkEnable
	// MNetworkBitCount "10"
	// MNetworkMinValue "0"
	// MNetworkMaxValue "256"
	// MNetworkEncodeFlags
	float m_flDamage; // 0xa50	
private:
	[[maybe_unused]] uint8_t __pad0a54[0x4]; 	// 0xa54
public:
	CUtlSymbolLarge m_iszBounceSound; // 0xa58	
	CUtlString m_ExplosionSound; // 0xa60	
private:
	[[maybe_unused]] uint8_t __pad0a68[0x4]; 	// 0xa68
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hThrower; // 0xa6c	
private:
	[[maybe_unused]] uint8_t __pad0a70[0x18]; 	// 0xa70
public:
	float m_flNextAttack; // 0xa88	
	CHandle< CBaseEntity > m_hOriginalThrower; // 0xa8c	
};

// Alignment: 3
// Size: 0xd60
class CShatterGlassShardPhysics : public CPhysicsProp
{
public:
	bool m_bDebris; // 0xcf8	
private:
	[[maybe_unused]] uint8_t __pad0cf9[0x3]; 	// 0xcf9
public:
	uint32_t m_hParentShard; // 0xcfc	
	// MNetworkEnable
	shard_model_desc_t m_ShardDesc; // 0xd00	
};

// Alignment: 5
// Size: 0x978
class CNPCAbilityModel : public CBaseAnimating
{
public:
	bool m_bDropped; // 0x960	
private:
	[[maybe_unused]] uint8_t __pad0961[0x3]; 	// 0x961
public:
	float m_flUnlockTime; // 0x964	
	CHandle< CBaseEntity > m_hLocker; // 0x968	
	CUtlStringToken m_nPrimaryAbilityID; // 0x96c	
	CUtlVector< CUtlStringToken >* m_pVecSecondaryAbilityIDs; // 0x970	
};

// Alignment: 4
// Size: 0x9d8
class CPropAnimatingBreakable : public CBaseAnimating
{
public:
	int32_t m_nCurrentBreakStage; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad095c[0x4]; 	// 0x95c
public:
	CEntityIOOutput m_OnTakeDamage; // 0x960	
	CEntityIOOutput m_OnFinalBreak; // 0x988	
	CEntityIOOutput m_OnStageAdvanced; // 0x9b0	
};

// Alignment: 5
// Size: 0x978
class CSteamPal_BaseSingingEntity : public CBaseAnimating
{
public:
	char m_cCurNote; // 0x960	
private:
	[[maybe_unused]] uint8_t __pad0961[0x3]; 	// 0x961
public:
	float m_flTimeNotePlayed; // 0x964	
	int32_t m_nSequenceTrack; // 0x968	
	bool m_bIsRegistered; // 0x96c	
private:
	[[maybe_unused]] uint8_t __pad096d[0x3]; 	// 0x96d
public:
	float m_flWingLastNotePct; // 0x970	
};

// Alignment: 1
// Size: 0x960
class CSteamPal_WritingSurface : public CBaseAnimating
{
public:
	// MNetworkEnable
	bool m_bCanWrite; // 0x958	
};

// Alignment: 54
// Size: 0xf50
class CSteamPal_Turret : public CBaseAnimating
{
public:
	AttachmentHandle_t m_hTurretLaserAttachment; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	// MNetworkEnable
	CHandle< CSteamPal_Turret_Wing > m_hWings[2]; // 0x95c	
	// MNetworkEnable
	CHandle< CSteamPal_Turret_Wing > m_hLeftWing; // 0x964	
	// MNetworkEnable
	CHandle< CSteamPal_Turret_Wing > m_hRightWing; // 0x968	
	// MNetworkEnable
	bool m_bBeingControlled; // 0x96c	
	// MNetworkEnable
	bool m_bGyroHintEnabled; // 0x96d	
private:
	[[maybe_unused]] uint8_t __pad096e[0x2]; 	// 0x96e
public:
	// MNetworkEnable
	float m_flTotalGyroActiveTime; // 0x970	
	// MNetworkEnable
	float m_flTotalGyroInactiveTime; // 0x974	
	// MNetworkEnable
	float m_flLastGyroActiveTime; // 0x978	
	ParticleIndex_t m_nLaserSightFX; // 0x97c	
	CEntityIOOutput m_OnLeftWingButton; // 0x980	
	CEntityIOOutput m_OnRightWingButton; // 0x9a8	
	CEntityIOOutput m_OnAnyWingButton; // 0x9d0	
	CEntityIOOutput m_OnLeftFireButton; // 0x9f8	
	CEntityIOOutput m_OnRightFireButton; // 0xa20	
	CEntityIOOutput m_OnAnyFireButton; // 0xa48	
	CEntityIOOutput m_OnTurretExploded; // 0xa70	
	CEntityIOOutput m_OnToiletControlsUsed; // 0xa98	
	CEntityIOOutput m_OnPresentingRotationFinished; // 0xac0	
	Vector m_vLaserSightEnd; // 0xae8	
private:
	[[maybe_unused]] uint8_t __pad0af4[0x4]; 	// 0xaf4
public:
	// MNetworkEnable
	float m_flCurrentAimX; // 0xaf8	
	// MNetworkEnable
	float m_flCurrentAimY; // 0xafc	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hAmmoModel; // 0xb00	
	// MNetworkEnable
	bool m_bRevertFOV; // 0xb04	
private:
	[[maybe_unused]] uint8_t __pad0b05[0x3]; 	// 0xb05
public:
	// MNetworkEnable
	float m_flWingDeployAmount; // 0xb08	
	// MNetworkEnable
	CHandle< CSteamPalPointCamera > m_hReturnCamera; // 0xb0c	
private:
	[[maybe_unused]] uint8_t __pad0b10[0x400]; 	// 0xb10
public:
	CHandle< CSteampal_Turret_Manager > m_hTurretManager; // 0xf10	
	float m_flMinAimYawLimit; // 0xf14	
	float m_flMaxAimYawLimit; // 0xf18	
	float m_flMinAimPitchLimit; // 0xf1c	
	float m_flMaxAimPitchLimit; // 0xf20	
	bool m_bWingAimEnabled; // 0xf24	
	bool m_bHorizontalWingAimEnabled; // 0xf25	
	bool m_bWingsFlipped; // 0xf26	
	bool m_bTrackPadAimingEnabled; // 0xf27	
	bool m_bShootingEnabled; // 0xf28	
	bool m_bLaserSightEnabled; // 0xf29	
	bool m_bAllowShootingWhileWingsClosed; // 0xf2a	
	bool m_bForceWingsOpen; // 0xf2b	
	bool m_bCameraBeingControlled; // 0xf2c	
	bool m_bShowAmmoCounter; // 0xf2d	
	bool m_bInfiniteAmmo; // 0xf2e	
private:
	[[maybe_unused]] uint8_t __pad0f2f[0x1]; 	// 0xf2f
public:
	int32_t m_nAmmoRemaining; // 0xf30	
	float m_flAmmoRemaining; // 0xf34	
	bool m_bExploded; // 0xf38	
	bool m_bShouldScaleDamageForce; // 0xf39	
private:
	[[maybe_unused]] uint8_t __pad0f3a[0x2]; 	// 0xf3a
public:
	float m_flAutoAimFactorX; // 0xf3c	
	float m_flAutoAimFactorY; // 0xf40	
	bool m_bCanTakeDamage; // 0xf44	
	bool m_bRestrictWingAimForPresentingTurret; // 0xf45	
	bool m_bToiletControlsEnabled; // 0xf46	
	bool m_bFiredThisFrame; // 0xf47	
	bool m_bAutoAimAllowed; // 0xf48	
	bool m_bTurretHidden; // 0xf49	
};

// Alignment: 37
// Size: 0x1220
class CSteamPal_Intro_Toilet : public CSteamPal_Turret
{
public:
	// MNetworkEnable
	float m_flLidSpeed; // 0xf50	
	// MNetworkEnable
	float m_flLidPos; // 0xf54	
	// MNetworkEnable
	float m_flHandleSpeed; // 0xf58	
	// MNetworkEnable
	float m_flHandlePos; // 0xf5c	
	// MNetworkEnable
	float m_flBidetPlaybackSpeed; // 0xf60	
	// MNetworkEnable
	float m_flBidetPlaybackPos; // 0xf64	
	// MNetworkEnable
	float m_flCisternSpeed; // 0xf68	
	// MNetworkEnable
	float m_flCisternPos; // 0xf6c	
	// MNetworkEnable
	int32_t m_nWaterLevel; // 0xf70	
	// MNetworkEnable
	bool m_bLoadedWithBullets; // 0xf74	
	// MNetworkEnable
	bool m_bExclusiveToilet; // 0xf75	
private:
	[[maybe_unused]] uint8_t __pad0f76[0x2]; 	// 0xf76
public:
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nLidTestState; // 0xf78	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nFlushTestState; // 0xf7c	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nBidet1TestState; // 0xf80	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nBidet2TestState; // 0xf84	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nBidet3TestState; // 0xf88	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nBidet4TestState; // 0xf8c	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nLeftArmTestState; // 0xf90	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nRightArmTestState; // 0xf94	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nHoldWaterTestState; // 0xf98	
	// MNetworkEnable
	CSteamPal_Intro_Toilet::TestState_t m_nSeatPressureTestState; // 0xf9c	
	// MNetworkEnable
	CHandle< CDynamicProp > m_hWaterSpout; // 0xfa0	
	// MNetworkEnable
	CHandle< CDynamicProp > m_hPressureTester; // 0xfa4	
	// MNetworkEnable
	CHandle< CSteamPal_ToiletTestPanel > m_hTestPanel; // 0xfa8	
private:
	[[maybe_unused]] uint8_t __pad0fac[0x4]; 	// 0xfac
public:
	CEntityIOOutput m_OnTestFailed; // 0xfb0	
	CEntityIOOutput m_OnTestsPassed; // 0xfd8	
	CEntityIOOutput m_OnFlushButton; // 0x1000	
	CEntityIOOutput m_OnBidetButton; // 0x1028	
	CEntityIOOutput m_OnPressureButtonPressed; // 0x1050	
	CEntityIOOutput m_OnPressureButtonReleased; // 0x1078	
	CEntityIOOutput m_OnPressureTesterDown; // 0x10a0	
	CEntityIOOutput m_OnLidButton; // 0x10c8	
	CEntityIOOutput m_OnCisternButton; // 0x10f0	
	CEntityIOOutput m_OnSpoutStartWater; // 0x1118	
	CEntityIOOutput m_OnOtherButton; // 0x1140	
	CEntityIOOutput m_OnHighBidetPressure; // 0x1168	
	CEntityIOOutput m_OnSmokingToiletBidetCanceled; // 0x1190	
};

// Alignment: 34
// Size: 0xfe0
class CSteamPal_ToiletTestPanel : public CPhysicsProp
{
public:
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hCisternDiagramLight; // 0xcf8	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hFlushDiagramLight; // 0xcfc	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hSeatPressureDiagramLight; // 0xd00	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hBidetDiagramLight; // 0xd04	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hCisternTestLight; // 0xd08	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hFlushTestLight; // 0xd0c	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hSeatPressureTestLight; // 0xd10	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hBidetTestLight; // 0xd14	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hCisternGauge; // 0xd18	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hFlushGauge; // 0xd1c	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hSeatPressureGauge; // 0xd20	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hBidetGauge; // 0xd24	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hCisternFunctionLight; // 0xd28	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hBidetFunctionLight; // 0xd2c	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hFlushFunctionLight; // 0xd30	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hSeatPressureFunctionLight; // 0xd34	
	// MNetworkEnable
	CHandle< CBaseModelEntity > m_hPassFailLight; // 0xd38	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit0; // 0xd3c	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit1; // 0xd40	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit2; // 0xd44	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit3; // 0xd48	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit4; // 0xd4c	
	// MNetworkEnable
	CHandle< CBaseAnimating > m_hDigit5; // 0xd50	
	// MNetworkEnable
	int32_t m_nCounterValue; // 0xd54	
private:
	[[maybe_unused]] uint8_t __pad0d58[0x60]; 	// 0xd58
public:
	CEntityIOOutput m_OnTestLidPassed; // 0xdb8	
	CEntityIOOutput m_OnTestCisternPassed; // 0xde0	
	CEntityIOOutput m_OnTestLeftArmPassed; // 0xe08	
	CEntityIOOutput m_OnTestRightArmPassed; // 0xe30	
	CEntityIOOutput m_OnTestBidetPassed; // 0xe58	
	CEntityIOOutput m_OnTestPressurePassed; // 0xe80	
	CEntityIOOutput m_OnTestFlushPassed; // 0xea8	
	CEntityIOOutput m_OnAllTestsPassed; // 0xed0	
	CEntityIOOutput m_OnTestFailed; // 0xef8	
	CEntityIOOutput m_OnResetPanel; // 0xf20	
};

// Alignment: 4
// Size: 0x968
class CSteamPal_Toilet : public CBaseAnimating
{
public:
	AttachmentHandle_t m_hToiletBidetAttachment; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	CEntityHandle m_hSeatHinge; // 0x95c	
	CEntityHandle m_hSeatCoverHinge; // 0x960	
	CEntityHandle m_hCisternLidConstraint; // 0x964	
};

// Alignment: 5
// Size: 0x998
class CSteamPal_Ultra_Toilet_Rocket : public CBaseAnimating
{
public:
	AttachmentHandle_t m_nTrailAttachment; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	ParticleIndex_t m_nTrailFX; // 0x95c	
	Vector m_vPrevPos; // 0x960	
private:
	[[maybe_unused]] uint8_t __pad096c[0x24]; 	// 0x96c
public:
	CHandle< CSteamPal_Ultra_Toilet_Attachment > m_hUltraAttachment; // 0x990	
	bool m_bIsLastRocket; // 0x994	
};

// Alignment: 23
// Size: 0xb38
class CSteamPal_Ultra_Toilet_Attachment : public CBaseAnimating
{
public:
	CEntityIOOutput m_OnLastRocketExploded; // 0x958	
	CHandle< CSteamPal_Ultra_Toilet > m_hUltraToilet; // 0x980	
	CHandle< CPhysicsProp > m_hAttachedModels[7]; // 0x984	
	CUtlString m_hAttachedModelsAnimgraphParams[7]; // 0x9a0	
	SteamPal_Ultra_Toilet_Gun_t m_UltraGuns[7]; // 0x9d8	
	CUtlVector< CHandle< CSteamPal_Ultra_Toilet_Rocket > > m_LeftRockets; // 0xa80	
	CUtlVector< CHandle< CSteamPal_Ultra_Toilet_Rocket > > m_RightRockets; // 0xa98	
	CUtlVector< int32 > m_LeftRocketPathIndexes; // 0xab0	
	CUtlVector< int32 > m_RightRocketPathIndexes; // 0xac8	
	int32_t m_nLeftIgnitedRocket; // 0xae0	
	int32_t m_nRightIgnitedRocket; // 0xae4	
	bool m_bLauncherIsBroken; // 0xae8	
private:
	[[maybe_unused]] uint8_t __pad0ae9[0x3]; 	// 0xae9
public:
	CHandle< CPhysicsProp > m_hRotateRocketModel; // 0xaec	
	bool m_bMinigunShooting; // 0xaf0	
	bool m_bMinigunWindingUp; // 0xaf1	
private:
	[[maybe_unused]] uint8_t __pad0af2[0x26]; 	// 0xaf2
public:
	AttachmentHandle_t m_nSMGHingeAttachment; // 0xb18	
private:
	[[maybe_unused]] uint8_t __pad0b19[0xf]; 	// 0xb19
public:
	AttachmentHandle_t m_nRadarHingeAttachment; // 0xb28	
	AttachmentHandle_t m_nRadarSpinAttachment; // 0xb29	
	AttachmentHandle_t m_nRadarMuzzleAttachment; // 0xb2a	
private:
	[[maybe_unused]] uint8_t __pad0b2b[0x1]; 	// 0xb2b
public:
	float m_flRadarPitch; // 0xb2c	
	bool m_bUltraHidden; // 0xb30	
	bool m_bReadyToControl; // 0xb31	
private:
	[[maybe_unused]] uint8_t __pad0b32[0x2]; 	// 0xb32
public:
	int32_t m_nCurrentExplodeStage; // 0xb34	
};

// Alignment: 6
// Size: 0xff8
class CSteamPal_Ultra_Toilet : public CSteamPal_Turret
{
public:
	CEntityIOOutput m_OnUltraIntroStart; // 0xf50	
	CEntityIOOutput m_OnUltraIntroEnd; // 0xf78	
	CEntityIOOutput m_OnUltraRotationEnd; // 0xfa0	
	CEntityIOOutput m_OnUltraTurretShoot; // 0xfc8	
	float m_flPrevThinkTime; // 0xff0	
	CHandle< CSteamPal_Ultra_Toilet_Attachment > m_hUltraAttachment; // 0xff4	
};

// Alignment: 0
// Size: 0x958
class CSteamPal_Trackball : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x958
class CSteamPal_TouchScreen : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 20
// Size: 0xe70
class CSteamPal_Desk : public CBaseAnimating
{
public:
	// MNetworkEnable
	bool m_bInputEnabled; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	float m_flStickDeployAmount; // 0x95c	
	float m_flStickDeployVelocity; // 0x960	
	int32_t m_nDeskState; // 0x964	
	bool m_bDiscoveryModeComplete; // 0x968	
	bool m_bDeskHidden; // 0x969	
private:
	[[maybe_unused]] uint8_t __pad096a[0x2ce]; 	// 0x96a
public:
	CEntityIOOutput m_OnAButton; // 0xc38	
	CEntityIOOutput m_OnBButton; // 0xc60	
	CEntityIOOutput m_OnXButton; // 0xc88	
	CEntityIOOutput m_OnYButton; // 0xcb0	
	CEntityIOOutput m_OnL4Button; // 0xcd8	
	CEntityIOOutput m_OnL5Button; // 0xd00	
	CEntityIOOutput m_OnR4Button; // 0xd28	
	CEntityIOOutput m_OnR5Button; // 0xd50	
	CEntityIOOutput m_OnL4ButtonReleased; // 0xd78	
	CEntityIOOutput m_OnL5ButtonReleased; // 0xda0	
	CEntityIOOutput m_OnR4ButtonReleased; // 0xdc8	
	CEntityIOOutput m_OnR5ButtonReleased; // 0xdf0	
	CEntityIOOutput m_OnHamburgerButton; // 0xe18	
	CEntityIOOutput m_OnShowPaddles; // 0xe40	
};

// Alignment: 6
// Size: 0xd28
class CSteamPal_PaintableProp : public CPhysicsProp
{
public:
	CUtlSymbolLarge m_iszSoundName; // 0xcf8	
	CUtlSymbolLarge m_iszAscentSoundName; // 0xd00	
	CUtlSymbolLarge m_iszGallerySoundName; // 0xd08	
private:
	[[maybe_unused]] uint8_t __pad0d10[0x8]; 	// 0xd10
public:
	bool m_bAlwaysAnimate; // 0xd18	
private:
	[[maybe_unused]] uint8_t __pad0d19[0x3]; 	// 0xd19
public:
	SteamPalPaintType m_PaintType; // 0xd1c	
	// MNetworkEnable
	bool m_bShouldSetPicture; // 0xd20	
};

// Alignment: 2
// Size: 0xd30
class CSteamPal_Toaster : public CSteamPal_PaintableProp
{
public:
	CHandle< CPhysicsProp > m_hPropToLaunch; // 0xd28	
	AttachmentHandle_t m_hLauncherAttachment; // 0xd2c	
};

// Alignment: 3
// Size: 0xd50
class CSteamPal_TouchTarget : public CPhysicsProp
{
public:
	CEntityIOOutput m_OnStartTouch; // 0xcf8	
	CEntityIOOutput m_OnEndTouch; // 0xd20	
	bool m_bPlayerIsTouching; // 0xd48	
};

// Alignment: 4
// Size: 0x970
class CSteamPal_Projectile_Tag_Dart : public CBaseAnimating
{
public:
	bool m_bLaunched; // 0x958	
private:
	[[maybe_unused]] uint8_t __pad0959[0x3]; 	// 0x959
public:
	ParticleIndex_t m_nAttachedParticle; // 0x95c	
	Vector m_vTouchPos; // 0x960	
	CHandle< CBaseEntity > m_hWeapon; // 0x96c	
};

// Alignment: 0
// Size: 0xcf8
class CNPCApplianceProjectile : public CPhysicsProp
{
public:
	// @note: no members available
};

// Alignment: 1
// Size: 0x2a20
class CFlexExpresserShim : public CFlexCycler
{
public:
	CAI_Expresser* m_pExpresser; // 0x2a18	
};

// Alignment: 1
// Size: 0x2a30
class CFlexExpresser : public CFlexExpresserShim
{
public:
	float m_flThenAnyMaxDist; // 0x2a28	
};

// Alignment: 19
// Size: 0xd18
class CDevtestHierarchy : public CDynamicProp
{
public:
	Vector m_vRotationAxis; // 0xcb0	
	float m_flRotationSpeed; // 0xcbc	
	// MNetworkEnable
	int32_t m_nTestMode; // 0xcc0	
	CHandle< CBaseEntity > m_hChild; // 0xcc4	
	// MNetworkEnable
	CUtlStringToken m_attachName; // 0xcc8	
	// MNetworkEnable
	Vector m_vDynamicAttachOffset; // 0xccc	
	// MNetworkEnable
	int32_t m_nDynamicResetCount; // 0xcd8	
	int32_t m_nDynamicDetachCount; // 0xcdc	
	// MNetworkEnable
	bool m_bChildIsDynamic; // 0xce0	
	// MNetworkEnable
	bool m_bCreateChildSideChild; // 0xce1	
private:
	[[maybe_unused]] uint8_t __pad0ce2[0x2]; 	// 0xce2
public:
	// MNetworkEnable
	CUtlStringToken m_alternateAttachName; // 0xce4	
	CHandle< CBaseEntity > m_hAlternateParent; // 0xce8	
private:
	[[maybe_unused]] uint8_t __pad0cec[0x4]; 	// 0xcec
public:
	CStrongHandle< InfoForResourceTypeCModel > m_hAlternateModel; // 0xcf0	
	CStrongHandle< InfoForResourceTypeCModel > m_hOriginalModel; // 0xcf8	
	// MNetworkEnable
	CStrongHandle< InfoForResourceTypeCModel > m_hClientSideChildModel; // 0xd00	
	// MNetworkEnable
	float m_flEntityStartTime; // 0xd08	
	int32_t m_nTestIndex; // 0xd0c	
	HierarchyType_t m_nCurrType; // 0xd10	
	int32_t m_nCurrentModel; // 0xd14	
};

// Alignment: 0
// Size: 0xcb0
class CDevtestHierarchyChild : public CDynamicProp
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x958
class CDevtestHierarchy2 : public CBaseAnimating
{
public:
	// @note: no members available
};

// Alignment: 8
// Size: 0x9a0
class CBasePlayerWeapon : public CBaseAnimating
{
public:
	// MNetworkEnable
	WeaponState_t m_iState; // 0x958	
	bool m_bRemoveable; // 0x95c	
private:
	[[maybe_unused]] uint8_t __pad095d[0x3]; 	// 0x95d
public:
	// MNetworkEnable
	// MNetworkUserGroup "LocalWeaponExclusive"
	float m_flNextPrimaryAttack; // 0x960	
	// MNetworkEnable
	// MNetworkUserGroup "LocalWeaponExclusive"
	float m_flNextSecondaryAttack; // 0x964	
	// MNetworkEnable
	// MNetworkSerializer "minusone"
	// MNetworkPriority "32"
	int32_t m_iClip1; // 0x968	
	// MNetworkEnable
	// MNetworkSerializer "minusone"
	// MNetworkUserGroup "LocalWeaponExclusive"
	int32_t m_iClip2; // 0x96c	
	// MNetworkEnable
	// MNetworkUserGroup "LocalWeaponExclusive"
	int32_t m_pReserveAmmo[2]; // 0x970	
	CEntityIOOutput m_OnPlayerUse; // 0x978	
};

// Alignment: 0
// Size: 0x9e8
class CBaseFlexAlias_funCBaseFlex : public CBaseFlex
{
public:
	// @note: no members available
};

// Alignment: 0
// Size: 0x2a60
class CGenericFlexCyclerAlias_cycler : public CGenericFlexCycler
{
public:
	// @note: no members available
};

// Alignment: 2
// Size: 0xa60
class CScriptItem : public CItem
{
public:
	CEntityIOOutput m_OnPlayerPickup; // 0xa30	
	MoveType_t m_MoveTypeOverride; // 0xa58	
};

// Alignment: 0
// Size: 0xaf8
class CRagdollPropAlias_physics_prop_ragdoll : public CRagdollProp
{
public:
	// @note: no members available
};

// Alignment: 6
// Size: 0xb38
class CRagdollPropAttached : public CRagdollProp
{
public:
	// MNetworkEnable
	uint32_t m_boneIndexAttached; // 0xaf8	
	// MNetworkEnable
	uint32_t m_ragdollAttachedObjectIndex; // 0xafc	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_attachmentPointBoneSpace; // 0xb00	
	// MNetworkEnable
	// MNetworkEncoder
	Vector m_attachmentPointRagdollSpace; // 0xb0c	
	bool m_bShouldDetach; // 0xb18	
private:
	[[maybe_unused]] uint8_t __pad0b19[0xf]; 	// 0xb19
public:
	bool m_bShouldDeleteAttachedActivationRecord; // 0xb28	
};

// Alignment: 16
// Size: 0xfd0
class CPropDoorRotating : public CBasePropDoor
{
public:
	Vector m_vecAxis; // 0xf40	
	float m_flDistance; // 0xf4c	
	PropDoorRotatingSpawnPos_t m_eSpawnPosition; // 0xf50	
	PropDoorRotatingOpenDirection_e m_eOpenDirection; // 0xf54	
	PropDoorRotatingOpenDirection_e m_eCurrentOpenDirection; // 0xf58	
	float m_flAjarAngle; // 0xf5c	
	QAngle m_angRotationAjarDeprecated; // 0xf60	
	QAngle m_angRotationClosed; // 0xf6c	
	QAngle m_angRotationOpenForward; // 0xf78	
	QAngle m_angRotationOpenBack; // 0xf84	
	QAngle m_angGoal; // 0xf90	
	Vector m_vecForwardBoundsMin; // 0xf9c	
	Vector m_vecForwardBoundsMax; // 0xfa8	
	Vector m_vecBackBoundsMin; // 0xfb4	
	Vector m_vecBackBoundsMax; // 0xfc0	
	CHandle< CEntityBlocker > m_hEntityBlocker; // 0xfcc	
};

// Alignment: 4
// Size: 0xff0
class CPropDoorRotatingBreakable : public CPropDoorRotating
{
public:
	bool m_bBreakable; // 0xfd0	
	bool m_isAbleToCloseAreaPortals; // 0xfd1	
private:
	[[maybe_unused]] uint8_t __pad0fd2[0x2]; 	// 0xfd2
public:
	int32_t m_currentDamageState; // 0xfd4	
	CUtlVector< CUtlSymbolLarge > m_damageStates; // 0xfd8	
};

// Alignment: 13
// Size: 0xa58
class CBaseCombatCharacter : public CBaseFlex
{
public:
	bool m_bForceServerRagdoll; // 0x9e8	
private:
	[[maybe_unused]] uint8_t __pad09e9[0x3]; 	// 0x9e9
public:
	// MNetworkEnable
	float m_flFieldOfView; // 0x9ec	
	float m_impactEnergyScale; // 0x9f0	
	HitGroup_t m_LastHitGroup; // 0x9f4	
	bool m_bApplyStressDamage; // 0x9f8	
private:
	[[maybe_unused]] uint8_t __pad09f9[0x3]; 	// 0x9f9
public:
	int32_t m_bloodColor; // 0x9fc	
private:
	[[maybe_unused]] uint8_t __pad0a00[0x30]; 	// 0xa00
public:
	int32_t m_registeredNavTeam; // 0xa30	
	int32_t m_navMeshID; // 0xa34	
	int32_t m_iDamageCount; // 0xa38	
private:
	[[maybe_unused]] uint8_t __pad0a3c[0x4]; 	// 0xa3c
public:
	CUtlVector< RelationshipOverride_t >* m_pVecRelationships; // 0xa40	
	CUtlSymbolLarge m_strRelationships; // 0xa48	
	Hull_t m_eHull; // 0xa50	
	uint32_t m_nNavHullIdx; // 0xa54	
	static int32_t &Get_sm_lastInteraction(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CBaseCombatCharacter")->m_static_fields[0]->m_instance);};
};

// Alignment: 32
// Size: 0xba0
class CItemGeneric : public CItem
{
public:
	bool m_bHasTriggerRadius; // 0xa38	
	bool m_bHasPickupRadius; // 0xa39	
private:
	[[maybe_unused]] uint8_t __pad0a3a[0x2]; 	// 0xa3a
public:
	float m_flPickupRadiusSqr; // 0xa3c	
	float m_flTriggerRadiusSqr; // 0xa40	
	float m_flLastPickupCheck; // 0xa44	
	bool m_bPlayerCounterListenerAdded; // 0xa48	
	bool m_bPlayerInTriggerRadius; // 0xa49	
private:
	[[maybe_unused]] uint8_t __pad0a4a[0x6]; 	// 0xa4a
public:
	CStrongHandle< InfoForResourceTypeIParticleSystemDefinition > m_hSpawnParticleEffect; // 0xa50	
	CUtlSymbolLarge m_pAmbientSoundEffect; // 0xa58	
	bool m_bAutoStartAmbientSound; // 0xa60	
private:
	[[maybe_unused]] uint8_t __pad0a61[0x7]; 	// 0xa61
public:
	CUtlSymbolLarge m_pSpawnScriptFunction; // 0xa68	
	CStrongHandle< InfoForResourceTypeIParticleSystemDefinition > m_hPickupParticleEffect; // 0xa70	
	CUtlSymbolLarge m_pPickupSoundEffect; // 0xa78	
	CUtlSymbolLarge m_pPickupScriptFunction; // 0xa80	
	CStrongHandle< InfoForResourceTypeIParticleSystemDefinition > m_hTimeoutParticleEffect; // 0xa88	
	CUtlSymbolLarge m_pTimeoutSoundEffect; // 0xa90	
	CUtlSymbolLarge m_pTimeoutScriptFunction; // 0xa98	
	CUtlSymbolLarge m_pPickupFilterName; // 0xaa0	
	CHandle< CBaseFilter > m_hPickupFilter; // 0xaa8	
private:
	[[maybe_unused]] uint8_t __pad0aac[0x4]; 	// 0xaac
public:
	CEntityIOOutput m_OnPickup; // 0xab0	
	CEntityIOOutput m_OnTimeout; // 0xad8	
	CEntityIOOutput m_OnTriggerStartTouch; // 0xb00	
	CEntityIOOutput m_OnTriggerTouch; // 0xb28	
	CEntityIOOutput m_OnTriggerEndTouch; // 0xb50	
	CUtlSymbolLarge m_pAllowPickupScriptFunction; // 0xb78	
	float m_flPickupRadius; // 0xb80	
	float m_flTriggerRadius; // 0xb84	
	CUtlSymbolLarge m_pTriggerSoundEffect; // 0xb88	
	bool m_bGlowWhenInTrigger; // 0xb90	
	Color m_glowColor; // 0xb91	
	bool m_bUseable; // 0xb95	
private:
	[[maybe_unused]] uint8_t __pad0b96[0x2]; 	// 0xb96
public:
	CHandle< CItemGenericTriggerHelper > m_hTriggerHelper; // 0xb98	
};

// Alignment: 97
// Size: 0xfb8
class CAI_BaseNPC : public CBaseCombatCharacter
{
public:
	bool m_bCheckContacts; // 0xa60	
	bool m_bIsUsingSmallHull; // 0xa61	
private:
	[[maybe_unused]] uint8_t __pad0a62[0x2]; 	// 0xa62
public:
	Vector m_vecLastPosition; // 0xa64	
	float m_flLastPositionTolerance; // 0xa70	
	AI_Efficiency_t m_Efficiency; // 0xa74	
	AI_MoveEfficiency_t m_MoveEfficiency; // 0xa78	
	AI_SleepState_t m_SleepState; // 0xa7c	
	int32_t m_SleepFlags; // 0xa80	
	float m_flWakeRadius; // 0xa84	
	bool m_bWakeSquad; // 0xa88	
private:
	[[maybe_unused]] uint8_t __pad0a89[0x3]; 	// 0xa89
public:
	int32_t m_nWakeTick; // 0xa8c	
	// MNetworkEnable
	NPC_STATE m_NPCState; // 0xa90	
	NPC_STATE m_IdealNPCState; // 0xa94	
	float m_flLastStateChangeTime; // 0xa98	
private:
	[[maybe_unused]] uint8_t __pad0a9c[0xc]; 	// 0xa9c
public:
	CAI_ScheduleBits m_Conditions; // 0xaa8	
	CAI_ScheduleBits m_NonGatherConditions; // 0xac8	
	CAI_ScheduleBits m_CustomInterruptConditions; // 0xae8	
	bool m_bForceConditionsGather; // 0xb08	
	bool m_bConditionsGathered; // 0xb09	
	bool m_bDoPostRestoreRefindPath; // 0xb0a	
private:
	[[maybe_unused]] uint8_t __pad0b0b[0x5]; 	// 0xb0b
public:
	CAI_BehaviorHost* m_pBehaviorHost; // 0xb10	
	CAI_EnemyServices* m_pEnemyServices; // 0xb18	
	CRandStopwatch m_GiveUpOnDeadEnemyTimer; // 0xb20	
	CSimpleSimTimer m_FailChooseEnemyTimer; // 0xb38	
	float m_flAcceptableTimeSeenEnemy; // 0xb3c	
	bool m_bSkippedChooseEnemy; // 0xb40	
	bool m_bIgnoreUnseenEnemies; // 0xb41	
private:
	[[maybe_unused]] uint8_t __pad0b42[0x2]; 	// 0xb42
public:
	CHandle< CBaseFilter > m_hEnemyFilter; // 0xb44	
	CUtlSymbolLarge m_iszEnemyFilterName; // 0xb48	
	CHandle< CBaseEntity > m_hTargetEnt; // 0xb50	
	float m_flSoundWaitTime; // 0xb54	
	int32_t m_nSoundPriority; // 0xb58	
	bool m_bSuppressFootsteps; // 0xb5c	
private:
	[[maybe_unused]] uint8_t __pad0b5d[0x3]; 	// 0xb5d
public:
	int32_t m_afCapability; // 0xb60	
	float m_flMoveWaitFinished; // 0xb64	
	CHandle< CBaseEntity > m_hOpeningDoor; // 0xb68	
	bool m_bUseAltNpcAvoid; // 0xb6c	
private:
	[[maybe_unused]] uint8_t __pad0b6d[0x3]; 	// 0xb6d
public:
	CUtlVector< UnreachableEnt_t > m_UnreachableEnts; // 0xb70	
	CHandle< CBaseEntity > m_hPathObstructor; // 0xb88	
	float m_flJumpMaxRise; // 0xb8c	
	float m_flJumpMaxDrop; // 0xb90	
	float m_flJumpMaxDist; // 0xb94	
	float m_flJumpMinDist; // 0xb98	
private:
	[[maybe_unused]] uint8_t __pad0b9c[0x4]; 	// 0xb9c
public:
	CAI_AnimGraphServices* m_pAnimGraphServices; // 0xba0	
	bool m_bAnimGraphIsAnimatingDeath; // 0xba8	
	bool m_bDeferredNavigation; // 0xba9	
private:
	[[maybe_unused]] uint8_t __pad0baa[0x6]; 	// 0xbaa
public:
	CAI_Scheduler m_Scheduler; // 0xbb0	
private:
	[[maybe_unused]] uint8_t __pad0c20[0x28]; 	// 0xc20
public:
	CHandle< CBaseEntity > m_hGoalEnt; // 0xc48	
	float m_flTimeLastMovement; // 0xc4c	
	CSimpleSimTimer m_CheckOnGroundTimer; // 0xc50	
private:
	[[maybe_unused]] uint8_t __pad0c54[0x4]; 	// 0xc54
public:
	CUtlSymbolLarge m_strNavRestrictionVolume; // 0xc58	
	// MNetworkEnable
	bool m_bIsMoving; // 0xc60	
private:
	[[maybe_unused]] uint8_t __pad0c61[0x3]; 	// 0xc61
public:
	Vector m_vDefaultEyeOffset; // 0xc64	
	int32_t m_afMemory; // 0xc70	
	float m_flLastDamageTime; // 0xc74	
	Vector m_vecLastDamageAttackVector; // 0xc78	
	float m_flLastPlayerDamageTime; // 0xc84	
	float m_flLastAttackTime; // 0xc88	
private:
	[[maybe_unused]] uint8_t __pad0c8c[0xc]; 	// 0xc8c
public:
	CUtlSymbolLarge m_iszSquadName; // 0xc98	
	CUtlVector< SquadSlotNPCEntry_t > m_vecMySquadSlots; // 0xca0	
	bool m_bIsBelowHalfHealthBefore; // 0xcb8	
	// MNetworkEnable
	bool m_bFadeCorpse; // 0xcb9	
	// MNetworkEnable
	bool m_bImportantRagdoll; // 0xcba	
private:
	[[maybe_unused]] uint8_t __pad0cbb[0x5]; 	// 0xcbb
public:
	CTakeDamageInfo m_deathBlowInfo; // 0xcc0	
	bool m_bDidDeathCleanup; // 0xd60	
	bool m_bReceivedEnemyDeadNotification; // 0xd61	
private:
	[[maybe_unused]] uint8_t __pad0d62[0x2]; 	// 0xd62
public:
	float m_flWaitFinished; // 0xd64	
	bool m_fNoDamageDecal; // 0xd68	
private:
	[[maybe_unused]] uint8_t __pad0d69[0x7]; 	// 0xd69
public:
	CUtlVector< CHandle< CBaseEntity > >* m_pVecAttachments; // 0xd70	
	CEntityIOOutput m_OnDamaged; // 0xd78	
	CEntityIOOutput m_OnDeath; // 0xda0	
	CEntityIOOutput m_OnHalfHealth; // 0xdc8	
	CEntityOutputTemplate< CHandle< CBaseEntity > > m_OnFoundEnemy; // 0xdf0	
	CEntityIOOutput m_OnLostEnemy; // 0xe18	
	CEntityIOOutput m_OnLostPlayer; // 0xe40	
	CEntityIOOutput m_OnDamagedByPlayer; // 0xe68	
	CEntityIOOutput m_OnDamagedByPlayerSquad; // 0xe90	
	CEntityIOOutput m_OnPlayerUse; // 0xeb8	
	CEntityIOOutput m_OnUse; // 0xee0	
	CEntityIOOutput m_OnLostEnemyLOS; // 0xf08	
	CEntityIOOutput m_OnLostPlayerLOS; // 0xf30	
	CEntityIOOutput m_OnSleep; // 0xf58	
	CEntityIOOutput m_OnWake; // 0xf80	
	uint64_t m_nAITraceMask; // 0xfa8	
	int32_t m_nDebugCurIndex; // 0xfb0	
	struct 
	{
		uint8_t m_bInvokingBehaviorIsCurTaskContinuousMove: 1; 		
		uint8_t m_bInvokingBehaviorIsValidEnemy: 1; 		
		uint8_t m_bInvokingBehaviorBestEnemy: 1; 		
		uint8_t m_bInvokingBehaviorShouldIgnoreSound: 1; 		
		uint8_t m_bInvokingBehaviorIsInterruptable: 1; 		
		uint8_t m_bInvokingBehaviorIsNavigationUrgent: 1; 		
		uint8_t m_bInvokingBehaviorOnTakeDamage_React_Alive: 1; 		
		uint8_t m_bInvokingBehaviorQueryHearSound: 1; 		
		uint8_t m_bInvokingBehaviorOnCalcBaseMove: 1; 		
		uint8_t m_bInvokingBehaviorFValidateHintType: 1; 		
		uint8_t m_bInvokingBehaviorShouldAlwaysThink: 1; 		
		uint8_t m_bInvokingBehaviorAimGun: 1; 		
		uint8_t __pad2: 4; // @note: autoaligned
	}; // 16 bits
	static CUtlSymbolLarge &Get_sm_iszPlayerSquad(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_BaseNPC")->m_static_fields[0]->m_instance);};
	static int32_t &Get_sm_nDebugBits(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_BaseNPC")->m_static_fields[1]->m_instance);};
	static int32_t &Get_sm_nDebugPauseIndex(){return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_BaseNPC")->m_static_fields[2]->m_instance);};
};

// Alignment: 1
// Size: 0xfc0
class CAI_TestHull : public CAI_BaseNPC
{
public:
	TestHullMode_t m_nHullMode; // 0xfb8	
	static CAI_TestHull* &Get_s_pTestHulls(){return *reinterpret_cast<CAI_TestHull**>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_TestHull")->m_static_fields[0]->m_instance);};
	static bool &Get_s_bTestHullAcquired(){return *reinterpret_cast<bool*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_TestHull")->m_static_fields[1]->m_instance);};
};

// Alignment: 63
// Size: 0x1290
class CAI_DefaultNPC : public CAI_BaseNPC
{
public:
	CHandle< CBaseModelEntity > m_hFootSweep; // 0xfc0	
	Class_T m_nClassifyAs; // 0xfc4	
	bool m_bCurrentlySeePlayer; // 0xfc8	
private:
	[[maybe_unused]] uint8_t __pad0fc9[0x3]; 	// 0xfc9
public:
	float m_flIgnoreDangerSoundsUntil; // 0xfcc	
	Vector m_vInterruptSavePosition; // 0xfd0	
	Vector m_vSavePosition; // 0xfdc	
	float m_flNextFlinchTime; // 0xfe8	
	float m_flLastHeavyDamageTime; // 0xfec	
	float m_flLastLightDamageTime; // 0xff0	
	float m_flLastRepeatedDamageTime; // 0xff4	
	Flinch_DamageClasses_t m_nUpcomingFlinchClass; // 0xff8	
	Flinch_Direction_t m_nUpcomingFlinchDir; // 0xffc	
	Flinch_Displacement_t m_nUpcomingFlinchDisplacement; // 0x1000	
	bool m_bFlinchingWithDisplacement; // 0x1004	
private:
	[[maybe_unused]] uint8_t __pad1005[0x3]; 	// 0x1005
public:
	CUtlStringToken m_sAnimGraphFlinchFinishedTag; // 0x1008	
	float m_flDistTooFar; // 0x100c	
	CEntityIOOutput m_OnForcedInteractionStarted; // 0x1010	
	CEntityIOOutput m_OnForcedInteractionAborted; // 0x1038	
	CEntityIOOutput m_OnForcedInteractionFinished; // 0x1060	
	CAI_DynamicInteractions* m_pDynamicInteractions; // 0x1088	
private:
	[[maybe_unused]] uint8_t __pad1090[0x4]; 	// 0x1090
public:
	float m_flWaitAtPathCornerResumeTime; // 0x1094	
private:
	[[maybe_unused]] uint8_t __pad1098[0x40]; 	// 0x1098
public:
	bool m_bAnimGraphHideUntilScriptStart; // 0x10d8	
private:
	[[maybe_unused]] uint8_t __pad10d9[0x17]; 	// 0x10d9
public:
	float m_flOriginalYaw; // 0x10f0	
	bool m_bLatchedEyeCached; // 0x10f4	
private:
	[[maybe_unused]] uint8_t __pad10f5[0x3]; 	// 0x10f5
public:
	Vector m_latchedEyeDirection; // 0x10f8	
private:
	[[maybe_unused]] uint8_t __pad1104[0x4]; 	// 0x1104
public:
	// MNetworkEnable
	CAI_StanceServices* m_pStanceServices; // 0x1108	
	// MNetworkEnable
	// MNetworkTypeAlias "CAI_AbilityServices"
	// MNetworkChangeCallback "AbilityServicesChanged"
	CAI_AbilityServices* m_pAbilityServices; // 0x1110	
	float m_flSumDamage; // 0x1118	
	int32_t m_nDamagesInSum; // 0x111c	
	float m_flLastSawPlayerTime; // 0x1120	
private:
	[[maybe_unused]] uint8_t __pad1124[0x4]; 	// 0x1124
public:
	CUtlSymbolLarge m_strHintGroup; // 0x1128	
private:
	[[maybe_unused]] uint8_t __pad1130[0x10]; 	// 0x1130
public:
	bool m_bInAScript; // 0x1140	
private:
	[[maybe_unused]] uint8_t __pad1141[0x3]; 	// 0x1141
public:
	Interruptability_t m_nScriptedIgnoreConditions; // 0x1144	
	bool m_bFaceLookTarget; // 0x1148	
	bool m_bEnableRandomLookAts; // 0x1149	
private:
	[[maybe_unused]] uint8_t __pad114a[0x2]; 	// 0x114a
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hServerRagdoll; // 0x114c	
	float m_flTempRagdolledAt; // 0x1150	
	float m_flAutoUnragdollDuration; // 0x1154	
	float m_flAutoUnragdollTimer; // 0x1158	
	float m_flUnragdollTimeoutDuration; // 0x115c	
	float m_flUnragdollTimeoutTimer; // 0x1160	
	Vector m_vecUnragdollLocation; // 0x1164	
	int32_t m_nSpawnAsRagdoll; // 0x1170	
private:
	[[maybe_unused]] uint8_t __pad1174[0xc]; 	// 0x1174
public:
	CUtlVector< attached_item_t > m_vecAttachedItems; // 0x1180	
	bool m_bAvoidPlayerState; // 0x1198	
	bool m_bPerformAvoidance; // 0x1199	
private:
	[[maybe_unused]] uint8_t __pad119a[0x2]; 	// 0x119a
public:
	CHandle< CBaseEntity > m_hItem; // 0x119c	
	CEntityOutputTemplate< CHandle< CBaseEntity > > m_OnFoundPlayer; // 0x11a0	
	CEntityIOOutput m_OnHearWorld; // 0x11c8	
	CEntityIOOutput m_OnHearPlayer; // 0x11f0	
	CEntityIOOutput m_OnHearCombat; // 0x1218	
	CEntityIOOutput m_OnUnragdollFinished; // 0x1240	
	CHandle< CBaseEntity > m_hObjectThrownAtMe; // 0x1268	
	CHandle< CBaseEntity > m_hObjectThrownAtMeThrower; // 0x126c	
	// MNetworkEnable
	bool m_bPoweredRagdoll; // 0x1270	
private:
	[[maybe_unused]] uint8_t __pad1271[0x3]; 	// 0x1271
public:
	// MNetworkEnable
	RagdollBlendDirection m_iPoweredRagdoll_TransitionDirection; // 0x1274	
	// MNetworkEnable
	float m_flPoweredRagdoll_TransitionStartTime; // 0x1278	
	Vector m_vecRagdollOffset; // 0x127c	
	struct 
	{
		uint8_t m_bInvokingBehaviorGetReasonableFacingDist: 1; 		
		uint8_t m_bInvokingBehaviorCanFlinch: 1; 		
		uint8_t m_bInvokingBehaviorCanRunAScriptedNPCInteraction: 1; 		
		uint8_t m_bInvokingBehaviorShouldAvoidPlayer: 1; 		
		uint8_t m_bInvokingBehaviorTacticalServicesModifyGoal: 1; 		
		uint8_t __pad3: 5; // @note: autoaligned
	}; // 10 bits
};

// Alignment: 30
// Size: 0x1340
class CAI_TrackPather : public CAI_DefaultNPC
{
public:
	Vector m_vecDesiredPosition; // 0x1290	
	Vector m_vecGoalOrientation; // 0x129c	
	CHandle< CPathTrack > m_pCurrentPathTarget; // 0x12a8	
	CHandle< CPathTrack > m_pDestPathTarget; // 0x12ac	
	CHandle< CPathTrack > m_pLastPathTarget; // 0x12b0	
	CHandle< CPathTrack > m_pTargetNearestPath; // 0x12b4	
	CUtlSymbolLarge m_strCurrentPathName; // 0x12b8	
	CUtlSymbolLarge m_strDestPathName; // 0x12c0	
	CUtlSymbolLarge m_strLastPathName; // 0x12c8	
	CUtlSymbolLarge m_strTargetNearestPathName; // 0x12d0	
	Vector m_vecLastGoalCheckPosition; // 0x12d8	
	float m_flEnemyPathUpdateTime; // 0x12e4	
	bool m_bForcedMove; // 0x12e8	
	bool m_bPatrolling; // 0x12e9	
	bool m_bPatrolBreakable; // 0x12ea	
	bool m_bLeading; // 0x12eb	
	float m_flTargetDistanceThreshold; // 0x12ec	
	float m_flAvoidDistance; // 0x12f0	
	float m_flTargetTolerance; // 0x12f4	
	Vector m_vecSegmentStartPoint; // 0x12f8	
	Vector m_vecSegmentStartSplinePoint; // 0x1304	
	bool m_bMovingForward; // 0x1310	
	bool m_bChooseFarthestPoint; // 0x1311	
private:
	[[maybe_unused]] uint8_t __pad1312[0x2]; 	// 0x1312
public:
	float m_flFarthestPathDist; // 0x1314	
	float m_flPathMaxSpeed; // 0x1318	
	float m_flTargetDistFromPath; // 0x131c	
	float m_flLeadDistance; // 0x1320	
	Vector m_vecTargetPathDir; // 0x1324	
	Vector m_vecTargetPathPoint; // 0x1330	
	CAI_TrackPather::PauseState_t m_nPauseState; // 0x133c	
};

// Alignment: 2
// Size: 0x12c8
class CAI_BasePhysicsFlyingBot : public CAI_DefaultNPC
{
public:
	CFlightComponent m_flight; // 0x1290	
	float m_fHeadYaw; // 0x12c0	
};

// Alignment: 6
// Size: 0x12f8
class CNPC_Bullseye : public CAI_DefaultNPC
{
public:
	CHandle< CBaseEntity > m_hPainPartner; // 0x1290	
private:
	[[maybe_unused]] uint8_t __pad1294[0x4]; 	// 0x1294
public:
	CEntityIOOutput m_OnTargeted; // 0x1298	
	CEntityIOOutput m_OnReleased; // 0x12c0	
	bool m_bPerfectAccuracy; // 0x12e8	
private:
	[[maybe_unused]] uint8_t __pad12e9[0x3]; 	// 0x12e9
public:
	float m_fAutoaimRadius; // 0x12ec	
	float m_flMinDistValidEnemy; // 0x12f0	
};

// Alignment: 8
// Size: 0x1358
class CNPC_EnemyFinder : public CAI_DefaultNPC
{
public:
	int32_t m_nStartOn; // 0x1290	
	float m_flMinSearchDist; // 0x1294	
	float m_flMaxSearchDist; // 0x1298	
private:
	[[maybe_unused]] uint8_t __pad129c[0x4]; 	// 0x129c
public:
	CAI_FreePass m_PlayerFreePass; // 0x12a0	
	CSimpleSimTimer m_ChooseEnemyTimer; // 0x1300	
	bool m_bEnemyStatus; // 0x1304	
private:
	[[maybe_unused]] uint8_t __pad1305[0x3]; 	// 0x1305
public:
	CEntityIOOutput m_OnLostEnemies; // 0x1308	
	CEntityIOOutput m_OnAcquireEnemies; // 0x1330	
	static CUtlSymbolLarge &Get_SCHED_EFINDER_SEARCH(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CNPC_EnemyFinder")->m_static_fields[0]->m_instance);};
};

// Alignment: 3
// Size: 0x12a0
class CNPC_Proxy : public CAI_DefaultNPC
{
public:
	CUtlSymbolLarge m_representedEntityName; // 0x1290	
	CHandle< CBaseEntity > m_hRepresentedEnt; // 0x1298	
	int32_t m_nPriority; // 0x129c	
};

// Alignment: 1
// Size: 0x1298
class CNPC_Appliance : public CAI_DefaultNPC
{
public:
	bool m_bDisabled; // 0x1290	
};

// Alignment: 24
// Size: 0xbe0
class CBasePlayerController : public CBaseCombatCharacter
{
public:
	// MNetworkEnable
	// MNetworkPriority "1"
	// MNetworkUserGroup "LocalPlayerExclusive"
	uint32_t m_nTickBase; // 0xa60	
private:
	[[maybe_unused]] uint8_t __pad0a64[0x2c]; 	// 0xa64
public:
	// MNetworkEnable
	// MNetworkChangeCallback "OnPawnChanged"
	CHandle< CBasePlayer > m_hPawn; // 0xa90	
	CSplitScreenSlot m_nSplitScreenSlot; // 0xa94	
	CHandle< CBasePlayerController > m_hSplitOwner; // 0xa98	
private:
	[[maybe_unused]] uint8_t __pad0a9c[0x4]; 	// 0xa9c
public:
	CUtlVector< CHandle< CBasePlayerController > > m_hSplitScreenPlayers; // 0xaa0	
	bool m_bIsHLTV; // 0xab8	
private:
	[[maybe_unused]] uint8_t __pad0ab9[0x3]; 	// 0xab9
public:
	PlayerConnectedState m_iConnected; // 0xabc	
	char m_iszPlayerName[128]; // 0xac0	
	CUtlString m_szNetworkIDString; // 0xb40	
	int32_t m_nUpdateRate; // 0xb48	
	float m_fLerpTime; // 0xb4c	
	bool m_bLagCompensation; // 0xb50	
	bool m_bPredict; // 0xb51	
	bool m_bAutoKickDisabled; // 0xb52	
	bool m_bIsLowViolence; // 0xb53	
	bool m_bGamePaused; // 0xb54	
private:
	[[maybe_unused]] uint8_t __pad0b55[0x4b]; 	// 0xb55
public:
	int32_t m_nHighestCommandNumberReceived; // 0xba0	
private:
	[[maybe_unused]] uint8_t __pad0ba4[0x4]; 	// 0xba4
public:
	int64_t m_nUsecTimestampLastUserCmdReceived; // 0xba8	
private:
	[[maybe_unused]] uint8_t __pad0bb0[0x10]; 	// 0xbb0
public:
	ChatIgnoreType_t m_iIgnoreGlobalChat; // 0xbc0	
	float m_flLastPlayerTalkTime; // 0xbc4	
	float m_flLastEntitySteadyState; // 0xbc8	
	int32_t m_nAvailableEntitySteadyState; // 0xbcc	
	bool m_bHasAnySteadyStateEnts; // 0xbd0	
private:
	[[maybe_unused]] uint8_t __pad0bd1[0x7]; 	// 0xbd1
public:
	uint64_t m_steamID; // 0xbd8	
};

// Alignment: 28
// Size: 0xda0
class CBasePlayer : public CBasePlayerController
{
public:
	// MNetworkEnable
	CPlayer_WeaponServices* m_pWeaponServices; // 0xbe0	
	// MNetworkEnable
	CPlayer_ItemServices* m_pItemServices; // 0xbe8	
	// MNetworkEnable
	CPlayer_VehicleServices* m_pVehicleServices; // 0xbf0	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	CPlayer_AutoaimServices* m_pAutoaimServices; // 0xbf8	
	// MNetworkEnable
	CPlayer_ObserverServices* m_pObserverServices; // 0xc00	
	// MNetworkEnable
	CPlayer_WaterServices* m_pWaterServices; // 0xc08	
	// MNetworkEnable
	CPlayer_UseServices* m_pUseServices; // 0xc10	
	// MNetworkEnable
	CPlayer_FlashlightServices* m_pFlashlightServices; // 0xc18	
	// MNetworkEnable
	CPlayer_CameraServices* m_pCameraServices; // 0xc20	
	// MNetworkEnable
	CPlayer_MovementServices* m_pMovementServices; // 0xc28	
private:
	[[maybe_unused]] uint8_t __pad0c30[0x8]; 	// 0xc30
public:
	uint64_t m_nButtons; // 0xc38	
	uint64_t m_afButtonPressed; // 0xc40	
	uint64_t m_afButtonReleased; // 0xc48	
	uint64_t m_afButtonLast; // 0xc50	
	uint64_t m_afButtonDisabled; // 0xc58	
	uint64_t m_afButtonForced; // 0xc60	
private:
	[[maybe_unused]] uint8_t __pad0c68[0x50]; 	// 0xc68
public:
	uint64_t m_nOldButtons; // 0xcb8	
	int32_t m_nImpulse; // 0xcc0	
	QAngle v_angle; // 0xcc4	
private:
	[[maybe_unused]] uint8_t __pad0cd0[0x10]; 	// 0xcd0
public:
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	uint32_t m_iHideHUD; // 0xce0	
private:
	[[maybe_unused]] uint8_t __pad0ce4[0x4]; 	// 0xce4
public:
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	sky3dparams_t m_skybox3d; // 0xce8	
	float m_fTimeLastHurt; // 0xd78	
	// MNetworkEnable
	// MNetworkUserGroup "LocalPlayerExclusive"
	float m_flDeathTime; // 0xd7c	
	float m_fNextSuicideTime; // 0xd80	
	bool m_fInitHUD; // 0xd84	
private:
	[[maybe_unused]] uint8_t __pad0d85[0x3]; 	// 0xd85
public:
	float m_flNextDecalTime; // 0xd88	
	bool deadflag; // 0xd8c	
private:
	[[maybe_unused]] uint8_t __pad0d8d[0x3]; 	// 0xd8d
public:
	CAI_Expresser* m_pExpresser; // 0xd90	
};

// Alignment: 14
// Size: 0x12f0
class CAI_BaseActor : public CAI_DefaultNPC
{
public:
	bool m_bCanBlink; // 0x1298	
private:
	[[maybe_unused]] uint8_t __pad1299[0x3]; 	// 0x1299
public:
	float m_flBlinktime; // 0x129c	
	CUtlSymbolLarge m_iszExpressionScene; // 0x12a0	
	CHandle< CBaseEntity > m_hExpressionSceneEnt; // 0x12a8	
	float m_flNextRandomExpressionTime; // 0x12ac	
	CUtlSymbolLarge m_iszExpressionOverride; // 0x12b0	
	CUtlSymbolLarge m_iszIdleExpression; // 0x12b8	
	CUtlSymbolLarge m_iszAlertExpression; // 0x12c0	
	CUtlSymbolLarge m_iszCombatExpression; // 0x12c8	
	CUtlSymbolLarge m_iszDeathExpression; // 0x12d0	
	bool m_bRemarkablePolling; // 0x12d8	
private:
	[[maybe_unused]] uint8_t __pad12d9[0x3]; 	// 0x12d9
public:
	float m_fNextRemarkPollTime; // 0x12dc	
	bool m_bDontUseSemaphore; // 0x12e0	
private:
	[[maybe_unused]] uint8_t __pad12e1[0x7]; 	// 0x12e1
public:
	CAI_Expresser* m_pExpresser; // 0x12e8	
};

// Alignment: 15
// Size: 0x1520
class CAI_PlayerAlly : public CAI_BaseActor
{
public:
	CRR_Response m_PendingResponse; // 0x12f0	
	CUtlString m_PendingConcept; // 0x14e0	
	float m_TimePendingSet; // 0x14e8	
	CHandle< CBaseEntity > m_hTalkTarget; // 0x14ec	
	float m_flNextRegenTime; // 0x14f0	
	float m_flTimePlayerStartStare; // 0x14f4	
	CHandle< CBaseEntity > m_hPotentialSpeechTarget; // 0x14f8	
	float m_flNextIdleSpeechTime; // 0x14fc	
	int32_t m_iQARandomNumber; // 0x1500	
	CSimpleSimTimer m_ConceptCategoryTimers[3]; // 0x1504	
	CHandle< CAI_SpeechFilter > m_hSpeechFilter; // 0x1510	
	bool m_bGameEndAlly; // 0x1514	
	bool m_bCanSpeakWhileScripting; // 0x1515	
private:
	[[maybe_unused]] uint8_t __pad1516[0x2]; 	// 0x1516
public:
	float m_flTimeLastRegen; // 0x1518	
	float m_flHealthAccumulator; // 0x151c	
	static CUtlSymbolLarge &Get_SCHED_TALKER_SPEAK_PENDING_IDLE(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[0]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_TALKER_SPEAK_PENDING_ALERT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[1]->m_instance);};
	static CUtlSymbolLarge &Get_SCHED_TALKER_SPEAK_PENDING_COMBAT(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[2]->m_instance);};
	static CUtlSymbolLarge &Get_TASK_TALKER_SPEAK_PENDING(){return *reinterpret_cast<CUtlSymbolLarge*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[3]->m_instance);};
	static ConditionId_t &Get_COND_TALKER_CLIENTUNSEEN(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[4]->m_instance);};
	static ConditionId_t &Get_COND_TALKER_PLAYER_DEAD(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[5]->m_instance);};
	static ConditionId_t &Get_COND_TALKER_PLAYER_STARING(){return *reinterpret_cast<ConditionId_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CAI_PlayerAlly")->m_static_fields[6]->m_instance);};
};

// Alignment: 4
// Size: 0x1308
class CGenericActor : public CAI_BaseActor
{
public:
	bool m_bWantsTeleportBuffer; // 0x12f0	
private:
	[[maybe_unused]] uint8_t __pad12f1[0x7]; 	// 0x12f1
public:
	CUtlSymbolLarge m_strHullName; // 0x12f8	
	bool m_bActLikeAFlyer; // 0x1300	
	bool m_bIsFriendlyNPC; // 0x1301	
};

// Alignment: 2
// Size: 0x12f8
class CNPC_Furniture : public CAI_BaseActor
{
public:
	bool m_bHasAnimatedFace; // 0x12f0	
	bool m_bFurniturePhysics; // 0x12f1	
};

// Alignment: 0
// Size: 0x12f8
class CGhostSpeaker : public CNPC_Furniture
{
public:
	// @note: no members available
};

// Alignment: 21
// Size: 0xed0
class CSteamPal_Player : public CBasePlayer
{
public:
	// MNetworkEnable
	CHandle< CBaseEntity > m_hCursorHoverEntity; // 0xe28	
	CHandle< CBaseEntity > m_hCurrentUserTouchEntity; // 0xe2c	
	Vector m_vCurrentUserTouchHitPoint; // 0xe30	
	Vector m_vCurrentScreenTouchPos; // 0xe3c	
	bool m_bIsUserTouchActive; // 0xe48	
private:
	[[maybe_unused]] uint8_t __pad0e49[0x3]; 	// 0xe49
public:
	CHandle< CSteamPal_TouchTarget > m_hCurrentTouchTarget; // 0xe4c	
	bool m_bInFreecam; // 0xe50	
private:
	[[maybe_unused]] uint8_t __pad0e51[0x3]; 	// 0xe51
public:
	Vector2D m_flCameraLookRangePitch; // 0xe54	
	Vector2D m_flCameraLookRangeYaw; // 0xe5c	
	float m_flCameraLookSpeed; // 0xe64	
	float m_flCameraLookOffsetPitch; // 0xe68	
	float m_flCameraLookOffsetYaw; // 0xe6c	
private:
	[[maybe_unused]] uint8_t __pad0e70[0x8]; 	// 0xe70
public:
	Vector2D m_flCameraMoveRangeLR; // 0xe78	
	Vector2D m_flCameraMoveRangeFB; // 0xe80	
	float m_flCameraMoveSpeed; // 0xe88	
	float m_flCameraMoveOffsetLR; // 0xe8c	
	float m_flCameraMoveOffsetFB; // 0xe90	
private:
	[[maybe_unused]] uint8_t __pad0e94[0x1]; 	// 0xe94
public:
	// MNetworkEnable
	bool m_bMotionBlur; // 0xe95	
private:
	[[maybe_unused]] uint8_t __pad0e96[0x2]; 	// 0xe96
public:
	// MNetworkEnable
	CUtlString m_strPlayerName; // 0xe98	
	// MNetworkEnable
	uint64_t m_uDamageCaused; // 0xea0	
	CEntityIOOutput m_OnScreenshotTaken; // 0xea8	
};

